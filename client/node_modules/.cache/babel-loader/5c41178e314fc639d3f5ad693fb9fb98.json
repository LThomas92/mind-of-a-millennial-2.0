{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _assertThisInitialized = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _getPrototypeOf = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _require = require(\"../helpers/selectors\"),\n    addNwsapi = _require.addNwsapi;\n\nvar _require2 = require(\"../helpers/namespaces\"),\n    HTML_NS = _require2.HTML_NS;\n\nvar _require3 = require(\"../../utils\"),\n    mixin = _require3.mixin,\n    memoizeQuery = _require3.memoizeQuery;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar NodeImpl = require(\"./Node-impl\").implementation;\n\nvar ParentNodeImpl = require(\"./ParentNode-impl\").implementation;\n\nvar ChildNodeImpl = require(\"./ChildNode-impl\").implementation;\n\nvar attributes = require(\"../attributes\");\n\nvar namedPropertiesWindow = require(\"../named-properties-window\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar _require4 = require(\"../../browser/domtohtml\"),\n    domToHtml = _require4.domToHtml;\n\nvar _require5 = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require5.domSymbolTree;\n\nvar DOMException = require(\"domexception\");\n\nvar DOMTokenList = require(\"../generated/DOMTokenList\");\n\nvar attrGenerated = require(\"../generated/Attr\");\n\nvar NamedNodeMap = require(\"../generated/NamedNodeMap\");\n\nvar validateNames = require(\"../helpers/validate-names\");\n\nvar _require6 = require(\"../helpers/strings\"),\n    asciiLowercase = _require6.asciiLowercase;\n\nvar _require7 = require(\"../node\"),\n    clone = _require7.clone,\n    listOfElementsWithQualifiedName = _require7.listOfElementsWithQualifiedName,\n    listOfElementsWithNamespaceAndLocalName = _require7.listOfElementsWithNamespaceAndLocalName,\n    listOfElementsWithClassNames = _require7.listOfElementsWithClassNames;\n\nvar NonDocumentTypeChildNode = require(\"./NonDocumentTypeChildNode-impl\").implementation;\n\nfunction clearChildNodes(node) {\n  for (var child = domSymbolTree.firstChild(node); child; child = domSymbolTree.firstChild(node)) {\n    node.removeChild(child);\n  }\n}\n\nfunction setInnerHTML(document, node, html) {\n  // Clear the children first:\n  if (node._templateContents) {\n    clearChildNodes(node._templateContents);\n  } else {\n    clearChildNodes(node);\n  }\n\n  if (node.nodeName === \"#document\") {\n    document._htmlToDom.appendToDocument(html, node);\n  } else {\n    document._htmlToDom.appendToNode(html, node);\n  }\n}\n\nfunction attachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (!doc._ids[id]) {\n      doc._ids[id] = [];\n    }\n\n    doc._ids[id].push(elm);\n  }\n}\n\nfunction detachId(id, elm, doc) {\n  if (id && elm && doc) {\n    if (doc._ids && doc._ids[id]) {\n      var elms = doc._ids[id];\n\n      for (var i = 0; i < elms.length; i++) {\n        if (elms[i] === elm) {\n          elms.splice(i, 1);\n          --i;\n        }\n      }\n\n      if (elms.length === 0) {\n        delete doc._ids[id];\n      }\n    }\n  }\n}\n\nvar ElementImpl =\n/*#__PURE__*/\nfunction (_NodeImpl) {\n  _inherits(ElementImpl, _NodeImpl);\n\n  function ElementImpl(args, privateData) {\n    var _this;\n\n    _classCallCheck(this, ElementImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementImpl).call(this, args, privateData));\n    _this.nodeType = NODE_TYPE.ELEMENT_NODE;\n    _this.scrollTop = 0;\n    _this.scrollLeft = 0;\n    _this._namespaceURI = privateData.namespace || null;\n    _this._prefix = null;\n    _this._localName = privateData.localName;\n    _this._attributeList = []; // Used for caching.\n\n    _this._attributesByNameMap = new Map();\n    _this._attributes = NamedNodeMap.createImpl([], {\n      element: _assertThisInitialized(_this)\n    });\n    return _this;\n  }\n\n  _createClass(ElementImpl, [{\n    key: \"_attach\",\n    value: function _attach() {\n      namedPropertiesWindow.nodeAttachedToDocument(this);\n      var id = this.getAttribute(\"id\");\n\n      if (id) {\n        attachId(id, this, this._ownerDocument);\n      }\n\n      _get(_getPrototypeOf(ElementImpl.prototype), \"_attach\", this).call(this);\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      _get(_getPrototypeOf(ElementImpl.prototype), \"_detach\", this).call(this);\n\n      namedPropertiesWindow.nodeDetachedFromDocument(this);\n      var id = this.getAttribute(\"id\");\n\n      if (id) {\n        detachId(id, this, this._ownerDocument);\n      }\n    }\n  }, {\n    key: \"_attrModified\",\n    value: function _attrModified(name, value, oldValue) {\n      this._modified();\n\n      namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);\n\n      if (name === \"id\" && this._attached) {\n        var doc = this._ownerDocument;\n        detachId(oldValue, this, doc);\n        attachId(value, this, doc);\n      } // update classList\n\n\n      if (name === \"class\" && this._classList !== undefined) {\n        this._classList.attrModified();\n      }\n    }\n  }, {\n    key: \"hasAttributes\",\n    value: function hasAttributes() {\n      return attributes.hasAttributes(this);\n    }\n  }, {\n    key: \"getAttributeNames\",\n    value: function getAttributeNames() {\n      return attributes.attributeNames(this);\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      var attr = attributes.getAttributeByName(this, name);\n\n      if (!attr) {\n        return null;\n      }\n\n      return attr._value;\n    }\n  }, {\n    key: \"getAttributeNS\",\n    value: function getAttributeNS(namespace, localName) {\n      var attr = attributes.getAttributeByNameNS(this, namespace, localName);\n\n      if (!attr) {\n        return null;\n      }\n\n      return attr._value;\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      validateNames.name(name);\n\n      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        name = asciiLowercase(name);\n      }\n\n      var attribute = attributes.getAttributeByName(this, name);\n\n      if (attribute === null) {\n        var newAttr = attrGenerated.createImpl([], {\n          localName: name,\n          value: value\n        });\n        attributes.appendAttribute(this, newAttr);\n        return;\n      }\n\n      attributes.changeAttribute(this, attribute, value);\n    }\n  }, {\n    key: \"setAttributeNS\",\n    value: function setAttributeNS(namespace, name, value) {\n      var extracted = validateNames.validateAndExtract(namespace, name);\n      attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      attributes.removeAttributeByName(this, name);\n    }\n  }, {\n    key: \"removeAttributeNS\",\n    value: function removeAttributeNS(namespace, localName) {\n      attributes.removeAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        name = asciiLowercase(name);\n      }\n\n      return attributes.hasAttributeByName(this, name);\n    }\n  }, {\n    key: \"hasAttributeNS\",\n    value: function hasAttributeNS(namespace, localName) {\n      if (namespace === \"\") {\n        namespace = null;\n      }\n\n      return attributes.hasAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"getAttributeNode\",\n    value: function getAttributeNode(name) {\n      return attributes.getAttributeByName(this, name);\n    }\n  }, {\n    key: \"getAttributeNodeNS\",\n    value: function getAttributeNodeNS(namespace, localName) {\n      return attributes.getAttributeByNameNS(this, namespace, localName);\n    }\n  }, {\n    key: \"setAttributeNode\",\n    value: function setAttributeNode(attr) {\n      return attributes.setAttribute(this, attr);\n    }\n  }, {\n    key: \"setAttributeNodeNS\",\n    value: function setAttributeNodeNS(attr) {\n      return attributes.setAttribute(this, attr);\n    }\n  }, {\n    key: \"removeAttributeNode\",\n    value: function removeAttributeNode(attr) {\n      if (!attributes.hasAttribute(this, attr)) {\n        throw new DOMException(\"Tried to remove an attribute that was not present\", \"NotFoundError\");\n      }\n\n      attributes.removeAttribute(this, attr);\n      return attr;\n    }\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect() {\n      return {\n        bottom: 0,\n        height: 0,\n        left: 0,\n        right: 0,\n        top: 0,\n        width: 0\n      };\n    }\n  }, {\n    key: \"getClientRects\",\n    value: function getClientRects() {\n      return [];\n    }\n  }, {\n    key: \"insertAdjacentHTML\",\n    // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml\n    value: function insertAdjacentHTML(position, text) {\n      position = position.toLowerCase();\n      var context;\n\n      switch (position) {\n        case \"beforebegin\":\n        case \"afterend\":\n          {\n            context = this.parentNode;\n\n            if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n              throw new DOMException(\"Cannot insert HTML adjacent to \" + \"parent-less nodes or children of document nodes.\", \"NoModificationAllowedError\");\n            }\n\n            break;\n          }\n\n        case \"afterbegin\":\n        case \"beforeend\":\n          {\n            context = this;\n            break;\n          }\n\n        default:\n          {\n            throw new DOMException(\"Must provide one of \\\"beforebegin\\\", \\\"afterend\\\", \" + \"\\\"afterbegin\\\", or \\\"beforeend\\\".\", \"SyntaxError\");\n          }\n      } // TODO: use context for parsing instead of a <template>.\n\n\n      var fragment = this.ownerDocument.createElement(\"template\");\n      fragment.innerHTML = text;\n\n      switch (position) {\n        case \"beforebegin\":\n          {\n            this.parentNode.insertBefore(fragment.content, this);\n            break;\n          }\n\n        case \"afterbegin\":\n          {\n            this.insertBefore(fragment.content, this.firstChild);\n            break;\n          }\n\n        case \"beforeend\":\n          {\n            this.appendChild(fragment.content);\n            break;\n          }\n\n        case \"afterend\":\n          {\n            this.parentNode.insertBefore(fragment.content, this.nextSibling);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"closest\",\n    value: function closest(selectors) {\n      var matcher = addNwsapi(this);\n      return matcher.closest(selectors, idlUtils.wrapperForImpl(this));\n    }\n  }, {\n    key: \"namespaceURI\",\n    get: function get() {\n      return this._namespaceURI;\n    }\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      return this._prefix;\n    }\n  }, {\n    key: \"localName\",\n    get: function get() {\n      return this._localName;\n    }\n  }, {\n    key: \"_qualifiedName\",\n    get: function get() {\n      return this._prefix !== null ? this._prefix + \":\" + this._localName : this._localName;\n    }\n  }, {\n    key: \"tagName\",\n    get: function get() {\n      var qualifiedName = this._qualifiedName;\n\n      if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === \"html\") {\n        qualifiedName = qualifiedName.toUpperCase();\n      }\n\n      return qualifiedName;\n    }\n  }, {\n    key: \"attributes\",\n    get: function get() {\n      return this._attributes;\n    }\n  }, {\n    key: \"outerHTML\",\n    get: function get() {\n      return domToHtml([this]);\n    },\n    set: function set(html) {\n      if (html === null) {\n        html = \"\";\n      }\n\n      var parent = domSymbolTree.parent(this);\n      var document = this._ownerDocument;\n\n      if (!parent) {\n        return;\n      }\n\n      var contextElement;\n\n      if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        throw new DOMException(\"Modifications are not allowed for this document\", \"NoModificationAllowedError\");\n      } else if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        contextElement = document.createElementNS(HTML_NS, \"body\");\n      } else if (parent.nodeType === NODE_TYPE.ELEMENT_NODE) {\n        contextElement = clone(parent, undefined, false);\n      } else {\n        throw new TypeError(\"This should never happen\");\n      }\n\n      document._htmlToDom.appendToNode(html, contextElement);\n\n      while (contextElement.firstChild) {\n        parent.insertBefore(contextElement.firstChild, this);\n      }\n\n      parent.removeChild(this);\n    }\n  }, {\n    key: \"innerHTML\",\n    get: function get() {\n      // TODO is this necessary? I would have thought this would be handled at a different level.\n      var tagName = this.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        var type = this.getAttribute(\"type\");\n\n        if (!type || /^text\\//i.test(type) || /\\/javascript$/i.test(type)) {\n          return domToHtml(domSymbolTree.childrenIterator(this));\n        }\n      } // In case of <template> we should pass its \"template contents\" fragment as a serialization root if we have one\n\n\n      if (this._templateContents) {\n        return domToHtml(domSymbolTree.childrenIterator(this._templateContents));\n      }\n\n      return domToHtml(domSymbolTree.childrenIterator(this));\n    },\n    set: function set(html) {\n      if (html === null) {\n        html = \"\";\n      }\n\n      setInnerHTML(this.ownerDocument, this, html);\n    }\n  }, {\n    key: \"classList\",\n    get: function get() {\n      if (this._classList === undefined) {\n        this._classList = DOMTokenList.createImpl([], {\n          element: this,\n          attributeLocalName: \"class\"\n        });\n      }\n\n      return this._classList;\n    }\n  }, {\n    key: \"scrollWidth\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"scrollHeight\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientTop\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientLeft\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientWidth\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"clientHeight\",\n    get: function get() {\n      return 0;\n    }\n  }]);\n\n  return ElementImpl;\n}(NodeImpl);\n\nmixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);\nmixin(ElementImpl.prototype, ParentNodeImpl.prototype);\nmixin(ElementImpl.prototype, ChildNodeImpl.prototype);\nElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {\n  return listOfElementsWithQualifiedName(qualifiedName, this);\n});\nElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {\n  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);\n});\nElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {\n  return listOfElementsWithClassNames(classNames, this);\n});\nElementImpl.prototype.matches = memoizeQuery(function (selectors) {\n  var matcher = addNwsapi(this);\n  return matcher.match(selectors, idlUtils.wrapperForImpl(this));\n});\nElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;\nmodule.exports = {\n  implementation: ElementImpl\n};","map":null,"metadata":{},"sourceType":"script"}