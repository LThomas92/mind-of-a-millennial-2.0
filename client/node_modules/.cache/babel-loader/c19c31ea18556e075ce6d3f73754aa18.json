{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DocumentType = require(\"../living/generated/DocumentType\");\n\nvar DocumentFragment = require(\"../living/generated/DocumentFragment\");\n\nvar Text = require(\"../living/generated/Text\");\n\nvar Comment = require(\"../living/generated/Comment\");\n\nvar attributes = require(\"../living/attributes\");\n\nvar nodeTypes = require(\"../living/node-type\");\n\nvar serializationAdapter = require(\"./parse5-adapter-serialization\");\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function JSDOMParse5Adapter(documentImpl) {\n    _classCallCheck(this, JSDOMParse5Adapter);\n\n    this._documentImpl = documentImpl;\n  }\n\n  _createClass(JSDOMParse5Adapter, [{\n    key: \"createDocument\",\n    value: function createDocument() {\n      // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n      // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n      // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n      // return the already-created Document when asked by parse5 to \"create\" a Document.\n      return this._documentImpl;\n    }\n  }, {\n    key: \"createDocumentFragment\",\n    value: function createDocumentFragment() {\n      return DocumentFragment.createImpl([], {\n        ownerDocument: this._documentImpl\n      });\n    }\n  }, {\n    key: \"createElement\",\n    value: function createElement(localName, namespace, attrs) {\n      var element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n\n      element._namespaceURI = namespace;\n      this.adoptAttributes(element, attrs);\n\n      if (\"_parserInserted\" in element) {\n        element._parserInserted = true;\n      }\n\n      return element;\n    }\n  }, {\n    key: \"createCommentNode\",\n    value: function createCommentNode(data) {\n      return Comment.createImpl([], {\n        data: data,\n        ownerDocument: this._documentImpl\n      });\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(parentNode, newNode) {\n      parentNode.appendChild(newNode);\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(parentNode, newNode, referenceNode) {\n      parentNode.insertBefore(newNode, referenceNode);\n    }\n  }, {\n    key: \"setTemplateContent\",\n    value: function setTemplateContent(templateElement, contentFragment) {\n      templateElement._templateContents = contentFragment;\n    }\n  }, {\n    key: \"setDocumentType\",\n    value: function setDocumentType(document, name, publicId, systemId) {\n      // parse5 sometimes gives us these as null.\n      if (name === null) {\n        name = \"\";\n      }\n\n      if (publicId === null) {\n        publicId = \"\";\n      }\n\n      if (systemId === null) {\n        systemId = \"\";\n      }\n\n      var documentType = DocumentType.createImpl([], {\n        name: name,\n        publicId: publicId,\n        systemId: systemId,\n        ownerDocument: this._documentImpl\n      });\n      document.appendChild(documentType);\n    }\n  }, {\n    key: \"setDocumentMode\",\n    value: function setDocumentMode(document, mode) {\n      // TODO: the rest of jsdom ignores this\n      document._mode = mode;\n    }\n  }, {\n    key: \"detachNode\",\n    value: function detachNode(node) {\n      node.remove();\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(parentNode, text) {\n      var lastChild = parentNode.lastChild;\n\n      if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n        lastChild.data += text;\n      } else {\n        var textNode = Text.createImpl([], {\n          data: text,\n          ownerDocument: this._documentImpl\n        });\n        parentNode.appendChild(textNode);\n      }\n    }\n  }, {\n    key: \"insertTextBefore\",\n    value: function insertTextBefore(parentNode, text, referenceNode) {\n      var previousSibling = referenceNode.previousSibling;\n\n      if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n        previousSibling.data += text;\n      } else {\n        var textNode = Text.createImpl([], {\n          data: text,\n          ownerDocument: this._documentImpl\n        });\n        parentNode.insertBefore(textNode, referenceNode);\n      }\n    }\n  }, {\n    key: \"adoptAttributes\",\n    value: function adoptAttributes(element, attrs) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = attrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var attr = _step.value;\n          var prefix = attr.prefix === \"\" ? null : attr.prefix;\n          attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return JSDOMParse5Adapter;\n}();\n\nObject.assign(module.exports.prototype, serializationAdapter);","map":null,"metadata":{},"sourceType":"script"}