{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar whatwgURL = require(\"whatwg-url\");\n\nvar HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\n\nvar PopStateEvent = require(\"../generated/PopStateEvent.js\");\n\nvar notImplemented = require(\"../../browser/not-implemented.js\");\n\nvar idlUtils = require(\"../generated/utils.js\"); // https://html.spec.whatwg.org/#session-history\n\n\nvar SessionHistory =\n/*#__PURE__*/\nfunction () {\n  function SessionHistory(initialEntry, window) {\n    _classCallCheck(this, SessionHistory);\n\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _createClass(SessionHistory, [{\n    key: \"_queueHistoryTraversalTask\",\n    value: function _queueHistoryTraversalTask(fn) {\n      var _this = this;\n\n      var timeoutId = this._window.setTimeout(function () {\n        _this._historyTraversalQueue.delete(timeoutId);\n\n        fn();\n      }, 0);\n\n      this._historyTraversalQueue.add(timeoutId);\n    }\n  }, {\n    key: \"clearHistoryTraversalTasks\",\n    value: function clearHistoryTraversalTasks() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._historyTraversalQueue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var timeoutId = _step.value;\n\n          this._window.clearTimeout(timeoutId);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._historyTraversalQueue.clear();\n    }\n  }, {\n    key: \"removeAllEntriesAfterCurrentEntry\",\n    // https://html.spec.whatwg.org/#dom-history-pushstate\n    value: function removeAllEntriesAfterCurrentEntry() {\n      this._entries.splice(this._currentIndex + 1, Infinity);\n    } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n\n  }, {\n    key: \"traverseByDelta\",\n    value: function traverseByDelta(delta) {\n      var _this2 = this;\n\n      this._queueHistoryTraversalTask(function () {\n        var newIndex = _this2._currentIndex + delta;\n\n        if (newIndex < 0 || newIndex >= _this2.length) {\n          return;\n        }\n\n        var specifiedEntry = _this2._entries[newIndex]; // Not implemented: unload a document guard\n        // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n        // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n\n        _this2._queueHistoryTraversalTask(function () {\n          // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n          // then cancel that attempt to navigate the browsing context.\n          // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n          // is because these navigations should already count as having \"matured\" because the document is not changing.\n          // this.clearHistoryTraversalTasks();\n          if (specifiedEntry.document !== _this2.currentEntry.document) {\n            // TODO: unload the active document with the recycle parameter set to false\n            notImplemented(\"Traversing history in a way that would change the window\", _this2._window);\n          }\n\n          _this2.traverseHistory(specifiedEntry);\n        });\n      });\n    } // https://html.spec.whatwg.org/#traverse-the-history\n\n  }, {\n    key: \"traverseHistory\",\n    value: function traverseHistory(specifiedEntry) {\n      var _this3 = this;\n\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!specifiedEntry.document) {\n        // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n        // to perform an entry update of entry, and abort these steps\n        notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n      } // Not spec compliant, just minimal. Lots of missing steps.\n\n\n      var nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n      var document = idlUtils.implForWrapper(this._window._document);\n      var currentEntry = this.currentEntry; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n      // to the value returned by the document.title IDL attribute.\n\n      if (currentEntry.title === undefined) {\n        currentEntry.title = document.title;\n      }\n\n      if (specifiedEntry.document !== currentEntry.document) {\n        // If entry has a different Document object than the current entry, then...\n        notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n      }\n\n      document._URL = specifiedEntry.url;\n      var hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n      var oldURL;\n      var newURL;\n\n      if (hashChanged) {\n        oldURL = currentEntry.url;\n        newURL = specifiedEntry.url;\n      }\n\n      if (flags.replacement) {\n        // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n        // specified entry in the session history.\n        this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n      }\n\n      this.updateCurrentEntry(specifiedEntry);\n      var state = specifiedEntry.stateObject; // TODO structured clone\n      // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n      // but the spec gives them to \"History\" and \"Document\" respecively.\n\n      document._history._state = state;\n      var stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n      specifiedEntry.document._latestEntry = specifiedEntry;\n\n      var fireEvents = function fireEvents() {\n        return _this3._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n      };\n\n      if (nonBlockingEvents) {\n        this._window.setTimeout(fireEvents, 0);\n      } else {\n        fireEvents();\n      }\n    }\n  }, {\n    key: \"_fireEvents\",\n    value: function _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n      if (stateChanged) {\n        this._windowImpl._dispatch(PopStateEvent.createImpl([\"popstate\", {\n          bubbles: false,\n          state: state\n        }], {\n          isTrusted: true\n        }));\n      }\n\n      if (hashChanged) {\n        this._windowImpl._dispatch(HashChangeEvent.createImpl([\"hashchange\", {\n          bubbles: false,\n          oldURL: whatwgURL.serializeURL(oldURL),\n          newURL: whatwgURL.serializeURL(newURL)\n        }], {\n          isTrusted: true\n        }));\n      }\n    }\n  }, {\n    key: \"addEntryAfterCurrentEntry\",\n    value: function addEntryAfterCurrentEntry(entry) {\n      this._entries.splice(this._currentIndex + 1, 0, entry);\n    }\n  }, {\n    key: \"updateCurrentEntry\",\n    value: function updateCurrentEntry(entry) {\n      this._currentIndex = this._entries.indexOf(entry);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._entries.length;\n    }\n  }, {\n    key: \"currentEntry\",\n    get: function get() {\n      return this._entries[this._currentIndex];\n    }\n  }]);\n\n  return SessionHistory;\n}();\n\nmodule.exports = SessionHistory;","map":null,"metadata":{},"sourceType":"script"}