{"ast":null,"code":"/*********************************************************************\n * These are commonly used parsers for CSS Values they take a string *\n * to parse and return a string after it's been converted, if needed *\n ********************************************************************/\n'use strict';\n\nvar _slicedToArray = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar namedColors = require('./named_colors.json');\n\nexports.TYPES = {\n  INTEGER: 1,\n  NUMBER: 2,\n  LENGTH: 3,\n  PERCENT: 4,\n  URL: 5,\n  COLOR: 6,\n  STRING: 7,\n  ANGLE: 8,\n  KEYWORD: 9,\n  NULL_OR_EMPTY_STR: 10\n}; // rough regular expressions\n\nvar integerRegEx = /^[-+]?[0-9]+$/;\nvar numberRegEx = /^[-+]?[0-9]*\\.[0-9]+$/;\nvar lengthRegEx = /^(0|[-+]?[0-9]*\\.?[0-9]+(in|cm|em|mm|pt|pc|px|ex|rem|vh|vw))$/;\nvar percentRegEx = /^[-+]?[0-9]*\\.?[0-9]+%$/;\nvar urlRegEx = /^url\\(\\s*([^)]*)\\s*\\)$/;\nvar stringRegEx = /^(\"[^\"]*\"|'[^']*')$/;\nvar colorRegEx1 = /^#[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]([0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])?$/;\nvar colorRegEx2 = /^rgb\\(([^)]*)\\)$/;\nvar colorRegEx3 = /^rgba\\(([^)]*)\\)$/;\nvar colorRegEx4 = /^hsla?\\(\\s*(-?\\d+|-?\\d*.\\d+)\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*,\\s*(-?\\d+|-?\\d*.\\d+)%\\s*(,\\s*(-?\\d+|-?\\d*.\\d+)\\s*)?\\)/;\nvar angleRegEx = /^([-+]?[0-9]*\\.?[0-9]+)(deg|grad|rad)$/; // This will return one of the above types based on the passed in string\n\nexports.valueType = function valueType(val) {\n  if (val === '' || val === null) {\n    return exports.TYPES.NULL_OR_EMPTY_STR;\n  }\n\n  if (typeof val === 'number') {\n    val = val.toString();\n  }\n\n  if (typeof val !== 'string') {\n    return undefined;\n  }\n\n  if (integerRegEx.test(val)) {\n    return exports.TYPES.INTEGER;\n  }\n\n  if (numberRegEx.test(val)) {\n    return exports.TYPES.NUMBER;\n  }\n\n  if (lengthRegEx.test(val)) {\n    return exports.TYPES.LENGTH;\n  }\n\n  if (percentRegEx.test(val)) {\n    return exports.TYPES.PERCENT;\n  }\n\n  if (urlRegEx.test(val)) {\n    return exports.TYPES.URL;\n  }\n\n  if (stringRegEx.test(val)) {\n    return exports.TYPES.STRING;\n  }\n\n  if (angleRegEx.test(val)) {\n    return exports.TYPES.ANGLE;\n  }\n\n  if (colorRegEx1.test(val)) {\n    return exports.TYPES.COLOR;\n  }\n\n  var res = colorRegEx2.exec(val);\n  var parts;\n\n  if (res !== null) {\n    parts = res[1].split(/\\s*,\\s*/);\n\n    if (parts.length !== 3) {\n      return undefined;\n    }\n\n    if (parts.every(percentRegEx.test.bind(percentRegEx)) || parts.every(integerRegEx.test.bind(integerRegEx))) {\n      return exports.TYPES.COLOR;\n    }\n\n    return undefined;\n  }\n\n  res = colorRegEx3.exec(val);\n\n  if (res !== null) {\n    parts = res[1].split(/\\s*,\\s*/);\n\n    if (parts.length !== 4) {\n      return undefined;\n    }\n\n    if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx)) || parts.every(integerRegEx.test.bind(integerRegEx))) {\n      if (numberRegEx.test(parts[3])) {\n        return exports.TYPES.COLOR;\n      }\n    }\n\n    return undefined;\n  }\n\n  if (colorRegEx4.test(val)) {\n    return exports.TYPES.COLOR;\n  } // could still be a color, one of the standard keyword colors\n\n\n  val = val.toLowerCase();\n\n  if (namedColors.includes(val)) {\n    return exports.TYPES.COLOR;\n  }\n\n  switch (val) {\n    // the following are deprecated in CSS3\n    case 'activeborder':\n    case 'activecaption':\n    case 'appworkspace':\n    case 'background':\n    case 'buttonface':\n    case 'buttonhighlight':\n    case 'buttonshadow':\n    case 'buttontext':\n    case 'captiontext':\n    case 'graytext':\n    case 'highlight':\n    case 'highlighttext':\n    case 'inactiveborder':\n    case 'inactivecaption':\n    case 'inactivecaptiontext':\n    case 'infobackground':\n    case 'infotext':\n    case 'menu':\n    case 'menutext':\n    case 'scrollbar':\n    case 'threeddarkshadow':\n    case 'threedface':\n    case 'threedhighlight':\n    case 'threedlightshadow':\n    case 'threedshadow':\n    case 'window':\n    case 'windowframe':\n    case 'windowtext':\n      return exports.TYPES.COLOR;\n\n    default:\n      return exports.TYPES.KEYWORD;\n  }\n};\n\nexports.parseInteger = function parseInteger(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.INTEGER) {\n    return undefined;\n  }\n\n  return String(parseInt(val, 10));\n};\n\nexports.parseNumber = function parseNumber(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.NUMBER && type !== exports.TYPES.INTEGER) {\n    return undefined;\n  }\n\n  return String(parseFloat(val));\n};\n\nexports.parseLength = function parseLength(val) {\n  if (val === 0 || val === '0') {\n    return '0px';\n  }\n\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.LENGTH) {\n    return undefined;\n  }\n\n  return val;\n};\n\nexports.parsePercent = function parsePercent(val) {\n  if (val === 0 || val === '0') {\n    return '0%';\n  }\n\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.PERCENT) {\n    return undefined;\n  }\n\n  return val;\n}; // either a length or a percent\n\n\nexports.parseMeasurement = function parseMeasurement(val) {\n  var length = exports.parseLength(val);\n\n  if (length !== undefined) {\n    return length;\n  }\n\n  return exports.parsePercent(val);\n};\n\nexports.parseUrl = function parseUrl(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  var res = urlRegEx.exec(val); // does it match the regex?\n\n  if (!res) {\n    return undefined;\n  }\n\n  var str = res[1]; // if it starts with single or double quotes, does it end with the same?\n\n  if ((str[0] === '\"' || str[0] === \"'\") && str[0] !== str[str.length - 1]) {\n    return undefined;\n  }\n\n  if (str[0] === '\"' || str[0] === \"'\") {\n    str = str.substr(1, str.length - 2);\n  }\n\n  var i;\n\n  for (i = 0; i < str.length; i++) {\n    switch (str[i]) {\n      case '(':\n      case ')':\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case \"'\":\n      case '\"':\n        return undefined;\n\n      case '\\\\':\n        i++;\n        break;\n    }\n  }\n\n  return 'url(' + str + ')';\n};\n\nexports.parseString = function parseString(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.STRING) {\n    return undefined;\n  }\n\n  var i;\n\n  for (i = 1; i < val.length - 1; i++) {\n    switch (val[i]) {\n      case val[0]:\n        return undefined;\n\n      case '\\\\':\n        i++;\n\n        while (i < val.length - 1 && /[0-9A-Fa-f]/.test(val[i])) {\n          i++;\n        }\n\n        break;\n    }\n  }\n\n  if (i >= val.length) {\n    return undefined;\n  }\n\n  return val;\n};\n\nexports.parseColor = function parseColor(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  var red,\n      green,\n      blue,\n      hue,\n      saturation,\n      lightness,\n      alpha = 1;\n  var parts;\n  var res = colorRegEx1.exec(val); // is it #aaa or #ababab\n\n  if (res) {\n    var hex = val.substr(1);\n\n    if (hex.length === 3) {\n      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    }\n\n    red = parseInt(hex.substr(0, 2), 16);\n    green = parseInt(hex.substr(2, 2), 16);\n    blue = parseInt(hex.substr(4, 2), 16);\n    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';\n  }\n\n  res = colorRegEx2.exec(val);\n\n  if (res) {\n    parts = res[1].split(/\\s*,\\s*/);\n\n    if (parts.length !== 3) {\n      return undefined;\n    }\n\n    if (parts.every(percentRegEx.test.bind(percentRegEx))) {\n      red = Math.floor(parseFloat(parts[0].slice(0, -1)) * 255 / 100);\n      green = Math.floor(parseFloat(parts[1].slice(0, -1)) * 255 / 100);\n      blue = Math.floor(parseFloat(parts[2].slice(0, -1)) * 255 / 100);\n    } else if (parts.every(integerRegEx.test.bind(integerRegEx))) {\n      red = parseInt(parts[0], 10);\n      green = parseInt(parts[1], 10);\n      blue = parseInt(parts[2], 10);\n    } else {\n      return undefined;\n    }\n\n    red = Math.min(255, Math.max(0, red));\n    green = Math.min(255, Math.max(0, green));\n    blue = Math.min(255, Math.max(0, blue));\n    return 'rgb(' + red + ', ' + green + ', ' + blue + ')';\n  }\n\n  res = colorRegEx3.exec(val);\n\n  if (res) {\n    parts = res[1].split(/\\s*,\\s*/);\n\n    if (parts.length !== 4) {\n      return undefined;\n    }\n\n    if (parts.slice(0, 3).every(percentRegEx.test.bind(percentRegEx))) {\n      red = Math.floor(parseFloat(parts[0].slice(0, -1)) * 255 / 100);\n      green = Math.floor(parseFloat(parts[1].slice(0, -1)) * 255 / 100);\n      blue = Math.floor(parseFloat(parts[2].slice(0, -1)) * 255 / 100);\n      alpha = parseFloat(parts[3]);\n    } else if (parts.slice(0, 3).every(integerRegEx.test.bind(integerRegEx))) {\n      red = parseInt(parts[0], 10);\n      green = parseInt(parts[1], 10);\n      blue = parseInt(parts[2], 10);\n      alpha = parseFloat(parts[3]);\n    } else {\n      return undefined;\n    }\n\n    if (isNaN(alpha)) {\n      alpha = 1;\n    }\n\n    red = Math.min(255, Math.max(0, red));\n    green = Math.min(255, Math.max(0, green));\n    blue = Math.min(255, Math.max(0, blue));\n    alpha = Math.min(1, Math.max(0, alpha));\n\n    if (alpha === 1) {\n      return 'rgb(' + red + ', ' + green + ', ' + blue + ')';\n    }\n\n    return 'rgba(' + red + ', ' + green + ', ' + blue + ', ' + alpha + ')';\n  }\n\n  res = colorRegEx4.exec(val);\n\n  if (res) {\n    var _res = res,\n        _res2 = _slicedToArray(_res, 5),\n        _hue = _res2[1],\n        _saturation = _res2[2],\n        _lightness = _res2[3],\n        _res2$ = _res2[4],\n        _alphaString = _res2$ === void 0 ? '' : _res2$;\n\n    var _alpha = parseFloat(_alphaString.replace(',', '').trim());\n\n    if (!_hue || !_saturation || !_lightness) {\n      return undefined;\n    }\n\n    hue = parseFloat(_hue);\n    saturation = parseInt(_saturation, 10);\n    lightness = parseInt(_lightness, 10);\n\n    if (_alpha && numberRegEx.test(_alpha)) {\n      alpha = parseFloat(_alpha);\n    }\n\n    if (!_alphaString || alpha === 1) {\n      return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';\n    }\n\n    return 'hsla(' + hue + ', ' + saturation + '%, ' + lightness + '%, ' + alpha + ')';\n  }\n\n  if (type === exports.TYPES.COLOR) {\n    return val;\n  }\n\n  return undefined;\n};\n\nexports.parseAngle = function parseAngle(val) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.ANGLE) {\n    return undefined;\n  }\n\n  var res = angleRegEx.exec(val);\n  var flt = parseFloat(res[1]);\n\n  if (res[2] === 'rad') {\n    flt *= 180 / Math.PI;\n  } else if (res[2] === 'grad') {\n    flt *= 360 / 400;\n  }\n\n  while (flt < 0) {\n    flt += 360;\n  }\n\n  while (flt > 360) {\n    flt -= 360;\n  }\n\n  return flt + 'deg';\n};\n\nexports.parseKeyword = function parseKeyword(val, valid_keywords) {\n  var type = exports.valueType(val);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    return val;\n  }\n\n  if (type !== exports.TYPES.KEYWORD) {\n    return undefined;\n  }\n\n  val = val.toString().toLowerCase();\n  var i;\n\n  for (i = 0; i < valid_keywords.length; i++) {\n    if (valid_keywords[i].toLowerCase() === val) {\n      return valid_keywords[i];\n    }\n  }\n\n  return undefined;\n}; // utility to translate from border-width to borderWidth\n\n\nvar dashedToCamelCase = function dashedToCamelCase(dashed) {\n  var i;\n  var camel = '';\n  var nextCap = false;\n\n  for (i = 0; i < dashed.length; i++) {\n    if (dashed[i] !== '-') {\n      camel += nextCap ? dashed[i].toUpperCase() : dashed[i];\n      nextCap = false;\n    } else {\n      nextCap = true;\n    }\n  }\n\n  return camel;\n};\n\nexports.dashedToCamelCase = dashedToCamelCase;\nvar is_space = /\\s/;\nvar opening_deliminators = ['\"', \"'\", '('];\nvar closing_deliminators = ['\"', \"'\", ')']; // this splits on whitespace, but keeps quoted and parened parts together\n\nvar getParts = function getParts(str) {\n  var deliminator_stack = [];\n  var length = str.length;\n  var i;\n  var parts = [];\n  var current_part = '';\n  var opening_index;\n  var closing_index;\n\n  for (i = 0; i < length; i++) {\n    opening_index = opening_deliminators.indexOf(str[i]);\n    closing_index = closing_deliminators.indexOf(str[i]);\n\n    if (is_space.test(str[i])) {\n      if (deliminator_stack.length === 0) {\n        if (current_part !== '') {\n          parts.push(current_part);\n        }\n\n        current_part = '';\n      } else {\n        current_part += str[i];\n      }\n    } else {\n      if (str[i] === '\\\\') {\n        i++;\n        current_part += str[i];\n      } else {\n        current_part += str[i];\n\n        if (closing_index !== -1 && closing_index === deliminator_stack[deliminator_stack.length - 1]) {\n          deliminator_stack.pop();\n        } else if (opening_index !== -1) {\n          deliminator_stack.push(opening_index);\n        }\n      }\n    }\n  }\n\n  if (current_part !== '') {\n    parts.push(current_part);\n  }\n\n  return parts;\n};\n/*\n * this either returns undefined meaning that it isn't valid\n * or returns an object where the keys are dashed short\n * hand properties and the values are the values to set\n * on them\n */\n\n\nexports.shorthandParser = function parse(v, shorthand_for) {\n  var obj = {};\n  var type = exports.valueType(v);\n\n  if (type === exports.TYPES.NULL_OR_EMPTY_STR) {\n    Object.keys(shorthand_for).forEach(function (property) {\n      obj[property] = '';\n    });\n    return obj;\n  }\n\n  if (typeof v === 'number') {\n    v = v.toString();\n  }\n\n  if (typeof v !== 'string') {\n    return undefined;\n  }\n\n  if (v.toLowerCase() === 'inherit') {\n    return {};\n  }\n\n  var parts = getParts(v);\n  var valid = true;\n  parts.forEach(function (part, i) {\n    var part_valid = false;\n    Object.keys(shorthand_for).forEach(function (property) {\n      if (shorthand_for[property].isValid(part, i)) {\n        part_valid = true;\n        obj[property] = part;\n      }\n    });\n    valid = valid && part_valid;\n  });\n\n  if (!valid) {\n    return undefined;\n  }\n\n  return obj;\n};\n\nexports.shorthandSetter = function (property, shorthand_for) {\n  return function (v) {\n    var obj = exports.shorthandParser(v, shorthand_for);\n\n    if (obj === undefined) {\n      return;\n    } //console.log('shorthandSetter for:', property, 'obj:', obj);\n\n\n    Object.keys(obj).forEach(function (subprop) {\n      // in case subprop is an implicit property, this will clear\n      // *its* subpropertiesX\n      var camel = dashedToCamelCase(subprop);\n      this[camel] = obj[subprop]; // in case it gets translated into something else (0 -> 0px)\n\n      obj[subprop] = this[camel];\n      this.removeProperty(subprop); // don't add in empty properties\n\n      if (obj[subprop] !== '') {\n        this._values[subprop] = obj[subprop];\n      }\n    }, this);\n    Object.keys(shorthand_for).forEach(function (subprop) {\n      if (!obj.hasOwnProperty(subprop)) {\n        this.removeProperty(subprop);\n        delete this._values[subprop];\n      }\n    }, this); // in case the value is something like 'none' that removes all values,\n    // check that the generated one is not empty, first remove the property\n    // if it already exists, then call the shorthandGetter, if it's an empty\n    // string, don't set the property\n\n    this.removeProperty(property);\n    var calculated = exports.shorthandGetter(property, shorthand_for).call(this);\n\n    if (calculated !== '') {\n      this._setProperty(property, calculated);\n    }\n  };\n};\n\nexports.shorthandGetter = function (property, shorthand_for) {\n  return function () {\n    if (this._values[property] !== undefined) {\n      return this.getPropertyValue(property);\n    }\n\n    return Object.keys(shorthand_for).map(function (subprop) {\n      return this.getPropertyValue(subprop);\n    }, this).filter(function (value) {\n      return value !== '';\n    }).join(' ');\n  };\n}; // isValid(){1,4} | inherit\n// if one, it applies to all\n// if two, the first applies to the top and bottom, and the second to left and right\n// if three, the first applies to the top, the second to left and right, the third bottom\n// if four, top, right, bottom, left\n\n\nexports.implicitSetter = function (property_before, property_after, isValid, parser) {\n  property_after = property_after || '';\n\n  if (property_after !== '') {\n    property_after = '-' + property_after;\n  }\n\n  var part_names = ['top', 'right', 'bottom', 'left'];\n  return function (v) {\n    if (typeof v === 'number') {\n      v = v.toString();\n    }\n\n    if (typeof v !== 'string') {\n      return undefined;\n    }\n\n    var parts;\n\n    if (v.toLowerCase() === 'inherit' || v === '') {\n      parts = [v];\n    } else {\n      parts = getParts(v);\n    }\n\n    if (parts.length < 1 || parts.length > 4) {\n      return undefined;\n    }\n\n    if (!parts.every(isValid)) {\n      return undefined;\n    }\n\n    parts = parts.map(function (part) {\n      return parser(part);\n    });\n\n    this._setProperty(property_before + property_after, parts.join(' '));\n\n    if (parts.length === 1) {\n      parts[1] = parts[0];\n    }\n\n    if (parts.length === 2) {\n      parts[2] = parts[0];\n    }\n\n    if (parts.length === 3) {\n      parts[3] = parts[1];\n    }\n\n    for (var i = 0; i < 4; i++) {\n      var property = property_before + '-' + part_names[i] + property_after;\n      this.removeProperty(property);\n\n      if (parts[i] !== '') {\n        this._values[property] = parts[i];\n      }\n    }\n\n    return v;\n  };\n}; //\n//  Companion to implicitSetter, but for the individual parts.\n//  This sets the individual value, and checks to see if all four\n//  sub-parts are set.  If so, it sets the shorthand version and removes\n//  the individual parts from the cssText.\n//\n\n\nexports.subImplicitSetter = function (prefix, part, isValid, parser) {\n  var property = prefix + '-' + part;\n  var subparts = [prefix + '-top', prefix + '-right', prefix + '-bottom', prefix + '-left'];\n  return function (v) {\n    if (typeof v === 'number') {\n      v = v.toString();\n    }\n\n    if (typeof v !== 'string') {\n      return undefined;\n    }\n\n    if (!isValid(v)) {\n      return undefined;\n    }\n\n    v = parser(v);\n\n    this._setProperty(property, v);\n\n    var parts = [];\n\n    for (var i = 0; i < 4; i++) {\n      if (this._values[subparts[i]] == null || this._values[subparts[i]] === '') {\n        break;\n      }\n\n      parts.push(this._values[subparts[i]]);\n    }\n\n    if (parts.length === 4) {\n      for (i = 0; i < 4; i++) {\n        this.removeProperty(subparts[i]);\n        this._values[subparts[i]] = parts[i];\n      }\n\n      this._setProperty(prefix, parts.join(' '));\n    }\n\n    return v;\n  };\n};\n\nvar camel_to_dashed = /[A-Z]/g;\nvar first_segment = /^\\([^-]\\)-/;\nvar vendor_prefixes = ['o', 'moz', 'ms', 'webkit'];\n\nexports.camelToDashed = function (camel_case) {\n  var match;\n  var dashed = camel_case.replace(camel_to_dashed, '-$&').toLowerCase();\n  match = dashed.match(first_segment);\n\n  if (match && vendor_prefixes.indexOf(match[1]) !== -1) {\n    dashed = '-' + dashed;\n  }\n\n  return dashed;\n};","map":null,"metadata":{},"sourceType":"script"}