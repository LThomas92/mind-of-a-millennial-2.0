{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nvar _require = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar _require2 = require(\"../../utils\"),\n    simultaneousIterators = _require2.simultaneousIterators;\n\nvar DOMException = require(\"domexception\");\n\nvar NODE_TYPE = require(\"../node-type\");\n\nvar NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\n\nvar NodeList = require(\"../generated/NodeList\");\n\nvar _require3 = require(\"../helpers/document-base-url\"),\n    documentBaseURLSerialized = _require3.documentBaseURLSerialized;\n\nvar _require4 = require(\"../node\"),\n    clone = _require4.clone,\n    locateNamespacePrefix = _require4.locateNamespacePrefix,\n    locateNamespace = _require4.locateNamespace;\n\nvar attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE || //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n  node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var nodes = _step.value;\n\n      if (!nodes[0] || !nodes[1]) {\n        // mismatch in the amount of childNodes\n        return false;\n      }\n\n      if (!nodeEquals(nodes[0], nodes[1])) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n\nvar NodeImpl =\n/*#__PURE__*/\nfunction (_EventTargetImpl) {\n  _inherits(NodeImpl, _EventTargetImpl);\n\n  function NodeImpl(args, privateData) {\n    var _this;\n\n    _classCallCheck(this, NodeImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeImpl).call(this));\n    domSymbolTree.initialize(_assertThisInitialized(_this));\n    _this._ownerDocument = privateData.ownerDocument;\n    _this._childNodesList = null;\n    _this._childrenList = null;\n    _this._version = 0;\n    _this._memoizedQueries = {};\n    return _this;\n  }\n\n  _createClass(NodeImpl, [{\n    key: \"getRootNode\",\n    value: function getRootNode() {\n      // ignore option for composed, because of no Shadow DOM support\n      var root;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = domSymbolTree.ancestorsIterator(this)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var ancestor = _step2.value;\n          root = ancestor;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return root;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(newChildImpl, refChildImpl) {\n      // DocumentType must be implicitly adopted\n      if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n        newChildImpl._ownerDocument = this._ownerDocument;\n      }\n\n      if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n        throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n      }\n\n      if (this._ownerDocument !== newChildImpl._ownerDocument) {\n        // adopt the node when it's not in this document\n        this._ownerDocument.adoptNode(newChildImpl);\n      } else {\n        // search for parents matching the newChild\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = domSymbolTree.ancestorsIterator(this)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var ancestor = _step3.value;\n\n            if (ancestor === newChildImpl) {\n              throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } // fragments are merged into the element (except parser-created fragments in <template>)\n\n\n      if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n        var grandChildImpl;\n\n        while (grandChildImpl = domSymbolTree.firstChild(newChildImpl)) {\n          newChildImpl.removeChild(grandChildImpl);\n          this.insertBefore(grandChildImpl, refChildImpl);\n        }\n      } else if (newChildImpl === refChildImpl) {\n        return newChildImpl;\n      } else {\n        var oldParentImpl = domSymbolTree.parent(newChildImpl); // if the newChild is already in the tree elsewhere, remove it first\n\n        if (oldParentImpl) {\n          oldParentImpl.removeChild(newChildImpl);\n        }\n\n        if (refChildImpl === null) {\n          domSymbolTree.appendChild(this, newChildImpl);\n        } else {\n          if (domSymbolTree.parent(refChildImpl) !== this) {\n            throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n          }\n\n          domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n        }\n\n        this._modified();\n\n        if (newChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n          this._childTextContentChangeSteps();\n        }\n\n        if (this._attached && newChildImpl._attach) {\n          newChildImpl._attach();\n        }\n\n        this._descendantAdded(this, newChildImpl);\n      }\n\n      return newChildImpl;\n    } // raises(DOMException);\n\n  }, {\n    key: \"_modified\",\n    value: function _modified() {\n      this._version++;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = domSymbolTree.ancestorsIterator(this)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var ancestor = _step4.value;\n          ancestor._version++;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      if (this._childrenList) {\n        this._childrenList._update();\n      }\n\n      if (this._childNodesList) {\n        this._childNodesList._update();\n      }\n\n      this._clearMemoizedQueries();\n    }\n  }, {\n    key: \"_childTextContentChangeSteps\",\n    value: function _childTextContentChangeSteps() {// Default: do nothing\n    }\n  }, {\n    key: \"_clearMemoizedQueries\",\n    value: function _clearMemoizedQueries() {\n      this._memoizedQueries = {};\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._clearMemoizedQueries();\n      }\n    }\n  }, {\n    key: \"_descendantRemoved\",\n    value: function _descendantRemoved(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantRemoved(parent, child);\n      }\n    }\n  }, {\n    key: \"_descendantAdded\",\n    value: function _descendantAdded(parent, child) {\n      var myParent = domSymbolTree.parent(this);\n\n      if (myParent) {\n        myParent._descendantAdded(parent, child);\n      }\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(node, child) {\n      this.insertBefore(node, child);\n      return this.removeChild(child);\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach() {\n      this._attached = true;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = domSymbolTree.childrenIterator(this)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var child = _step5.value;\n\n          if (child._attach) {\n            child._attach();\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_detach\",\n    value: function _detach() {\n      this._attached = false;\n\n      if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n        this._ownerDocument._lastFocusedElement = null;\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = domSymbolTree.childrenIterator(this)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var child = _step6.value;\n\n          if (child._detach) {\n            child._detach();\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(\n    /* Node */\n    oldChildImpl) {\n      if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n        throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n      }\n\n      if (this._ownerDocument) {\n        this._ownerDocument._runPreRemovingSteps(oldChildImpl);\n      }\n\n      domSymbolTree.remove(oldChildImpl);\n\n      this._modified();\n\n      oldChildImpl._detach();\n\n      this._descendantRemoved(this, oldChildImpl);\n\n      if (oldChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      return oldChildImpl;\n    } // raises(DOMException);\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(newChild) {\n      return this.insertBefore(newChild, null);\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return domSymbolTree.hasChildren(this);\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = domSymbolTree.childrenIterator(this)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var child = _step7.value;\n\n          if (child.normalize) {\n            child.normalize();\n          } // Normalize should only transform Text nodes, and nothing else.\n\n\n          if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n            continue;\n          }\n\n          if (child.nodeValue === \"\") {\n            this.removeChild(child);\n            continue;\n          }\n\n          var prevChild = domSymbolTree.previousSibling(child);\n\n          if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n            // merge text nodes\n            prevChild.appendData(child.nodeValue);\n            this.removeChild(child);\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"compareDocumentPosition\",\n    value: function compareDocumentPosition(otherImpl) {\n      // Let reference be the context object.\n      var reference = this;\n\n      if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n        throw new Error(\"Obsolete node type\");\n      }\n\n      var result = domSymbolTree.compareTreePosition(reference, otherImpl); // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n      //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n      // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n\n      if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n        // symbol-tree does not add these bits required by the spec:\n        return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"lookupPrefix\",\n    value: function lookupPrefix(namespace) {\n      if (namespace === null || namespace === \"\") {\n        return null;\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            return locateNamespacePrefix(this, namespace);\n          }\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          {\n            return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n          }\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          {\n            return null;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n          }\n\n        default:\n          {\n            return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n          }\n      }\n    }\n  }, {\n    key: \"lookupNamespaceURI\",\n    value: function lookupNamespaceURI(prefix) {\n      if (prefix === \"\") {\n        prefix = null;\n      }\n\n      return locateNamespace(this, prefix);\n    }\n  }, {\n    key: \"isDefaultNamespace\",\n    value: function isDefaultNamespace(namespace) {\n      if (namespace === \"\") {\n        namespace = null;\n      }\n\n      var defaultNamespace = locateNamespace(this, null);\n      return defaultNamespace === namespace;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(other) {\n      if (other === null) {\n        return false;\n      } else if (this === other) {\n        return true;\n      }\n\n      return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n    }\n  }, {\n    key: \"isEqualNode\",\n    value: function isEqualNode(node) {\n      if (node === null) {\n        return false;\n      } // Fast-path, not in the spec\n\n\n      if (this === node) {\n        return true;\n      }\n\n      return nodeEquals(this, node);\n    }\n  }, {\n    key: \"isSameNode\",\n    value: function isSameNode(node) {\n      if (this === node) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      deep = Boolean(deep);\n      return clone(this, undefined, deep);\n    }\n  }, {\n    key: \"parentNode\",\n    get: function get() {\n      return domSymbolTree.parent(this);\n    }\n  }, {\n    key: \"nodeName\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ELEMENT_NODE:\n          return this.tagName;\n\n        case NODE_TYPE.TEXT_NODE:\n          return \"#text\";\n\n        case NODE_TYPE.CDATA_SECTION_NODE:\n          return \"#cdata-section\";\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n          return this.target;\n\n        case NODE_TYPE.COMMENT_NODE:\n          return \"#comment\";\n\n        case NODE_TYPE.DOCUMENT_NODE:\n          return \"#document\";\n\n        case NODE_TYPE.DOCUMENT_TYPE_NODE:\n          return this.name;\n\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n          return \"#document-fragment\";\n      } // should never happen\n\n\n      return null;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return domSymbolTree.firstChild(this);\n    }\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = domSymbolTree.ancestorsIterator(this)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var ancestor = _step8.value;\n\n          if (ancestor.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ownerDocument\",\n    get: function get() {\n      return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return domSymbolTree.lastChild(this);\n    }\n  }, {\n    key: \"childNodes\",\n    get: function get() {\n      var _this2 = this;\n\n      if (!this._childNodesList) {\n        this._childNodesList = NodeList.createImpl([], {\n          element: this,\n          query: function query() {\n            return domSymbolTree.childrenToArray(_this2);\n          }\n        });\n      } else {\n        this._childNodesList._update();\n      }\n\n      return this._childNodesList;\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      return domSymbolTree.nextSibling(this);\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      return domSymbolTree.previousSibling(this);\n    }\n  }, {\n    key: \"parentElement\",\n    get: function get() {\n      var parentNode = domSymbolTree.parent(this);\n      return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n    }\n  }, {\n    key: \"baseURI\",\n    get: function get() {\n      return documentBaseURLSerialized(this._ownerDocument);\n    }\n  }, {\n    key: \"nodeValue\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      if (value === null) {\n        value = \"\";\n      }\n\n      switch (this.nodeType) {\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            attributes.setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            var text = \"\";\n            var _iteratorNormalCompletion9 = true;\n            var _didIteratorError9 = false;\n            var _iteratorError9 = undefined;\n\n            try {\n              for (var _iterator9 = domSymbolTree.treeIterator(this)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                var child = _step9.value;\n\n                if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n                  text += child.nodeValue;\n                }\n              }\n            } catch (err) {\n              _didIteratorError9 = true;\n              _iteratorError9 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                  _iterator9.return();\n                }\n              } finally {\n                if (_didIteratorError9) {\n                  throw _iteratorError9;\n                }\n              }\n            }\n\n            return text;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            return this._value;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            return this._data;\n          }\n\n        default:\n          {\n            return null;\n          }\n      }\n    },\n    set: function set(value) {\n      switch (this.nodeType) {\n        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        case NODE_TYPE.ELEMENT_NODE:\n          {\n            var child = domSymbolTree.firstChild(this);\n\n            while (child) {\n              this.removeChild(child);\n              child = domSymbolTree.firstChild(this);\n            }\n\n            if (value !== null && value !== \"\") {\n              this.appendChild(this._ownerDocument.createTextNode(value));\n            }\n\n            break;\n          }\n\n        case NODE_TYPE.ATTRIBUTE_NODE:\n          {\n            attributes.setAnExistingAttributeValue(this, value);\n            break;\n          }\n\n        case NODE_TYPE.TEXT_NODE:\n        case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n\n        case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        case NODE_TYPE.COMMENT_NODE:\n          {\n            this.replaceData(0, this.length, value);\n            break;\n          }\n      }\n    }\n  }]);\n\n  return NodeImpl;\n}(EventTargetImpl);\n\nmodule.exports = {\n  implementation: NodeImpl\n};","map":null,"metadata":{},"sourceType":"script"}