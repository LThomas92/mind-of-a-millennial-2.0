{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _immutable = require(\"immutable\");\n\nvar _draftJs = require(\"draft-js\");\n\nvar _parseHTML = _interopRequireDefault(require(\"./util/parseHTML\"));\n\nvar _rangeSort = _interopRequireDefault(require(\"./util/rangeSort\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the /src directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n\nvar NBSP = '&nbsp;';\nvar SPACE = ' '; // Arbitrary max indent\n\nvar MAX_DEPTH = 4; // used for replacing characters in HTML\n\n/* eslint-disable no-control-regex */\n\nvar REGEX_CR = new RegExp('\\r', 'g');\nvar REGEX_LF = new RegExp('\\n', 'g');\nvar REGEX_NBSP = new RegExp(NBSP, 'g');\nvar REGEX_BLOCK_DELIMITER = new RegExp('\\r', 'g');\n/* eslint-enable no-control-regex */\n// Block tag flow is different because LIs do not have\n// a deterministic style ;_;\n\nvar blockTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre'];\nvar inlineTags = {\n  b: 'BOLD',\n  code: 'CODE',\n  del: 'STRIKETHROUGH',\n  em: 'ITALIC',\n  i: 'ITALIC',\n  s: 'STRIKETHROUGH',\n  strike: 'STRIKETHROUGH',\n  strong: 'BOLD',\n  u: 'UNDERLINE'\n};\n\nvar handleMiddleware = function handleMiddleware(maybeMiddleware, base) {\n  if (maybeMiddleware && maybeMiddleware.__isMiddleware === true) {\n    return maybeMiddleware(base);\n  }\n\n  return maybeMiddleware;\n};\n\nvar defaultHTMLToBlock = function defaultHTMLToBlock(nodeName, node, lastList) {\n  return undefined;\n};\n\nvar defaultHTMLToStyle = function defaultHTMLToStyle(nodeName, node, currentStyle) {\n  return currentStyle;\n};\n\nvar defaultHTMLToEntity = function defaultHTMLToEntity(nodeName, node) {\n  return undefined;\n};\n\nvar defaultTextToEntity = function defaultTextToEntity(text) {\n  return [];\n};\n\nvar nullthrows = function nullthrows(x) {\n  if (x != null) {\n    return x;\n  }\n\n  throw new Error('Got unexpected null or undefined');\n};\n\nvar sanitizeDraftText = function sanitizeDraftText(input) {\n  return input.replace(REGEX_BLOCK_DELIMITER, '');\n};\n\nfunction getEmptyChunk() {\n  return {\n    text: '',\n    inlines: [],\n    entities: [],\n    blocks: []\n  };\n}\n\nfunction getWhitespaceChunk(inEntity) {\n  var entities = new Array(1);\n\n  if (inEntity) {\n    entities[0] = inEntity;\n  }\n\n  return {\n    text: SPACE,\n    inlines: [(0, _immutable.OrderedSet)()],\n    entities: entities,\n    blocks: []\n  };\n}\n\nfunction getSoftNewlineChunk(block, depth) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : (0, _immutable.Map)();\n\n  if (flat === true) {\n    return {\n      text: '\\r',\n      inlines: [(0, _immutable.OrderedSet)()],\n      entities: new Array(1),\n      blocks: [{\n        type: block,\n        data: data,\n        depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n      }],\n      isNewline: true\n    };\n  }\n\n  return {\n    text: '\\n',\n    inlines: [(0, _immutable.OrderedSet)()],\n    entities: new Array(1),\n    blocks: []\n  };\n}\n\nfunction getBlockDividerChunk(block, depth) {\n  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _immutable.Map)();\n  return {\n    text: '\\r',\n    inlines: [(0, _immutable.OrderedSet)()],\n    entities: new Array(1),\n    blocks: [{\n      type: block,\n      data: data,\n      depth: Math.max(0, Math.min(MAX_DEPTH, depth))\n    }]\n  };\n}\n\nfunction getBlockTypeForTag(tag, lastList) {\n  switch (tag) {\n    case 'h1':\n      return 'header-one';\n\n    case 'h2':\n      return 'header-two';\n\n    case 'h3':\n      return 'header-three';\n\n    case 'h4':\n      return 'header-four';\n\n    case 'h5':\n      return 'header-five';\n\n    case 'h6':\n      return 'header-six';\n\n    case 'li':\n      if (lastList === 'ol') {\n        return 'ordered-list-item';\n      }\n\n      return 'unordered-list-item';\n\n    case 'blockquote':\n      return 'blockquote';\n\n    case 'pre':\n      return 'code-block';\n\n    case 'div':\n    case 'p':\n      return 'unstyled';\n\n    default:\n      return null;\n  }\n}\n\nfunction baseCheckBlockType(nodeName, node, lastList) {\n  return getBlockTypeForTag(nodeName, lastList);\n}\n\nfunction processInlineTag(tag, node, currentStyle) {\n  var styleToCheck = inlineTags[tag];\n\n  if (styleToCheck) {\n    currentStyle = currentStyle.add(styleToCheck).toOrderedSet();\n  } else if (node instanceof HTMLElement) {\n    var htmlElement = node;\n    currentStyle = currentStyle.withMutations(function (style) {\n      if (htmlElement.style.fontWeight === 'bold') {\n        style.add('BOLD');\n      }\n\n      if (htmlElement.style.fontStyle === 'italic') {\n        style.add('ITALIC');\n      }\n\n      if (htmlElement.style.textDecoration === 'underline') {\n        style.add('UNDERLINE');\n      }\n\n      if (htmlElement.style.textDecoration === 'line-through') {\n        style.add('STRIKETHROUGH');\n      }\n    }).toOrderedSet();\n  }\n\n  return currentStyle;\n}\n\nfunction baseProcessInlineTag(tag, node) {\n  var inlineStyles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _immutable.OrderedSet)();\n  return processInlineTag(tag, node, inlineStyles);\n}\n\nfunction joinChunks(A, B) {\n  var flat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Sometimes two blocks will touch in the DOM and we need to strip the\n  // extra delimiter to preserve niceness.\n\n  var firstInB = B.text.slice(0, 1);\n  var lastInA = A.text.slice(-1);\n  var adjacentDividers = lastInA === '\\r' && firstInB === '\\r';\n  var isJoiningBlocks = A.text !== '\\r' && B.text !== '\\r'; // when joining two full blocks like this we want to pop one divider\n\n  var addingNewlineToEmptyBlock = A.text === '\\r' && !A.isNewline && B.isNewline; // when joining a newline to an empty block we want to remove the newline\n\n  if (adjacentDividers && (isJoiningBlocks || addingNewlineToEmptyBlock)) {\n    A.text = A.text.slice(0, -1);\n    A.inlines.pop();\n    A.entities.pop();\n    A.blocks.pop();\n  } // Kill whitespace after blocks if flat mode is on\n\n\n  if (A.text.slice(-1) === '\\r' && flat === true) {\n    if (B.text === SPACE || B.text === '\\n') {\n      return A;\n    } else if (firstInB === SPACE || firstInB === '\\n') {\n      B.text = B.text.slice(1);\n      B.inlines.shift();\n      B.entities.shift();\n    }\n  }\n\n  var isNewline = A.text.length === 0 && B.isNewline;\n  return {\n    text: A.text + B.text,\n    inlines: A.inlines.concat(B.inlines),\n    entities: A.entities.concat(B.entities),\n    blocks: A.blocks.concat(B.blocks),\n    isNewline: isNewline\n  };\n}\n/*\n * Check to see if we have anything like <p> <blockquote> <h1>... to create\n * block tags from. If we do, we can use those and ignore <div> tags. If we\n * don't, we can treat <div> tags as meaningful (unstyled) blocks.\n */\n\n\nfunction containsSemanticBlockMarkup(html) {\n  return blockTags.some(function (tag) {\n    return html.indexOf(\"<\".concat(tag)) !== -1;\n  });\n}\n\nfunction genFragment(node, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, inEntity) {\n  var nodeName = node.nodeName.toLowerCase();\n  var newBlock = false;\n  var nextBlockType = 'unstyled'; // Base Case\n\n  if (nodeName === '#text') {\n    var text = node.textContent;\n\n    if (text.trim() === '' && inBlock === null) {\n      return getEmptyChunk();\n    }\n\n    if (text.trim() === '' && inBlock !== 'code-block') {\n      return getWhitespaceChunk(inEntity);\n    }\n\n    if (inBlock !== 'code-block') {\n      // Can't use empty string because MSWord\n      text = text.replace(REGEX_LF, SPACE);\n    }\n\n    var entities = Array(text.length).fill(inEntity);\n    var offsetChange = 0;\n    var textEntities = checkEntityText(text, createEntity, getEntity, mergeEntityData, replaceEntityData).sort(_rangeSort[\"default\"]);\n    textEntities.forEach(function (_ref) {\n      var entity = _ref.entity,\n          offset = _ref.offset,\n          length = _ref.length,\n          result = _ref.result;\n      var adjustedOffset = offset + offsetChange;\n\n      if (result === null || result === undefined) {\n        result = text.substr(adjustedOffset, length);\n      }\n\n      var textArray = text.split('');\n      textArray.splice.bind(textArray, adjustedOffset, length).apply(textArray, result.split(''));\n      text = textArray.join('');\n      entities.splice.bind(entities, adjustedOffset, length).apply(entities, Array(result.length).fill(entity));\n      offsetChange += result.length - length;\n    });\n    return {\n      text: text,\n      inlines: Array(text.length).fill(inlineStyle),\n      entities: entities,\n      blocks: []\n    };\n  } // BR tags\n\n\n  if (nodeName === 'br') {\n    var _blockType = inBlock;\n\n    if (_blockType === null) {\n      //  BR tag is at top level, treat it as an unstyled block\n      return getSoftNewlineChunk('unstyled', depth, true);\n    }\n\n    return getSoftNewlineChunk(_blockType || 'unstyled', depth, options.flat);\n  }\n\n  var chunk = getEmptyChunk();\n  var newChunk = null; // Inline tags\n\n  inlineStyle = processInlineTag(nodeName, node, inlineStyle);\n  inlineStyle = processCustomInlineStyles(nodeName, node, inlineStyle); // Handle lists\n\n  if (nodeName === 'ul' || nodeName === 'ol') {\n    if (lastList) {\n      depth += 1;\n    }\n\n    lastList = nodeName;\n    inBlock = null;\n  } // Block Tags\n\n\n  var blockInfo = checkBlockType(nodeName, node, lastList, inBlock);\n  var blockType;\n  var blockDataMap;\n\n  if (blockInfo === false) {\n    return getEmptyChunk();\n  }\n\n  blockInfo = blockInfo || {};\n\n  if (typeof blockInfo === 'string') {\n    blockType = blockInfo;\n    blockDataMap = (0, _immutable.Map)();\n  } else {\n    blockType = typeof blockInfo === 'string' ? blockInfo : blockInfo.type;\n    blockDataMap = blockInfo.data ? (0, _immutable.Map)(blockInfo.data) : (0, _immutable.Map)();\n  }\n\n  if (!inBlock && (fragmentBlockTags.indexOf(nodeName) !== -1 || blockType)) {\n    chunk = getBlockDividerChunk(blockType || getBlockTypeForTag(nodeName, lastList), depth, blockDataMap);\n    inBlock = blockType || getBlockTypeForTag(nodeName, lastList);\n    newBlock = true;\n  } else if (lastList && (inBlock === 'ordered-list-item' || inBlock === 'unordered-list-item') && nodeName === 'li') {\n    var listItemBlockType = getBlockTypeForTag(nodeName, lastList);\n    chunk = getBlockDividerChunk(listItemBlockType, depth);\n    inBlock = listItemBlockType;\n    newBlock = true;\n    nextBlockType = lastList === 'ul' ? 'unordered-list-item' : 'ordered-list-item';\n  } else if (inBlock && inBlock !== 'atomic' && blockType === 'atomic') {\n    inBlock = blockType;\n    newBlock = true;\n    chunk = getSoftNewlineChunk(blockType, depth, true, // atomic blocks within non-atomic blocks must always be split out\n    blockDataMap);\n  } // Recurse through children\n\n\n  var child = node.firstChild; // hack to allow conversion of atomic blocks from HTML (e.g. <figure><img\n  // src=\"...\" /></figure>). since metadata must be stored on an entity text\n  // must exist for the entity to apply to. the way chunks are joined strips\n  // whitespace at the end so it cannot be a space character.\n\n  if (child == null && inEntity && (blockType === 'atomic' || inBlock === 'atomic')) {\n    child = document.createTextNode('a');\n  }\n\n  if (child != null) {\n    nodeName = child.nodeName.toLowerCase();\n  }\n\n  var entityId = null;\n\n  while (child) {\n    entityId = checkEntityNode(nodeName, child, createEntity, getEntity, mergeEntityData, replaceEntityData);\n    newChunk = genFragment(child, inlineStyle, lastList, inBlock, fragmentBlockTags, depth, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, entityId || inEntity);\n    chunk = joinChunks(chunk, newChunk, options.flat);\n    var sibling = child.nextSibling; // Put in a newline to break up blocks inside blocks\n\n    if (sibling && fragmentBlockTags.indexOf(nodeName) >= 0 && inBlock) {\n      var newBlockInfo = checkBlockType(nodeName, child, lastList, inBlock);\n      var newBlockType = void 0;\n      var newBlockData = void 0;\n\n      if (newBlockInfo !== false) {\n        newBlockInfo = newBlockInfo || {};\n\n        if (typeof newBlockInfo === 'string') {\n          newBlockType = newBlockInfo;\n          newBlockData = (0, _immutable.Map)();\n        } else {\n          newBlockType = newBlockInfo.type || getBlockTypeForTag(nodeName, lastList);\n          newBlockData = newBlockInfo.data ? (0, _immutable.Map)(newBlockInfo.data) : (0, _immutable.Map)();\n        }\n\n        chunk = joinChunks(chunk, getSoftNewlineChunk(newBlockType, depth, options.flat, newBlockData), options.flat);\n      }\n    }\n\n    if (sibling) {\n      nodeName = sibling.nodeName.toLowerCase();\n    }\n\n    child = sibling;\n  }\n\n  if (newBlock) {\n    chunk = joinChunks(chunk, getBlockDividerChunk(nextBlockType, depth, (0, _immutable.Map)()), options.flat);\n  }\n\n  return chunk;\n}\n\nfunction getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder) {\n  html = html.trim().replace(REGEX_CR, '').replace(REGEX_NBSP, SPACE);\n  var safeBody = DOMBuilder(html);\n\n  if (!safeBody) {\n    return null;\n  } // Sometimes we aren't dealing with content that contains nice semantic\n  // tags. In this case, use divs to separate everything out into paragraphs\n  // and hope for the best.\n\n\n  var workingBlocks = containsSemanticBlockMarkup(html) ? blockTags.concat(['div']) : ['div']; // Start with -1 block depth to offset the fact that we are passing in a fake\n  // UL block to sta rt with.\n\n  var chunk = genFragment(safeBody, (0, _immutable.OrderedSet)(), 'ul', null, workingBlocks, -1, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options); // join with previous block to prevent weirdness on paste\n\n  if (chunk.text.indexOf('\\r') === 0) {\n    chunk = {\n      text: chunk.text.slice(1),\n      inlines: chunk.inlines.slice(1),\n      entities: chunk.entities.slice(1),\n      blocks: chunk.blocks\n    };\n  } // Kill block delimiter at the end\n\n\n  if (chunk.text.slice(-1) === '\\r') {\n    chunk.text = chunk.text.slice(0, -1);\n    chunk.inlines = chunk.inlines.slice(0, -1);\n    chunk.entities = chunk.entities.slice(0, -1);\n    chunk.blocks.pop();\n  } // If we saw no block tags, put an unstyled one in\n\n\n  if (chunk.blocks.length === 0) {\n    chunk.blocks.push({\n      type: 'unstyled',\n      data: (0, _immutable.Map)(),\n      depth: 0\n    });\n  } // Sometimes we start with text that isn't in a block, which is then\n  // followed by blocks. Need to fix up the blocks to add in\n  // an unstyled block for this content\n\n\n  if (chunk.text.split('\\r').length === chunk.blocks.length + 1) {\n    chunk.blocks.unshift({\n      type: 'unstyled',\n      data: (0, _immutable.Map)(),\n      depth: 0\n    });\n  }\n\n  return chunk;\n}\n\nfunction convertFromHTMLtoContentBlocks(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey) {\n  // Be ABSOLUTELY SURE that the dom builder you pass hare won't execute\n  // arbitrary code in whatever environment you're running this in. For an\n  // example of how we try to do this in-browser, see getSafeBodyFromHTML.\n  var chunk = getChunkForHTML(html, processCustomInlineStyles, checkEntityNode, checkEntityText, checkBlockType, createEntity, getEntity, mergeEntityData, replaceEntityData, options, DOMBuilder, generateKey);\n\n  if (chunk == null) {\n    return [];\n  }\n\n  var start = 0;\n  return chunk.text.split('\\r').map(function (textBlock, blockIndex) {\n    // Make absolutely certain that our text is acceptable.\n    textBlock = sanitizeDraftText(textBlock);\n    var end = start + textBlock.length;\n    var inlines = nullthrows(chunk).inlines.slice(start, end);\n    var entities = nullthrows(chunk).entities.slice(start, end);\n    var characterList = (0, _immutable.List)(inlines.map(function (style, entityIndex) {\n      var data = {\n        style: style,\n        entity: null\n      };\n\n      if (entities[entityIndex]) {\n        data.entity = entities[entityIndex];\n      }\n\n      return _draftJs.CharacterMetadata.create(data);\n    }));\n    start = end + 1;\n    return new _draftJs.ContentBlock({\n      key: generateKey(),\n      type: nullthrows(chunk).blocks[blockIndex].type,\n      data: nullthrows(chunk).blocks[blockIndex].data,\n      depth: nullthrows(chunk).blocks[blockIndex].depth,\n      text: textBlock,\n      characterList: characterList\n    });\n  });\n}\n\nvar convertFromHTML = function convertFromHTML(_ref2) {\n  var _ref2$htmlToStyle = _ref2.htmlToStyle,\n      htmlToStyle = _ref2$htmlToStyle === void 0 ? defaultHTMLToStyle : _ref2$htmlToStyle,\n      _ref2$htmlToEntity = _ref2.htmlToEntity,\n      htmlToEntity = _ref2$htmlToEntity === void 0 ? defaultHTMLToEntity : _ref2$htmlToEntity,\n      _ref2$textToEntity = _ref2.textToEntity,\n      textToEntity = _ref2$textToEntity === void 0 ? defaultTextToEntity : _ref2$textToEntity,\n      _ref2$htmlToBlock = _ref2.htmlToBlock,\n      htmlToBlock = _ref2$htmlToBlock === void 0 ? defaultHTMLToBlock : _ref2$htmlToBlock;\n  return function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      flat: false\n    };\n    var DOMBuilder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _parseHTML[\"default\"];\n    var generateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _draftJs.genKey;\n\n    var contentState = _draftJs.ContentState.createFromText('');\n\n    var createEntityWithContentState = function createEntityWithContentState() {\n      if (contentState.createEntity) {\n        var _contentState;\n\n        contentState = (_contentState = contentState).createEntity.apply(_contentState, arguments);\n        return contentState.getLastCreatedEntityKey();\n      }\n\n      return _draftJs.Entity.create.apply(_draftJs.Entity, arguments);\n    };\n\n    var getEntityWithContentState = function getEntityWithContentState() {\n      if (contentState.getEntity) {\n        var _contentState2;\n\n        return (_contentState2 = contentState).getEntity.apply(_contentState2, arguments);\n      }\n\n      return _draftJs.Entity.get.apply(_draftJs.Entity, arguments);\n    };\n\n    var mergeEntityDataWithContentState = function mergeEntityDataWithContentState() {\n      if (contentState.mergeEntityData) {\n        var _contentState3;\n\n        contentState = (_contentState3 = contentState).mergeEntityData.apply(_contentState3, arguments);\n        return;\n      }\n\n      _draftJs.Entity.mergeData.apply(_draftJs.Entity, arguments);\n    };\n\n    var replaceEntityDataWithContentState = function replaceEntityDataWithContentState() {\n      if (contentState.replaceEntityData) {\n        var _contentState4;\n\n        contentState = (_contentState4 = contentState).replaceEntityData.apply(_contentState4, arguments);\n        return;\n      }\n\n      _draftJs.Entity.replaceData.apply(_draftJs.Entity, arguments);\n    };\n\n    var contentBlocks = convertFromHTMLtoContentBlocks(html, handleMiddleware(htmlToStyle, baseProcessInlineTag), handleMiddleware(htmlToEntity, defaultHTMLToEntity), handleMiddleware(textToEntity, defaultTextToEntity), handleMiddleware(htmlToBlock, baseCheckBlockType), createEntityWithContentState, getEntityWithContentState, mergeEntityDataWithContentState, replaceEntityDataWithContentState, options, DOMBuilder, generateKey);\n\n    var blockMap = _draftJs.BlockMapBuilder.createFromArray(contentBlocks);\n\n    var firstBlockKey = contentBlocks[0].getKey();\n    return contentState.merge({\n      blockMap: blockMap,\n      selectionBefore: _draftJs.SelectionState.createEmpty(firstBlockKey),\n      selectionAfter: _draftJs.SelectionState.createEmpty(firstBlockKey)\n    });\n  };\n};\n\nvar _default = function _default() {\n  if (arguments.length >= 1 && typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n    return convertFromHTML({}).apply(void 0, arguments);\n  }\n\n  return convertFromHTML.apply(void 0, arguments);\n};\n\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}