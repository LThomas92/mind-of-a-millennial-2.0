{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DOMException = require(\"domexception\");\n\nvar reportException = require(\"../helpers/runtime-script-errors\");\n\nvar _require = require(\"../helpers/internal-constants\"),\n    domSymbolTree = _require.domSymbolTree;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar Event = require(\"../generated/Event\").interface;\n\nvar EventTargetImpl =\n/*#__PURE__*/\nfunction () {\n  function EventTargetImpl() {\n    _classCallCheck(this, EventTargetImpl);\n\n    this._eventListeners = Object.create(null);\n  }\n\n  _createClass(EventTargetImpl, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, callback, options) {\n      // webidl2js currently can't handle neither optional arguments nor callback interfaces\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n      if (callback === null) {\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        this._eventListeners[type] = [];\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.options.capture === options.capture && listener.callback === callback) {\n          return;\n        }\n      }\n\n      this._eventListeners[type].push({\n        callback: callback,\n        options: options\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback, options) {\n      if (callback === undefined || callback === null) {\n        callback = null;\n      } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n        throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n      }\n\n      options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n      if (callback === null) {\n        // Optimization, not in the spec.\n        return;\n      }\n\n      if (!this._eventListeners[type]) {\n        return;\n      }\n\n      for (var i = 0; i < this._eventListeners[type].length; ++i) {\n        var listener = this._eventListeners[type][i];\n\n        if (listener.callback === callback && listener.options.capture === options.capture) {\n          this._eventListeners[type].splice(i, 1);\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(eventImpl) {\n      if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n        throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n      }\n\n      if (eventImpl.eventPhase !== Event.NONE) {\n        throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n      }\n\n      eventImpl.isTrusted = false;\n      return this._dispatch(eventImpl);\n    }\n  }, {\n    key: \"_dispatch\",\n    value: function _dispatch(eventImpl, targetOverride) {\n      eventImpl._dispatchFlag = true;\n      eventImpl.target = targetOverride || this;\n      var eventPath = [];\n      var target = eventImpl.target;\n      var targetParent = domSymbolTree.parent(target);\n\n      while (targetParent) {\n        eventPath.push(targetParent);\n        target = targetParent;\n        targetParent = domSymbolTree.parent(targetParent);\n      }\n\n      if (eventImpl.type !== \"load\" && target._defaultView) {\n        // https://html.spec.whatwg.org/#events-and-the-window-object\n        eventPath.push(idlUtils.implForWrapper(target._defaultView));\n      }\n\n      eventImpl.eventPhase = Event.CAPTURING_PHASE;\n\n      for (var i = eventPath.length - 1; i >= 0; --i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        var object = eventPath[i];\n        var objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n\n        var eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n\n      eventImpl.eventPhase = Event.AT_TARGET;\n\n      if (!eventImpl._stopPropagationFlag) {\n        if (this._eventListeners[eventImpl.type]) {\n          var _eventListeners = this._eventListeners[eventImpl.type];\n          invokeEventListeners(_eventListeners, eventImpl.target, eventImpl);\n        }\n      }\n\n      if (eventImpl.bubbles) {\n        eventImpl.eventPhase = Event.BUBBLING_PHASE;\n\n        for (var _i = 0; _i < eventPath.length; ++_i) {\n          if (eventImpl._stopPropagationFlag) {\n            break;\n          }\n\n          var _object = eventPath[_i];\n\n          var _objectImpl = idlUtils.implForWrapper(_object) || _object; // window :(\n\n\n          var _eventListeners2 = _objectImpl._eventListeners[eventImpl.type];\n          invokeEventListeners(_eventListeners2, _object, eventImpl);\n        }\n      }\n\n      eventImpl._dispatchFlag = false;\n      eventImpl._stopPropagationFlag = false;\n      eventImpl._stopImmediatePropagationFlag = false;\n      eventImpl.eventPhase = Event.NONE;\n      eventImpl.currentTarget = null;\n      return !eventImpl._canceledFlag;\n    }\n  }]);\n\n  return EventTargetImpl;\n}();\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  var wrapper = idlUtils.wrapperForImpl(target);\n  var document = target._ownerDocument || wrapper && (wrapper._document || wrapper._ownerDocument); // Will be falsy for windows that have closed\n\n  if (!document) {\n    return;\n  } // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n\n\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n\n  eventImpl.currentTarget = target;\n\n  if (!listeners) {\n    return;\n  }\n\n  var handlers = listeners.slice();\n\n  for (var i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    var listener = handlers[i];\n    var _listener$options = listener.options,\n        capture = _listener$options.capture,\n        once = _listener$options.once;\n\n    if (listeners.indexOf(listener) === -1 || eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      var window = null;\n\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n  }\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  var returnValue = {}; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(function (k) {\n      return k !== \"capture\";\n    });\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = defaultBoolKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      returnValue[key] = Boolean(options[key]);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return returnValue;\n}","map":null,"metadata":{},"sourceType":"script"}