{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp;\n/*\n * Copyright (c) 2016, Globo.com (https://github.com/globocom)\n *\n * License: MIT\n */\n\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _draftJs = require(\"draft-js\");\n\nvar _classnames = require(\"classnames\");\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _ToolbarItem = require(\"./ToolbarItem\");\n\nvar _ToolbarItem2 = _interopRequireDefault(_ToolbarItem);\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar Toolbar = (_temp = _class = function (_Component) {\n  _inherits(Toolbar, _Component);\n\n  function Toolbar(props) {\n    _classCallCheck(this, Toolbar);\n\n    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, props));\n\n    _this.state = {\n      show: false,\n      editingEntity: null,\n      link: \"\",\n      error: null\n    };\n    _this.renderButton = _this.renderButton.bind(_this);\n    _this.cancelEntity = _this.cancelEntity.bind(_this);\n    _this.removeEntity = _this.removeEntity.bind(_this);\n    _this.setError = _this.setError.bind(_this);\n    _this.cancelError = _this.cancelError.bind(_this);\n    return _this;\n  }\n\n  _createClass(Toolbar, [{\n    key: \"toggleInlineStyle\",\n    value: function toggleInlineStyle(inlineStyle) {\n      var newEditorState = _draftJs.RichUtils.toggleInlineStyle(this.props.editorState, inlineStyle);\n\n      this.props.onChange(newEditorState);\n    }\n  }, {\n    key: \"toggleBlockType\",\n    value: function toggleBlockType(blockType) {\n      this.props.onChange(_draftJs.RichUtils.toggleBlockType(this.props.editorState, blockType));\n    }\n  }, {\n    key: \"toggleEntity\",\n    value: function toggleEntity(entity) {\n      this.setState({\n        editingEntity: entity\n      });\n    }\n  }, {\n    key: \"renderButton\",\n    value: function renderButton(item, position) {\n      var _this2 = this;\n\n      var current = null;\n      var toggle = null;\n      var active = null;\n      var key = item.label;\n\n      switch (item.type) {\n        case \"custom\":\n          {\n            key = \"custom-\" + position;\n\n            toggle = function toggle() {\n              return item.action(_this2.props.editorState, _this2.props.onChange);\n            };\n\n            active = item.active && item.active(this.props.editorState);\n            break;\n          }\n\n        case \"inline\":\n          {\n            current = this.props.editorState.getCurrentInlineStyle();\n\n            toggle = function toggle() {\n              return _this2.toggleInlineStyle(item.style);\n            };\n\n            active = current.has(item.style);\n            break;\n          }\n\n        case \"block\":\n          {\n            var selection = this.props.editorState.getSelection();\n            current = this.props.editorState.getCurrentContent().getBlockForKey(selection.getStartKey()).getType();\n\n            toggle = function toggle() {\n              return _this2.toggleBlockType(item.style);\n            };\n\n            active = item.style === current;\n            break;\n          }\n\n        case \"separator\":\n          {\n            key = \"sep-\" + position;\n            break;\n          }\n\n        case \"entity\":\n          {\n            var _item$entity = item.entity,\n                entity = _item$entity === undefined ? \"LINK\" : _item$entity;\n            key = \"entity-\" + entity;\n\n            toggle = function toggle() {\n              return _this2.toggleEntity(entity);\n            };\n\n            active = this.hasEntity(entity);\n            break;\n          }\n      }\n\n      return _react2.default.createElement(_ToolbarItem2.default, {\n        key: key,\n        active: active,\n        toggle: toggle,\n        item: item\n      });\n    }\n  }, {\n    key: \"setError\",\n    value: function setError(errorMsg) {\n      this.setState({\n        error: errorMsg\n      });\n    }\n  }, {\n    key: \"cancelError\",\n    value: function cancelError() {\n      this.setState({\n        error: null\n      });\n    }\n  }, {\n    key: \"setBarPosition\",\n    value: function setBarPosition() {\n      var editor = this.props.editor;\n      var toolbar = this.toolbarEl;\n      var selectionCoords = (0, _utils.getSelectionCoords)(editor, toolbar);\n\n      if (!selectionCoords) {\n        return null;\n      }\n\n      if (selectionCoords && !this.state.position || this.state.position.top !== selectionCoords.offsetTop || this.state.position.left !== selectionCoords.offsetLeft || this.state.arrowStyle !== selectionCoords.arrowStyle || !this.state.show) {\n        this.setState({\n          show: true,\n          position: {\n            top: selectionCoords.offsetTop,\n            left: selectionCoords.offsetLeft\n          },\n          arrowStyle: selectionCoords.arrowStyle\n        });\n      }\n    }\n  }, {\n    key: \"handleSetToolbar\",\n    value: function handleSetToolbar() {\n      if (this.props.shouldDisplayToolbarFn(this.props, this.state)) {\n        this.shouldUpdatePos = false;\n        return this.setBarPosition();\n      } else {\n        if (this.state.show) {\n          this.setState({\n            show: false,\n            editingEntity: null,\n            link: \"\",\n            error: null\n          });\n        }\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var currentContentState = this.props.editorState.getCurrentContent();\n      var newContentState = nextProps.editorState.getCurrentContent();\n\n      if (currentContentState === newContentState) {\n        this.shouldUpdatePos = true;\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      if (this.shouldUpdatePos) {\n        this.handleSetToolbar();\n      }\n    }\n  }, {\n    key: \"getCurrentEntityKey\",\n    value: function getCurrentEntityKey() {\n      var selection = this.props.editorState.getSelection();\n      var anchorKey = selection.getAnchorKey();\n      var contentState = this.props.editorState.getCurrentContent();\n      var anchorBlock = contentState.getBlockForKey(anchorKey);\n      var offset = selection.anchorOffset;\n      var index = selection.isBackward ? offset - 1 : offset;\n      return anchorBlock.getEntityAt(index);\n    }\n  }, {\n    key: \"getCurrentEntity\",\n    value: function getCurrentEntity() {\n      var contentState = this.props.editorState.getCurrentContent();\n      var entityKey = this.getCurrentEntityKey();\n\n      if (entityKey) {\n        return contentState.getEntity(entityKey);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasEntity\",\n    value: function hasEntity(entityType) {\n      var entity = this.getCurrentEntity();\n\n      if (entity && entity.getType() === entityType) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"setEntity\",\n    value: function setEntity(entityType, data) {\n      var mutability = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"MUTABLE\";\n      var editorState = this.props.editorState;\n      var contentState = editorState.getCurrentContent();\n      var contentStateWithEntity = contentState.createEntity(entityType, mutability, data);\n      var entityKey = contentStateWithEntity.getLastCreatedEntityKey();\n\n      var newState = _draftJs.RichUtils.toggleLink(editorState, editorState.getSelection(), entityKey);\n\n      var selectionState = _draftJs.EditorState.forceSelection(newState, editorState.getSelection());\n\n      this.props.onChange(selectionState);\n    }\n  }, {\n    key: \"removeEntity\",\n    value: function removeEntity() {\n      var editorState = this.props.editorState;\n      var selection = editorState.getSelection();\n\n      if (!selection.isCollapsed()) {\n        // toggleLink should be named toggleEntity: https://github.com/facebook/draft-js/issues/737\n        this.props.onChange(_draftJs.RichUtils.toggleLink(editorState, selection, null));\n      }\n\n      this.cancelEntity();\n    }\n  }, {\n    key: \"cancelEntity\",\n    value: function cancelEntity() {\n      var _this3 = this;\n\n      this.setState({\n        editingEntity: null,\n        error: null\n      }, function () {\n        _this3.props.draft && _this3.props.draft.focus();\n      });\n    }\n  }, {\n    key: \"renderEntityInput\",\n    value: function renderEntityInput(entityType) {\n      var _this4 = this;\n\n      if (!this.props.entityInputs) {\n        console.warn(\"no entityInputs provided\");\n        return null;\n      }\n\n      var Component = this.props.entityInputs[entityType];\n\n      var setEntity = function setEntity(data, mutability) {\n        return _this4.setEntity(entityType, data, mutability);\n      };\n\n      var entityData = {};\n      var entity = null;\n\n      if (this.hasEntity(entityType)) {\n        entity = this.getCurrentEntity();\n\n        if (entity) {\n          entityData = entity.getData();\n        }\n      }\n\n      if (Component) {\n        return _react2.default.createElement(Component, _extends({\n          i18n: this.props.i18n,\n          editorState: this.props.editorState,\n          setEntity: setEntity,\n          entityType: entityType,\n          onChange: this.props.onChange,\n          cancelEntity: this.cancelEntity,\n          removeEntity: this.removeEntity,\n          setError: this.setError,\n          cancelError: this.cancelError,\n          entity: entity\n        }, entityData));\n      } else {\n        console.warn(\"unknown entity type: \" + entityType);\n        return null;\n      }\n    }\n  }, {\n    key: \"renderToolList\",\n    value: function renderToolList() {\n      return _react2.default.createElement(\"ul\", {\n        className: \"toolbar__list\"\n      }, this.props.actions.map(this.renderButton));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      if (this.props.readOnly || !this.props.shouldDisplayToolbarFn(this.props, this.state)) {\n        return null;\n      }\n\n      var toolbarClass = (0, _classnames2.default)(\"toolbar\", {\n        \"toolbar--open\": this.state.show,\n        \"toolbar--error\": this.state.error\n      });\n      return _react2.default.createElement(\"div\", {\n        className: toolbarClass,\n        style: this.state.position,\n        ref: \"toolbarWrapper\"\n      }, _react2.default.createElement(\"div\", {\n        style: {\n          position: \"absolute\",\n          bottom: 0\n        }\n      }, _react2.default.createElement(\"div\", {\n        className: \"toolbar__wrapper\",\n        ref: function ref(el) {\n          _this5.toolbarEl = el;\n        },\n        onMouseDown: function onMouseDown(e) {\n          if (e.target.localName !== \"input\") {\n            e.preventDefault();\n          }\n        }\n      }, this.state.editingEntity ? this.renderEntityInput(this.state.editingEntity) : this.renderToolList(), _react2.default.createElement(\"p\", {\n        className: \"toolbar__error-msg\"\n      }, this.state.error), _react2.default.createElement(\"span\", {\n        className: \"toolbar__arrow\",\n        ref: function ref(el) {\n          _this5.arrowEl = el;\n        },\n        style: this.state.arrowStyle\n      }))));\n    }\n  }]);\n\n  return Toolbar;\n}(_react.Component), _class.defaultProps = {\n  shouldDisplayToolbarFn: function shouldDisplayToolbarFn(props, state) {\n    return (props.editorHasFocus || state.editingEntity) && !props.editorState.getSelection().isCollapsed();\n  }\n}, _class.propTypes = {\n  editorHasFocus: _propTypes2.default.bool\n}, _temp);\nexports.default = Toolbar;","map":null,"metadata":{},"sourceType":"script"}