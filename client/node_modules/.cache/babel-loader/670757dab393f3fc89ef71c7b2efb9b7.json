{"ast":null,"code":"// AST walker module for Mozilla Parser API compatible trees\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type,\n        found = visitors[type];\n    baseVisitor[type](node, st, c);\n\n    if (found) {\n      found(node, st);\n    }\n  })(node, state, override);\n} // An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\n\n\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type,\n        found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n\n    if (isNew) {\n      ancestors.push(node);\n    }\n\n    baseVisitor[type](node, st, c);\n\n    if (found) {\n      found(node, st || ancestors, ancestors);\n    }\n\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n} // A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\n\n\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n\n  (function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\") {\n    return function (type) {\n      return type === test;\n    };\n  } else if (!test) {\n    return function () {\n      return true;\n    };\n  } else {\n    return test;\n  }\n}\n\nvar Found = function Found(node, state) {\n  this.node = node;\n  this.state = state;\n}; // A full walk triggers the callback on each node\n\n\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  (function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n\n    if (!override) {\n      callback(node, st, type);\n    }\n  })(node, state, override);\n} // An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\n\n\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  var ancestors = [];\n\n  (function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n\n    if (isNew) {\n      ancestors.push(node);\n    }\n\n    baseVisitor[type](node, st, c);\n\n    if (!override) {\n      callback(node, st || ancestors, ancestors, type);\n    }\n\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n} // Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\n\n\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  test = makeTest(test);\n\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n\n      if ((start == null || node.start <= start) && (end == null || node.end >= end)) {\n        baseVisitor[type](node, st, c);\n      }\n\n      if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\n\n\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n\n      if (node.start > pos || node.end < pos) {\n        return;\n      }\n\n      baseVisitor[type](node, st, c);\n\n      if (test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the outermost matching node after a given position.\n\n\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) {\n        return;\n      }\n\n      var type = override || node.type;\n\n      if (node.start >= pos && test(type, node)) {\n        throw new Found(node, st);\n      }\n\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n\n    throw e;\n  }\n} // Find the outermost matching node before a given position.\n\n\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n\n  var max;\n\n  (function c(node, st, override) {\n    if (node.start > pos) {\n      return;\n    }\n\n    var type = override || node.type;\n\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n      max = new Found(node, st);\n    }\n\n    baseVisitor[type](node, st, c);\n  })(node, state);\n\n  return max;\n} // Fallback to an Object.create polyfill for older environments.\n\n\nvar create = Object.create || function (proto) {\n  function Ctor() {}\n\n  Ctor.prototype = proto;\n  return new Ctor();\n}; // Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\n\n\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n\n  for (var type in funcs) {\n    visitor[type] = funcs[type];\n  }\n\n  return visitor;\n}\n\nfunction skipThrough(node, st, c) {\n  c(node, st);\n}\n\nfunction ignore(_node, _st, _c) {} // Node walkers.\n\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var stmt = list[i];\n    c(stmt, st, \"Statement\");\n  }\n};\n\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\n\nbase.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {\n  return c(node.expression, st, \"Expression\");\n};\n\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n\n  if (node.alternate) {\n    c(node.alternate, st, \"Statement\");\n  }\n};\n\nbase.LabeledStatement = function (node, st, c) {\n  return c(node.body, st, \"Statement\");\n};\n\nbase.BreakStatement = base.ContinueStatement = ignore;\n\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n\n  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n    var cs = list[i];\n\n    if (cs.test) {\n      c(cs.test, st, \"Expression\");\n    }\n\n    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1) {\n      var cons = list$1[i$1];\n      c(cons, st, \"Statement\");\n    }\n  }\n};\n\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n    var cons = list[i];\n    c(cons, st, \"Statement\");\n  }\n};\n\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) {\n    c(node.argument, st, \"Expression\");\n  }\n};\n\nbase.ThrowStatement = base.SpreadElement = function (node, st, c) {\n  return c(node.argument, st, \"Expression\");\n};\n\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n\n  if (node.handler) {\n    c(node.handler, st);\n  }\n\n  if (node.finalizer) {\n    c(node.finalizer, st, \"Statement\");\n  }\n};\n\nbase.CatchClause = function (node, st, c) {\n  if (node.param) {\n    c(node.param, st, \"Pattern\");\n  }\n\n  c(node.body, st, \"Statement\");\n};\n\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForStatement = function (node, st, c) {\n  if (node.init) {\n    c(node.init, st, \"ForInit\");\n  }\n\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n\n  if (node.update) {\n    c(node.update, st, \"Expression\");\n  }\n\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\n\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") {\n    c(node, st);\n  } else {\n    c(node, st, \"Expression\");\n  }\n};\n\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) {\n  return c(node, st, \"Function\");\n};\n\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n    var decl = list[i];\n    c(decl, st);\n  }\n};\n\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n\n  if (node.init) {\n    c(node.init, st, \"Expression\");\n  }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    c(param, st, \"Pattern\");\n  }\n\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\") {\n    c(node, st, \"VariablePattern\");\n  } else if (node.type === \"MemberExpression\") {\n    c(node, st, \"MemberPattern\");\n  } else {\n    c(node, st);\n  }\n};\n\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\n\nbase.RestElement = function (node, st, c) {\n  return c(node.argument, st, \"Pattern\");\n};\n\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Pattern\");\n    }\n  }\n};\n\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) {\n        c(prop.key, st, \"Expression\");\n      }\n\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\n\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) {\n      c(elt, st, \"Expression\");\n    }\n  }\n};\n\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n    c(prop, st);\n  }\n};\n\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\n\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n    var expr = list[i];\n    c(expr, st, \"Expression\");\n  }\n};\n\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n    var quasi = list[i];\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n    var expr = list$1[i$1];\n    c(expr, st, \"Expression\");\n  }\n};\n\nbase.TemplateElement = ignore;\n\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\n\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\n\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\n\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\n\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n\n  if (node.arguments) {\n    for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n      var arg = list[i];\n      c(arg, st, \"Expression\");\n    }\n  }\n};\n\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n\n  if (node.computed) {\n    c(node.property, st, \"Expression\");\n  }\n};\n\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration) {\n    c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n  }\n\n  if (node.source) {\n    c(node.source, st, \"Expression\");\n  }\n};\n\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\n\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n    var spec = list[i];\n    c(spec, st);\n  }\n\n  c(node.source, st, \"Expression\");\n};\n\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\n\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) {\n  return c(node, st, \"Class\");\n};\n\nbase.Class = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n\n  if (node.superClass) {\n    c(node.superClass, st, \"Expression\");\n  }\n\n  c(node.body, st);\n};\n\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var elt = list[i];\n    c(elt, st);\n  }\n};\n\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) {\n    c(node.key, st, \"Expression\");\n  }\n\n  c(node.value, st, \"Expression\");\n};\n\nexport { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };","map":null,"metadata":{},"sourceType":"module"}