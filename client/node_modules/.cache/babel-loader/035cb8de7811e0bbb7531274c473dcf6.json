{"ast":null,"code":"\"use strict\";\n/**\n * btoa() as defined by the HTML and Infra specs, which mostly just references\n * RFC 4648.\n */\n\nfunction btoa(s) {\n  var i; // String conversion as required by Web IDL.\n\n  s = \"\".concat(s); // \"The btoa() method must throw an \"InvalidCharacterError\" DOMException if\n  // data contains any character whose code point is greater than U+00FF.\"\n\n  for (i = 0; i < s.length; i++) {\n    if (s.charCodeAt(i) > 255) {\n      return null;\n    }\n  }\n\n  var out = \"\";\n\n  for (i = 0; i < s.length; i += 3) {\n    var groupsOfSix = [undefined, undefined, undefined, undefined];\n    groupsOfSix[0] = s.charCodeAt(i) >> 2;\n    groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;\n\n    if (s.length > i + 1) {\n      groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;\n      groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;\n    }\n\n    if (s.length > i + 2) {\n      groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;\n      groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;\n    }\n\n    for (var j = 0; j < groupsOfSix.length; j++) {\n      if (typeof groupsOfSix[j] === \"undefined\") {\n        out += \"=\";\n      } else {\n        out += btoaLookup(groupsOfSix[j]);\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Lookup table for btoa(), which converts a six-bit number into the\n * corresponding ASCII character.\n */\n\n\nfunction btoaLookup(idx) {\n  if (idx < 26) {\n    return String.fromCharCode(idx + \"A\".charCodeAt(0));\n  }\n\n  if (idx < 52) {\n    return String.fromCharCode(idx - 26 + \"a\".charCodeAt(0));\n  }\n\n  if (idx < 62) {\n    return String.fromCharCode(idx - 52 + \"0\".charCodeAt(0));\n  }\n\n  if (idx === 62) {\n    return \"+\";\n  }\n\n  if (idx === 63) {\n    return \"/\";\n  } // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.\n\n\n  return undefined;\n}\n\nmodule.exports = btoa;","map":null,"metadata":{},"sourceType":"script"}