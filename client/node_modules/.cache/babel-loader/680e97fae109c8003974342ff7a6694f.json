{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar webIDLConversions = require(\"webidl-conversions\");\n\nvar _require = require(\"cssstyle\"),\n    CSSStyleDeclaration = _require.CSSStyleDeclaration;\n\nvar _require2 = require(\"w3c-hr-time\"),\n    RawPerformance = _require2.Performance;\n\nvar notImplemented = require(\"./not-implemented\");\n\nvar VirtualConsole = require(\"../virtual-console\");\n\nvar _require3 = require(\"../utils\"),\n    define = _require3.define,\n    mixin = _require3.mixin;\n\nvar EventTarget = require(\"../living/generated/EventTarget\");\n\nvar namedPropertiesWindow = require(\"../living/named-properties-window\");\n\nvar cssom = require(\"cssom\");\n\nvar postMessage = require(\"../living/post-message\");\n\nvar DOMException = require(\"domexception\");\n\nvar _require4 = require(\"abab\"),\n    btoa = _require4.btoa,\n    atob = _require4.atob;\n\nvar idlUtils = require(\"../living/generated/utils\");\n\nvar createXMLHttpRequest = require(\"../living/xmlhttprequest\");\n\nvar createFileReader = require(\"../living/generated/FileReader\").createInterface;\n\nvar createWebSocket = require(\"../living/generated/WebSocket\").createInterface;\n\nvar WebSocketImpl = require(\"../living/websockets/WebSocket-impl\").implementation;\n\nvar BarProp = require(\"../living/generated/BarProp\");\n\nvar Document = require(\"../living/generated/Document\");\n\nvar External = require(\"../living/generated/External\");\n\nvar Navigator = require(\"../living/generated/Navigator\");\n\nvar Performance = require(\"../living/generated/Performance\");\n\nvar Screen = require(\"../living/generated/Screen\");\n\nvar Storage = require(\"../living/generated/Storage\");\n\nvar createAbortController = require(\"../living/generated/AbortController\").createInterface;\n\nvar createAbortSignal = require(\"../living/generated/AbortSignal\").createInterface;\n\nvar reportException = require(\"../living/helpers/runtime-script-errors\");\n\nvar _require5 = require(\"../living/helpers/selectors\"),\n    matchesDontThrow = _require5.matchesDontThrow;\n\nvar SessionHistory = require(\"../living/window/SessionHistory\");\n\nvar _require6 = require(\"./documentfeatures.js\"),\n    contextifyWindow = _require6.contextifyWindow;\n\nvar GlobalEventHandlersImpl = require(\"../living/nodes/GlobalEventHandlers-impl\").implementation;\n\nvar WindowEventHandlersImpl = require(\"../living/nodes/WindowEventHandlers-impl\").implementation; // NB: the require() must be after assigning `module.exports` because this require() is circular\n// TODO: this above note might not even be true anymore... figure out the cycle and document it, or clean up.\n\n\nmodule.exports = Window;\n\nvar dom = require(\"../living\");\n\nvar cssSelectorSplitRE = /((?:[^,\"']|\"[^\"]*\"|'[^']*')+)/;\nvar defaultStyleSheet = cssom.parse(require(\"./default-stylesheet\"));\ndom.Window = Window; // NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.\n// That is why we assign everything inside of the constructor, instead of using a shared prototype.\n// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.\n\nfunction Window(options) {\n  var _this = this;\n\n  EventTarget.setup(this);\n  var rawPerformance = new RawPerformance();\n  var windowInitialized = rawPerformance.now();\n  var window = this;\n  mixin(window, WindowEventHandlersImpl.prototype);\n  mixin(window, GlobalEventHandlersImpl.prototype);\n\n  this._initGlobalEvents(); ///// INTERFACES FROM THE DOM\n  // TODO: consider a mode of some sort where these are not shared between all DOM instances\n  // It'd be very memory-expensive in most cases, though.\n\n\n  for (var name in dom) {\n    Object.defineProperty(window, name, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: dom[name]\n    });\n  } ///// PRIVATE DATA PROPERTIES\n  // vm initialization is deferred until script processing is activated\n\n\n  this._globalProxy = this;\n  Object.defineProperty(idlUtils.implForWrapper(this), idlUtils.wrapperSymbol, {\n    get: function get() {\n      return _this._globalProxy;\n    }\n  });\n  var timers = Object.create(null);\n  var animationFrameCallbacks = Object.create(null); // List options explicitly to be clear which are passed through\n\n  this._document = Document.create([], {\n    options: {\n      parsingMode: options.parsingMode,\n      contentType: options.contentType,\n      encoding: options.encoding,\n      cookieJar: options.cookieJar,\n      url: options.url,\n      lastModified: options.lastModified,\n      referrer: options.referrer,\n      cookie: options.cookie,\n      deferClose: options.deferClose,\n      resourceLoader: options.resourceLoader,\n      concurrentNodeIterators: options.concurrentNodeIterators,\n      pool: options.pool,\n      agent: options.agent,\n      agentClass: options.agentClass,\n      agentOptions: options.agentOptions,\n      strictSSL: options.strictSSL,\n      proxy: options.proxy,\n      parseOptions: options.parseOptions,\n      defaultView: this._globalProxy,\n      global: this\n    }\n  }); // https://html.spec.whatwg.org/#session-history\n\n  this._sessionHistory = new SessionHistory({\n    document: idlUtils.implForWrapper(this._document),\n    url: idlUtils.implForWrapper(this._document)._URL,\n    stateObject: null\n  }, this); // TODO NEWAPI can remove this\n\n  if (options.virtualConsole) {\n    if (options.virtualConsole instanceof VirtualConsole) {\n      this._virtualConsole = options.virtualConsole;\n    } else {\n      throw new TypeError(\"options.virtualConsole must be a VirtualConsole (from createVirtualConsole)\");\n    }\n  } else {\n    this._virtualConsole = new VirtualConsole();\n  }\n\n  this._runScripts = options.runScripts;\n\n  if (this._runScripts === \"outside-only\" || this._runScripts === \"dangerously\") {\n    contextifyWindow(this);\n  } // Set up the window as if it's a top level window.\n  // If it's not, then references will be corrected by frame/iframe code.\n\n\n  this._parent = this._top = this._globalProxy;\n  this._frameElement = null; // This implements window.frames.length, since window.frames returns a\n  // self reference to the window object.  This value is incremented in the\n  // HTMLFrameElement implementation.\n\n  this._length = 0;\n  this._pretendToBeVisual = options.pretendToBeVisual;\n  this._storageQuota = options.storageQuota; // Some properties (such as localStorage and sessionStorage) share data\n  // between windows in the same origin. This object is intended\n  // to contain such data.\n\n  if (options.commonForOrigin && options.commonForOrigin[this._document.origin]) {\n    this._commonForOrigin = options.commonForOrigin;\n  } else {\n    this._commonForOrigin = _defineProperty({}, this._document.origin, {\n      localStorageArea: new Map(),\n      sessionStorageArea: new Map(),\n      windowsInSameOrigin: [this]\n    });\n  }\n\n  this._currentOriginData = this._commonForOrigin[this._document.origin]; ///// WEB STORAGE\n\n  this._localStorage = Storage.create([], {\n    associatedWindow: this,\n    storageArea: this._currentOriginData.localStorageArea,\n    type: \"localStorage\",\n    url: this._document.documentURI,\n    storageQuota: this._storageQuota\n  });\n  this._sessionStorage = Storage.create([], {\n    associatedWindow: this,\n    storageArea: this._currentOriginData.sessionStorageArea,\n    type: \"sessionStorage\",\n    url: this._document.documentURI,\n    storageQuota: this._storageQuota\n  }); ///// GETTERS\n\n  var locationbar = BarProp.create();\n  var menubar = BarProp.create();\n  var personalbar = BarProp.create();\n  var scrollbars = BarProp.create();\n  var statusbar = BarProp.create();\n  var toolbar = BarProp.create();\n  var external = External.create();\n  var navigator = Navigator.create([], {\n    userAgent: options.userAgent\n  });\n  var performance = Performance.create([], {\n    rawPerformance: rawPerformance\n  });\n  var screen = Screen.create();\n  define(this, {\n    get length() {\n      return window._length;\n    },\n\n    get window() {\n      return window._globalProxy;\n    },\n\n    get frameElement() {\n      return window._frameElement;\n    },\n\n    get frames() {\n      return window._globalProxy;\n    },\n\n    get self() {\n      return window._globalProxy;\n    },\n\n    get parent() {\n      return window._parent;\n    },\n\n    get top() {\n      return window._top;\n    },\n\n    get document() {\n      return window._document;\n    },\n\n    get external() {\n      return external;\n    },\n\n    get location() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);\n    },\n\n    get history() {\n      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);\n    },\n\n    get navigator() {\n      return navigator;\n    },\n\n    get locationbar() {\n      return locationbar;\n    },\n\n    get menubar() {\n      return menubar;\n    },\n\n    get personalbar() {\n      return personalbar;\n    },\n\n    get scrollbars() {\n      return scrollbars;\n    },\n\n    get statusbar() {\n      return statusbar;\n    },\n\n    get toolbar() {\n      return toolbar;\n    },\n\n    get performance() {\n      return performance;\n    },\n\n    get screen() {\n      return screen;\n    },\n\n    get localStorage() {\n      if (this._document.origin === \"null\") {\n        throw new DOMException(\"localStorage is not available for opaque origins\", \"SecurityError\");\n      }\n\n      return this._localStorage;\n    },\n\n    get sessionStorage() {\n      if (this._document.origin === \"null\") {\n        throw new DOMException(\"sessionStorage is not available for opaque origins\", \"SecurityError\");\n      }\n\n      return this._sessionStorage;\n    }\n\n  });\n  namedPropertiesWindow.initializeWindow(this, this._globalProxy); ///// METHODS for [ImplicitThis] hack\n  // See https://lists.w3.org/Archives/Public/public-script-coord/2015JanMar/0109.html\n\n  this.addEventListener = this.addEventListener.bind(this);\n  this.removeEventListener = this.removeEventListener.bind(this);\n  this.dispatchEvent = this.dispatchEvent.bind(this); ///// METHODS\n\n  var latestTimerId = 0;\n  var latestAnimationFrameCallbackId = 0;\n\n  this.setTimeout = function (fn, ms) {\n    var args = [];\n\n    for (var i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n\n    return startTimer(window, setTimeout, clearTimeout, ++latestTimerId, fn, ms, timers, args);\n  };\n\n  this.setInterval = function (fn, ms) {\n    var args = [];\n\n    for (var i = 2; i < arguments.length; ++i) {\n      args[i - 2] = arguments[i];\n    }\n\n    return startTimer(window, setInterval, clearInterval, ++latestTimerId, fn, ms, timers, args);\n  };\n\n  this.clearInterval = stopTimer.bind(this, timers);\n  this.clearTimeout = stopTimer.bind(this, timers);\n\n  if (this._pretendToBeVisual) {\n    this.requestAnimationFrame = function (fn) {\n      var timestamp = rawPerformance.now() - windowInitialized;\n      var fps = 1000 / 60;\n      return startTimer(window, setTimeout, clearTimeout, ++latestAnimationFrameCallbackId, fn, fps, animationFrameCallbacks, [timestamp]);\n    };\n\n    this.cancelAnimationFrame = stopTimer.bind(this, animationFrameCallbacks);\n  }\n\n  this.__stopAllTimers = function () {\n    stopAllTimers(timers);\n    stopAllTimers(animationFrameCallbacks);\n    latestTimerId = 0;\n    latestAnimationFrameCallbackId = 0;\n    timers = Object.create(null);\n    animationFrameCallbacks = Object.create(null);\n  };\n\n  function Option(text, value, defaultSelected, selected) {\n    if (text === undefined) {\n      text = \"\";\n    }\n\n    text = webIDLConversions.DOMString(text);\n\n    if (value !== undefined) {\n      value = webIDLConversions.DOMString(value);\n    }\n\n    defaultSelected = webIDLConversions.boolean(defaultSelected);\n    selected = webIDLConversions.boolean(selected);\n\n    var option = window._document.createElement(\"option\");\n\n    var impl = idlUtils.implForWrapper(option);\n\n    if (text !== \"\") {\n      impl.text = text;\n    }\n\n    if (value !== undefined) {\n      impl.setAttribute(\"value\", value);\n    }\n\n    if (defaultSelected) {\n      impl.setAttribute(\"selected\", \"\");\n    }\n\n    impl._selectedness = selected;\n    return option;\n  }\n\n  Object.defineProperty(Option, \"prototype\", {\n    value: this.HTMLOptionElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Option\", {\n    value: Option,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Image() {\n    var img = window._document.createElement(\"img\");\n\n    var impl = idlUtils.implForWrapper(img);\n\n    if (arguments.length > 0) {\n      impl.setAttribute(\"width\", String(arguments[0]));\n    }\n\n    if (arguments.length > 1) {\n      impl.setAttribute(\"height\", String(arguments[1]));\n    }\n\n    return img;\n  }\n\n  Object.defineProperty(Image, \"prototype\", {\n    value: this.HTMLImageElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Image\", {\n    value: Image,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function Audio(src) {\n    var audio = window._document.createElement(\"audio\");\n\n    var impl = idlUtils.implForWrapper(audio);\n    impl.setAttribute(\"preload\", \"auto\");\n\n    if (src !== undefined) {\n      impl.setAttribute(\"src\", String(src));\n    }\n\n    return audio;\n  }\n\n  Object.defineProperty(Audio, \"prototype\", {\n    value: this.HTMLAudioElement.prototype,\n    configurable: false,\n    enumerable: false,\n    writable: false\n  });\n  Object.defineProperty(window, \"Audio\", {\n    value: Audio,\n    configurable: true,\n    enumerable: false,\n    writable: true\n  });\n\n  function wrapConsoleMethod(method) {\n    return function () {\n      var _window$_virtualConso;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_window$_virtualConso = window._virtualConsole).emit.apply(_window$_virtualConso, [method].concat(args));\n    };\n  }\n\n  this.postMessage = postMessage;\n\n  this.atob = function (str) {\n    var result = atob(str);\n\n    if (result === null) {\n      throw new DOMException(\"The string to be decoded contains invalid characters.\", \"InvalidCharacterError\");\n    }\n\n    return result;\n  };\n\n  this.btoa = function (str) {\n    var result = btoa(str);\n\n    if (result === null) {\n      throw new DOMException(\"The string to be encoded contains invalid characters.\", \"InvalidCharacterError\");\n    }\n\n    return result;\n  };\n\n  this.FileReader = createFileReader({\n    window: this\n  }).interface;\n  this.WebSocket = createWebSocket({\n    window: this\n  }).interface;\n  var AbortSignalWrapper = createAbortSignal({\n    window: this\n  });\n  this.AbortSignal = AbortSignalWrapper.interface;\n  this.AbortController = createAbortController({\n    AbortSignal: AbortSignalWrapper\n  }).interface;\n  this.XMLHttpRequest = createXMLHttpRequest(this); // TODO: necessary for Blob and FileReader due to different-globals weirdness; investigate how to avoid this.\n\n  this.ArrayBuffer = ArrayBuffer;\n  this.Int8Array = Int8Array;\n  this.Uint8Array = Uint8Array;\n  this.Uint8ClampedArray = Uint8ClampedArray;\n  this.Int16Array = Int16Array;\n  this.Uint16Array = Uint16Array;\n  this.Int32Array = Int32Array;\n  this.Uint32Array = Uint32Array;\n  this.Float32Array = Float32Array;\n  this.Float64Array = Float64Array;\n\n  this.stop = function () {\n    var manager = idlUtils.implForWrapper(this._document)._requestManager;\n\n    if (manager) {\n      manager.close();\n    }\n  };\n\n  this.close = function () {\n    // Recursively close child frame windows, then ourselves.\n    var currentWindow = this;\n\n    (function windowCleaner(windowToClean) {\n      for (var i = 0; i < windowToClean.length; i++) {\n        windowCleaner(windowToClean[i]);\n      } // We\"re already in our own window.close().\n\n\n      if (windowToClean !== currentWindow) {\n        windowToClean.close();\n      }\n    })(this); // Clear out all listeners. Any in-flight or upcoming events should not get delivered.\n\n\n    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);\n\n    if (this._document) {\n      if (this._document.body) {\n        this._document.body.innerHTML = \"\";\n      }\n\n      if (this._document.close) {\n        // It's especially important to clear out the listeners here because document.close() causes a \"load\" event to\n        // fire.\n        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);\n\n        this._document.close();\n      }\n\n      var doc = idlUtils.implForWrapper(this._document);\n\n      if (doc._requestManager) {\n        doc._requestManager.close();\n      }\n\n      delete this._document;\n    }\n\n    this.__stopAllTimers();\n\n    WebSocketImpl.cleanUpWindow(this);\n  };\n\n  this.getComputedStyle = function (node) {\n    var nodeImpl = idlUtils.implForWrapper(node);\n    var s = node.style;\n    var cs = new CSSStyleDeclaration();\n    var forEach = Array.prototype.forEach;\n\n    function setPropertiesFromRule(rule) {\n      if (!rule.selectorText) {\n        return;\n      }\n\n      var selectors = rule.selectorText.split(cssSelectorSplitRE);\n      var matched = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = selectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var selectorText = _step.value;\n\n          if (selectorText !== \"\" && selectorText !== \",\" && !matched && matchesDontThrow(nodeImpl, selectorText)) {\n            matched = true;\n            forEach.call(rule.style, function (property) {\n              cs.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    function readStylesFromStyleSheet(sheet) {\n      forEach.call(sheet.cssRules, function (rule) {\n        if (rule.media) {\n          if (Array.prototype.indexOf.call(rule.media, \"screen\") !== -1) {\n            forEach.call(rule.cssRules, setPropertiesFromRule);\n          }\n        } else {\n          setPropertiesFromRule(rule);\n        }\n      });\n    }\n\n    readStylesFromStyleSheet(defaultStyleSheet);\n    forEach.call(node.ownerDocument.styleSheets, readStylesFromStyleSheet);\n    forEach.call(s, function (property) {\n      cs.setProperty(property, s.getPropertyValue(property), s.getPropertyPriority(property));\n    });\n    return cs;\n  }; // The captureEvents() and releaseEvents() methods must do nothing\n\n\n  this.captureEvents = function () {};\n\n  this.releaseEvents = function () {}; ///// PUBLIC DATA PROPERTIES (TODO: should be getters)\n\n\n  this.console = {\n    assert: wrapConsoleMethod(\"assert\"),\n    clear: wrapConsoleMethod(\"clear\"),\n    count: wrapConsoleMethod(\"count\"),\n    debug: wrapConsoleMethod(\"debug\"),\n    error: wrapConsoleMethod(\"error\"),\n    group: wrapConsoleMethod(\"group\"),\n    groupCollapsed: wrapConsoleMethod(\"groupCollapsed\"),\n    groupEnd: wrapConsoleMethod(\"groupEnd\"),\n    info: wrapConsoleMethod(\"info\"),\n    log: wrapConsoleMethod(\"log\"),\n    table: wrapConsoleMethod(\"table\"),\n    time: wrapConsoleMethod(\"time\"),\n    timeEnd: wrapConsoleMethod(\"timeEnd\"),\n    trace: wrapConsoleMethod(\"trace\"),\n    warn: wrapConsoleMethod(\"warn\")\n  };\n\n  function notImplementedMethod(name) {\n    return function () {\n      notImplemented(name, window);\n    };\n  }\n\n  define(this, {\n    name: \"nodejs\",\n    // Node v6 has issues (presumably in the vm module)\n    // which this property exposes through an XHR test\n    // status: \"\",\n    devicePixelRatio: 1,\n    innerWidth: 1024,\n    innerHeight: 768,\n    outerWidth: 1024,\n    outerHeight: 768,\n    pageXOffset: 0,\n    pageYOffset: 0,\n    screenX: 0,\n    screenY: 0,\n    scrollX: 0,\n    scrollY: 0,\n    // Not in spec, but likely to be added eventually:\n    // https://github.com/w3c/csswg-drafts/issues/1091\n    screenLeft: 0,\n    screenTop: 0,\n    alert: notImplementedMethod(\"window.alert\"),\n    blur: notImplementedMethod(\"window.blur\"),\n    confirm: notImplementedMethod(\"window.confirm\"),\n    focus: notImplementedMethod(\"window.focus\"),\n    moveBy: notImplementedMethod(\"window.moveBy\"),\n    moveTo: notImplementedMethod(\"window.moveTo\"),\n    open: notImplementedMethod(\"window.open\"),\n    print: notImplementedMethod(\"window.print\"),\n    prompt: notImplementedMethod(\"window.prompt\"),\n    resizeBy: notImplementedMethod(\"window.resizeBy\"),\n    resizeTo: notImplementedMethod(\"window.resizeTo\"),\n    scroll: notImplementedMethod(\"window.scroll\"),\n    scrollBy: notImplementedMethod(\"window.scrollBy\"),\n    scrollTo: notImplementedMethod(\"window.scrollTo\")\n  }); ///// INITIALIZATION\n\n  process.nextTick(function () {\n    if (!window.document) {\n      return; // window might've been closed already\n    }\n\n    if (window.document.readyState === \"complete\") {\n      var ev = window.document.createEvent(\"HTMLEvents\");\n      ev.initEvent(\"load\", false, false);\n      window.dispatchEvent(ev);\n    } else {\n      window.document.addEventListener(\"load\", function () {\n        var ev = window.document.createEvent(\"HTMLEvents\");\n        ev.initEvent(\"load\", false, false);\n        window.dispatchEvent(ev);\n      });\n    }\n  });\n}\n\nObject.setPrototypeOf(Window, EventTarget.interface);\nObject.setPrototypeOf(Window.prototype, EventTarget.interface.prototype);\nObject.defineProperty(Window.prototype, Symbol.toStringTag, {\n  value: \"Window\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nfunction startTimer(window, startFn, stopFn, timerId, callback, ms, timerStorage, args) {\n  if (!window || !window._document) {\n    return undefined;\n  }\n\n  if (typeof callback !== \"function\") {\n    var code = String(callback);\n    callback = window._globalProxy.eval.bind(window, code + \"\\n//# sourceURL=\".concat(window.location.href));\n  }\n\n  var oldCallback = callback;\n\n  callback = function callback() {\n    try {\n      oldCallback.apply(window._globalProxy, args);\n    } catch (e) {\n      reportException(window, e, window.location.href);\n    }\n  };\n\n  var res = startFn(callback, ms);\n  timerStorage[timerId] = [res, stopFn];\n  return timerId;\n}\n\nfunction stopTimer(timerStorage, id) {\n  var timer = timerStorage[id];\n\n  if (timer) {\n    // Need to .call() with undefined to ensure the thisArg is not timer itself\n    timer[1].call(undefined, timer[0]);\n    delete timerStorage[id];\n  }\n}\n\nfunction stopAllTimers(timers) {\n  Object.keys(timers).forEach(function (key) {\n    var timer = timers[key]; // Need to .call() with undefined to ensure the thisArg is not timer itself\n\n    timer[1].call(undefined, timer[0]);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}