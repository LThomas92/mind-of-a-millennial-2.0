{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _DEFAULT_STYLE_MAP, _ENTITY_ATTR_MAP, _DATA_TO_ATTR;\n\nexports.default = stateToHTML;\n\nvar _combineOrderedStyles3 = require('./helpers/combineOrderedStyles');\n\nvar _combineOrderedStyles4 = _interopRequireDefault(_combineOrderedStyles3);\n\nvar _normalizeAttributes = require('./helpers/normalizeAttributes');\n\nvar _normalizeAttributes2 = _interopRequireDefault(_normalizeAttributes);\n\nvar _styleToCSS = require('./helpers/styleToCSS');\n\nvar _styleToCSS2 = _interopRequireDefault(_styleToCSS);\n\nvar _draftJsUtils = require('draft-js-utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar BOLD = _draftJsUtils.INLINE_STYLE.BOLD,\n    CODE = _draftJsUtils.INLINE_STYLE.CODE,\n    ITALIC = _draftJsUtils.INLINE_STYLE.ITALIC,\n    STRIKETHROUGH = _draftJsUtils.INLINE_STYLE.STRIKETHROUGH,\n    UNDERLINE = _draftJsUtils.INLINE_STYLE.UNDERLINE;\nvar INDENT = '  ';\nvar BREAK = '<br>';\nvar DATA_ATTRIBUTE = /^data-([a-z0-9-]+)$/;\nvar DEFAULT_STYLE_MAP = (_DEFAULT_STYLE_MAP = {}, _defineProperty(_DEFAULT_STYLE_MAP, BOLD, {\n  element: 'strong'\n}), _defineProperty(_DEFAULT_STYLE_MAP, CODE, {\n  element: 'code'\n}), _defineProperty(_DEFAULT_STYLE_MAP, ITALIC, {\n  element: 'em'\n}), _defineProperty(_DEFAULT_STYLE_MAP, STRIKETHROUGH, {\n  element: 'del'\n}), _defineProperty(_DEFAULT_STYLE_MAP, UNDERLINE, {\n  element: 'u'\n}), _DEFAULT_STYLE_MAP); // Order: inner-most style to outer-most.\n// Examle: <em><strong>foo</strong></em>\n\nvar DEFAULT_STYLE_ORDER = [BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE]; // Map entity data to element attributes.\n\nvar ENTITY_ATTR_MAP = (_ENTITY_ATTR_MAP = {}, _defineProperty(_ENTITY_ATTR_MAP, _draftJsUtils.ENTITY_TYPE.LINK, {\n  url: 'href',\n  href: 'href',\n  rel: 'rel',\n  target: 'target',\n  title: 'title',\n  className: 'class'\n}), _defineProperty(_ENTITY_ATTR_MAP, _draftJsUtils.ENTITY_TYPE.IMAGE, {\n  src: 'src',\n  height: 'height',\n  width: 'width',\n  alt: 'alt',\n  className: 'class'\n}), _ENTITY_ATTR_MAP); // Map entity data to element attributes.\n\nvar DATA_TO_ATTR = (_DATA_TO_ATTR = {}, _defineProperty(_DATA_TO_ATTR, _draftJsUtils.ENTITY_TYPE.LINK, function (entityType, entity) {\n  var attrMap = ENTITY_ATTR_MAP.hasOwnProperty(entityType) ? ENTITY_ATTR_MAP[entityType] : {};\n  var data = entity.getData();\n  var attrs = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Object.keys(data)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var dataKey = _step.value;\n      var dataValue = data[dataKey];\n\n      if (attrMap.hasOwnProperty(dataKey)) {\n        var attrKey = attrMap[dataKey];\n        attrs[attrKey] = dataValue;\n      } else if (DATA_ATTRIBUTE.test(dataKey)) {\n        attrs[dataKey] = dataValue;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return attrs;\n}), _defineProperty(_DATA_TO_ATTR, _draftJsUtils.ENTITY_TYPE.IMAGE, function (entityType, entity) {\n  var attrMap = ENTITY_ATTR_MAP.hasOwnProperty(entityType) ? ENTITY_ATTR_MAP[entityType] : {};\n  var data = entity.getData();\n  var attrs = {};\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = Object.keys(data)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var dataKey = _step2.value;\n      var dataValue = data[dataKey];\n\n      if (attrMap.hasOwnProperty(dataKey)) {\n        var attrKey = attrMap[dataKey];\n        attrs[attrKey] = dataValue;\n      } else if (DATA_ATTRIBUTE.test(dataKey)) {\n        attrs[dataKey] = dataValue;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return attrs;\n}), _DATA_TO_ATTR); // The reason this returns an array is because a single block might get wrapped\n// in two tags.\n\nfunction getTags(blockType, defaultBlockTag) {\n  switch (blockType) {\n    case _draftJsUtils.BLOCK_TYPE.HEADER_ONE:\n      return ['h1'];\n\n    case _draftJsUtils.BLOCK_TYPE.HEADER_TWO:\n      return ['h2'];\n\n    case _draftJsUtils.BLOCK_TYPE.HEADER_THREE:\n      return ['h3'];\n\n    case _draftJsUtils.BLOCK_TYPE.HEADER_FOUR:\n      return ['h4'];\n\n    case _draftJsUtils.BLOCK_TYPE.HEADER_FIVE:\n      return ['h5'];\n\n    case _draftJsUtils.BLOCK_TYPE.HEADER_SIX:\n      return ['h6'];\n\n    case _draftJsUtils.BLOCK_TYPE.UNORDERED_LIST_ITEM:\n    case _draftJsUtils.BLOCK_TYPE.ORDERED_LIST_ITEM:\n      return ['li'];\n\n    case _draftJsUtils.BLOCK_TYPE.BLOCKQUOTE:\n      return ['blockquote'];\n\n    case _draftJsUtils.BLOCK_TYPE.CODE:\n      return ['pre', 'code'];\n\n    case _draftJsUtils.BLOCK_TYPE.ATOMIC:\n      return ['figure'];\n\n    default:\n      if (defaultBlockTag === null) {\n        return [];\n      }\n\n      return [defaultBlockTag || 'p'];\n  }\n}\n\nfunction getWrapperTag(blockType) {\n  switch (blockType) {\n    case _draftJsUtils.BLOCK_TYPE.UNORDERED_LIST_ITEM:\n      return 'ul';\n\n    case _draftJsUtils.BLOCK_TYPE.ORDERED_LIST_ITEM:\n      return 'ol';\n\n    default:\n      return null;\n  }\n}\n\nvar MarkupGenerator = function () {\n  // These are related to user-defined options.\n  function MarkupGenerator(contentState, options) {\n    _classCallCheck(this, MarkupGenerator);\n\n    if (options == null) {\n      options = {};\n    }\n\n    this.contentState = contentState;\n    this.options = options;\n\n    var _combineOrderedStyles = (0, _combineOrderedStyles4.default)(options.inlineStyles, [DEFAULT_STYLE_MAP, DEFAULT_STYLE_ORDER]),\n        _combineOrderedStyles2 = _slicedToArray(_combineOrderedStyles, 2),\n        inlineStyles = _combineOrderedStyles2[0],\n        styleOrder = _combineOrderedStyles2[1];\n\n    this.inlineStyles = inlineStyles;\n    this.inlineStyleFn = options.inlineStyleFn;\n    this.styleOrder = styleOrder;\n  } // These are related to state.\n\n\n  _createClass(MarkupGenerator, [{\n    key: 'generate',\n    value: function generate() {\n      this.output = [];\n      this.blocks = this.contentState.getBlocksAsArray();\n      this.totalBlocks = this.blocks.length;\n      this.currentBlock = 0;\n      this.indentLevel = 0;\n      this.wrapperTag = null;\n\n      while (this.currentBlock < this.totalBlocks) {\n        this.processBlock();\n      }\n\n      this.closeWrapperTag();\n      return this.output.join('').trim();\n    }\n  }, {\n    key: 'processBlock',\n    value: function processBlock() {\n      var _options = this.options,\n          blockRenderers = _options.blockRenderers,\n          defaultBlockTag = _options.defaultBlockTag;\n      var block = this.blocks[this.currentBlock];\n      var blockType = block.getType();\n      var newWrapperTag = getWrapperTag(blockType);\n\n      if (this.wrapperTag !== newWrapperTag) {\n        if (this.wrapperTag) {\n          this.closeWrapperTag();\n        }\n\n        if (newWrapperTag) {\n          this.openWrapperTag(newWrapperTag);\n        }\n      }\n\n      this.indent(); // Allow blocks to be rendered using a custom renderer.\n\n      var customRenderer = blockRenderers != null && blockRenderers.hasOwnProperty(blockType) ? blockRenderers[blockType] : null;\n      var customRendererOutput = customRenderer ? customRenderer(block) : null; // Renderer can return null, which will cause processing to continue as normal.\n\n      if (customRendererOutput != null) {\n        this.output.push(customRendererOutput);\n        this.output.push('\\n');\n        this.currentBlock += 1;\n        return;\n      }\n\n      this.writeStartTag(block, defaultBlockTag);\n      this.output.push(this.renderBlockContent(block)); // Look ahead and see if we will nest list.\n\n      var nextBlock = this.getNextBlock();\n\n      if (canHaveDepth(blockType) && nextBlock && nextBlock.getDepth() === block.getDepth() + 1) {\n        this.output.push('\\n'); // This is a litle hacky: temporarily stash our current wrapperTag and\n        // render child list(s).\n\n        var thisWrapperTag = this.wrapperTag;\n        this.wrapperTag = null;\n        this.indentLevel += 1;\n        this.currentBlock += 1;\n        this.processBlocksAtDepth(nextBlock.getDepth());\n        this.wrapperTag = thisWrapperTag;\n        this.indentLevel -= 1;\n        this.indent();\n      } else {\n        this.currentBlock += 1;\n      }\n\n      this.writeEndTag(block, defaultBlockTag);\n    }\n  }, {\n    key: 'processBlocksAtDepth',\n    value: function processBlocksAtDepth(depth) {\n      var block = this.blocks[this.currentBlock];\n\n      while (block && block.getDepth() === depth) {\n        this.processBlock();\n        block = this.blocks[this.currentBlock];\n      }\n\n      this.closeWrapperTag();\n    }\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock() {\n      return this.blocks[this.currentBlock + 1];\n    }\n  }, {\n    key: 'writeStartTag',\n    value: function writeStartTag(block, defaultBlockTag) {\n      var tags = getTags(block.getType(), defaultBlockTag);\n      var attrString = void 0;\n\n      if (this.options.blockStyleFn) {\n        var _ref = this.options.blockStyleFn(block) || {},\n            _attributes = _ref.attributes,\n            _style = _ref.style; // Normalize `className` -> `class`, etc.\n\n\n        _attributes = (0, _normalizeAttributes2.default)(_attributes);\n\n        if (_style != null) {\n          var styleAttr = (0, _styleToCSS2.default)(_style);\n          _attributes = _attributes == null ? {\n            style: styleAttr\n          } : _extends({}, _attributes, {\n            style: styleAttr\n          });\n        }\n\n        attrString = stringifyAttrs(_attributes);\n      } else {\n        attrString = '';\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tags[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var tag = _step3.value;\n          this.output.push('<' + tag + attrString + '>');\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'writeEndTag',\n    value: function writeEndTag(block, defaultBlockTag) {\n      var tags = getTags(block.getType(), defaultBlockTag);\n\n      if (tags.length === 1) {\n        this.output.push('</' + tags[0] + '>\\n');\n      } else {\n        var output = [];\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = tags[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var tag = _step4.value;\n            output.unshift('</' + tag + '>');\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        this.output.push(output.join('') + '\\n');\n      }\n    }\n  }, {\n    key: 'openWrapperTag',\n    value: function openWrapperTag(wrapperTag) {\n      this.wrapperTag = wrapperTag;\n      this.indent();\n      this.output.push('<' + wrapperTag + '>\\n');\n      this.indentLevel += 1;\n    }\n  }, {\n    key: 'closeWrapperTag',\n    value: function closeWrapperTag() {\n      var wrapperTag = this.wrapperTag;\n\n      if (wrapperTag) {\n        this.indentLevel -= 1;\n        this.indent();\n        this.output.push('</' + wrapperTag + '>\\n');\n        this.wrapperTag = null;\n      }\n    }\n  }, {\n    key: 'indent',\n    value: function indent() {\n      this.output.push(INDENT.repeat(this.indentLevel));\n    }\n  }, {\n    key: 'withCustomInlineStyles',\n    value: function withCustomInlineStyles(content, styleSet) {\n      if (!this.inlineStyleFn) {\n        return content;\n      }\n\n      var renderConfig = this.inlineStyleFn(styleSet);\n\n      if (!renderConfig) {\n        return content;\n      }\n\n      var _renderConfig$element = renderConfig.element,\n          element = _renderConfig$element === undefined ? 'span' : _renderConfig$element,\n          attributes = renderConfig.attributes,\n          style = renderConfig.style;\n      var attrString = stringifyAttrs(_extends({}, attributes, {\n        style: style && (0, _styleToCSS2.default)(style)\n      }));\n      return '<' + element + attrString + '>' + content + '</' + element + '>';\n    }\n  }, {\n    key: 'renderBlockContent',\n    value: function renderBlockContent(block) {\n      var _this = this;\n\n      var blockType = block.getType();\n      var text = block.getText();\n\n      if (text === '') {\n        // Prevent element collapse if completely empty.\n        return BREAK;\n      }\n\n      text = this.preserveWhitespace(text);\n      var charMetaList = block.getCharacterList();\n      var entityPieces = (0, _draftJsUtils.getEntityRanges)(text, charMetaList);\n      return entityPieces.map(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            entityKey = _ref3[0],\n            stylePieces = _ref3[1];\n\n        var content = stylePieces.map(function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              text = _ref5[0],\n              styleSet = _ref5[1];\n\n          var content = encodeContent(text);\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = _this.styleOrder[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var _styleName = _step5.value; // If our block type is CODE then don't wrap inline code elements.\n\n              if (_styleName === CODE && blockType === _draftJsUtils.BLOCK_TYPE.CODE) {\n                continue;\n              }\n\n              if (styleSet.has(_styleName)) {\n                var _inlineStyles$_styleN = _this.inlineStyles[_styleName],\n                    _element = _inlineStyles$_styleN.element,\n                    _attributes2 = _inlineStyles$_styleN.attributes,\n                    _style2 = _inlineStyles$_styleN.style;\n\n                if (_element == null) {\n                  _element = 'span';\n                } // Normalize `className` -> `class`, etc.\n\n\n                _attributes2 = (0, _normalizeAttributes2.default)(_attributes2);\n\n                if (_style2 != null) {\n                  var styleAttr = (0, _styleToCSS2.default)(_style2);\n                  _attributes2 = _attributes2 == null ? {\n                    style: styleAttr\n                  } : _extends({}, _attributes2, {\n                    style: styleAttr\n                  });\n                }\n\n                var attrString = stringifyAttrs(_attributes2);\n                content = '<' + _element + attrString + '>' + content + '</' + _element + '>';\n              }\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          return _this.withCustomInlineStyles(content, styleSet);\n        }).join('');\n        var entity = entityKey ? _this.contentState.getEntity(entityKey) : null; // Note: The `toUpperCase` below is for compatability with some libraries that use lower-case for image blocks.\n\n        var entityType = entity == null ? null : entity.getType().toUpperCase();\n        var entityStyle = void 0;\n\n        if (entity != null && _this.options.entityStyleFn && (entityStyle = _this.options.entityStyleFn(entity))) {\n          var _entityStyle = entityStyle,\n              _element2 = _entityStyle.element,\n              _attributes3 = _entityStyle.attributes,\n              _style3 = _entityStyle.style;\n\n          if (_element2 == null) {\n            _element2 = 'span';\n          } // Normalize `className` -> `class`, etc.\n\n\n          _attributes3 = (0, _normalizeAttributes2.default)(_attributes3);\n\n          if (_style3 != null) {\n            var styleAttr = (0, _styleToCSS2.default)(_style3);\n            _attributes3 = _attributes3 == null ? {\n              style: styleAttr\n            } : _extends({}, _attributes3, {\n              style: styleAttr\n            });\n          }\n\n          var attrString = stringifyAttrs(_attributes3);\n          return '<' + _element2 + attrString + '>' + content + '</' + _element2 + '>';\n        } else if (entityType != null && entityType === _draftJsUtils.ENTITY_TYPE.LINK) {\n          var attrs = DATA_TO_ATTR.hasOwnProperty(entityType) ? DATA_TO_ATTR[entityType](entityType, entity) : null;\n\n          var _attrString = stringifyAttrs(attrs);\n\n          return '<a' + _attrString + '>' + content + '</a>';\n        } else if (entityType != null && entityType === _draftJsUtils.ENTITY_TYPE.IMAGE) {\n          var _attrs = DATA_TO_ATTR.hasOwnProperty(entityType) ? DATA_TO_ATTR[entityType](entityType, entity) : null;\n\n          var _attrString2 = stringifyAttrs(_attrs);\n\n          return '<img' + _attrString2 + '/>';\n        } else {\n          return content;\n        }\n      }).join('');\n    }\n  }, {\n    key: 'preserveWhitespace',\n    value: function preserveWhitespace(text) {\n      var length = text.length; // Prevent leading/trailing/consecutive whitespace collapse.\n\n      var newText = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        if (text[i] === ' ' && (i === 0 || i === length - 1 || text[i - 1] === ' ')) {\n          newText[i] = '\\xA0';\n        } else {\n          newText[i] = text[i];\n        }\n      }\n\n      return newText.join('');\n    }\n  }]);\n\n  return MarkupGenerator;\n}();\n\nfunction stringifyAttrs(attrs) {\n  if (attrs == null) {\n    return '';\n  }\n\n  var parts = [];\n  var _iteratorNormalCompletion6 = true;\n  var _didIteratorError6 = false;\n  var _iteratorError6 = undefined;\n\n  try {\n    for (var _iterator6 = Object.keys(attrs)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n      var name = _step6.value;\n      var value = attrs[name];\n\n      if (value != null) {\n        parts.push(' ' + name + '=\"' + encodeAttr(value + '') + '\"');\n      }\n    }\n  } catch (err) {\n    _didIteratorError6 = true;\n    _iteratorError6 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion6 && _iterator6.return) {\n        _iterator6.return();\n      }\n    } finally {\n      if (_didIteratorError6) {\n        throw _iteratorError6;\n      }\n    }\n  }\n\n  return parts.join('');\n}\n\nfunction canHaveDepth(blockType) {\n  switch (blockType) {\n    case _draftJsUtils.BLOCK_TYPE.UNORDERED_LIST_ITEM:\n    case _draftJsUtils.BLOCK_TYPE.ORDERED_LIST_ITEM:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction encodeContent(text) {\n  return text.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;').split('\\xA0').join('&nbsp;').split('\\n').join(BREAK + '\\n');\n}\n\nfunction encodeAttr(text) {\n  return text.split('&').join('&amp;').split('<').join('&lt;').split('>').join('&gt;').split('\"').join('&quot;');\n}\n\nfunction stateToHTML(content, options) {\n  return new MarkupGenerator(content, options).generate();\n}","map":null,"metadata":{},"sourceType":"script"}