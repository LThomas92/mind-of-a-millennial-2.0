{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar parse5 = require(\"parse5\");\n\nvar sax = require(\"sax\");\n\nvar attributes = require(\"../living/attributes\");\n\nvar DocumentType = require(\"../living/generated/DocumentType\");\n\nvar JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\n\nvar _require = require(\"../living/helpers/namespaces\"),\n    HTML_NS = _require.HTML_NS; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\n\n\nvar OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\n\nvar originalPop = OpenElementStack.prototype.pop;\n\nOpenElementStack.prototype.pop = function () {\n  var before = this.items[this.stackTop];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  originalPop.apply(this, args);\n\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nvar originalPush = OpenElementStack.prototype.push;\n\nOpenElementStack.prototype.push = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  originalPush.apply(this, args);\n  var after = this.items[this.stackTop];\n\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function HTMLToDOM(parsingMode) {\n    _classCallCheck(this, HTMLToDOM);\n\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  _createClass(HTMLToDOM, [{\n    key: \"appendToNode\",\n    value: function appendToNode(html, node) {\n      html = String(html);\n      return this._doParse(html, true, node);\n    }\n  }, {\n    key: \"appendToDocument\",\n    value: function appendToDocument(html, documentImpl) {\n      html = String(html);\n      return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n    }\n  }, {\n    key: \"_doParse\",\n    value: function _doParse() {\n      return this.parser === parse5 ? this._parseWithParse5.apply(this, arguments) : this._parseWithSax.apply(this, arguments);\n    }\n  }, {\n    key: \"_parseWithParse5\",\n    value: function _parseWithParse5(html, isFragment, contextNode) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n      options.treeAdapter = adapter;\n\n      if (isFragment) {\n        var fragment = this.parser.parseFragment(contextNode, html, options);\n\n        if (contextNode._templateContents) {\n          contextNode._templateContents.appendChild(fragment);\n        } else {\n          contextNode.appendChild(fragment);\n        }\n      } else {\n        this.parser.parse(html, options);\n      }\n\n      return contextNode;\n    }\n  }, {\n    key: \"_parseWithSax\",\n    value: function _parseWithSax(html, isFragment, contextNode) {\n      var SaxParser = this.parser.parser;\n      var parser = new SaxParser(\n      /* strict = */\n      true, {\n        xmlns: true,\n        strictEntities: true\n      });\n      parser.noscript = false;\n      parser.looseCase = \"toString\";\n      var openStack = [contextNode];\n\n      parser.ontext = function (text) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"text\",\n          data: text\n        });\n      };\n\n      parser.oncdata = function (cdata) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"cdata\",\n          data: cdata\n        });\n      };\n\n      parser.onopentag = function (arg) {\n        var attrs = Object.keys(arg.attributes).map(function (key) {\n          var rawAttribute = arg.attributes[key];\n          var prefix = rawAttribute.prefix;\n          var localName = rawAttribute.local;\n\n          if (prefix === \"xmlns\" && localName === \"\") {\n            // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n            localName = prefix;\n            prefix = null;\n          }\n\n          if (prefix === \"\") {\n            prefix = null;\n          }\n\n          var namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n          return {\n            name: rawAttribute.name,\n            value: rawAttribute.value,\n            prefix: prefix,\n            localName: localName,\n            namespace: namespace\n          };\n        });\n        var tag = {\n          type: \"tag\",\n          name: arg.local,\n          prefix: arg.prefix,\n          namespace: arg.uri,\n          attributes: attrs\n        };\n\n        if (arg.local === \"script\" && arg.uri === HTML_NS) {\n          openStack.push(tag);\n        } else {\n          var elem = setChildForSax(openStack[openStack.length - 1], tag);\n          openStack.push(elem);\n        }\n      };\n\n      parser.onclosetag = function () {\n        var elem = openStack.pop();\n\n        if (elem.constructor.name === \"Object\") {\n          // we have an empty script tag\n          setChildForSax(openStack[openStack.length - 1], elem);\n        }\n      };\n\n      parser.onscript = function (scriptText) {\n        var tag = openStack.pop();\n        tag.children = [{\n          type: \"text\",\n          data: scriptText\n        }];\n        var elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      };\n\n      parser.oncomment = function (comment) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"comment\",\n          data: comment\n        });\n      };\n\n      parser.onprocessinginstruction = function (pi) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"directive\",\n          name: \"?\" + pi.name,\n          data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n        });\n      };\n\n      parser.ondoctype = function (dt) {\n        setChildForSax(openStack[openStack.length - 1], {\n          type: \"directive\",\n          name: \"!doctype\",\n          data: \"!doctype \" + dt\n        });\n        var entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n        var result;\n\n        while (result = entityMatcher.exec(dt)) {\n          var _result = result,\n              _result2 = _slicedToArray(_result, 3),\n              name = _result2[1],\n              value = _result2[2];\n\n          if (!(name in parser.ENTITIES)) {\n            parser.ENTITIES[name] = value;\n          }\n        }\n      };\n\n      parser.onerror = function (err) {\n        throw err;\n      };\n\n      parser.write(html).close();\n    }\n  }]);\n\n  return HTMLToDOM;\n}();\n\nfunction setChildForSax(parentImpl, node) {\n  var currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n  var newNode;\n  var isTemplateContents = false;\n\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        var data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = node.attributes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var a = _step.value;\n        attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  if (node.children) {\n    for (var c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nvar HTML5_DOCTYPE = /<!doctype html>/i;\nvar PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nvar SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  var publicPieces = PUBLIC_DOCTYPE.exec(html);\n\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  var systemPieces = SYSTEM_DOCTYPE.exec(html);\n\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  } // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n\n\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument: ownerDocument,\n    name: name,\n    publicId: publicId,\n    systemId: systemId\n  });\n}","map":null,"metadata":{},"sourceType":"script"}