{"ast":null,"code":"//! moment.js\n//! version : 2.4.0\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n(function (undefined) {\n  /************************************\n      Constants\n  ************************************/\n  var moment,\n      VERSION = \"2.4.0\",\n      round = Math.round,\n      i,\n      YEAR = 0,\n      MONTH = 1,\n      DATE = 2,\n      HOUR = 3,\n      MINUTE = 4,\n      SECOND = 5,\n      MILLISECOND = 6,\n      // internal storage for language config files\n  languages = {},\n      // check for nodeJS\n  hasModule = typeof module !== 'undefined' && module.exports,\n      // ASP.NET json date format regex\n  aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i,\n      aspNetTimeSpanJsonRegex = /(\\-)?(?:(\\d*)\\.)?(\\d+)\\:(\\d+)(?:\\:(\\d+)\\.?(\\d{3})?)?/,\n      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n  isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,\n      // format tokens\n  formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,\n      localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LT|LL?L?L?|l{1,4})/g,\n      // parsing token regexes\n  parseTokenOneOrTwoDigits = /\\d\\d?/,\n      // 0 - 99\n  parseTokenOneToThreeDigits = /\\d{1,3}/,\n      // 0 - 999\n  parseTokenThreeDigits = /\\d{3}/,\n      // 000 - 999\n  parseTokenFourDigits = /\\d{1,4}/,\n      // 0 - 9999\n  parseTokenSixDigits = /[+\\-]?\\d{1,6}/,\n      // -999,999 - 999,999\n  parseTokenDigits = /\\d+/,\n      // nonzero number of digits\n  parseTokenWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i,\n      // any word (or two) characters or numbers including two/three word month in arabic.\n  parseTokenTimezone = /Z|[\\+\\-]\\d\\d:?\\d\\d/i,\n      // +00:00 -00:00 +0000 -0000 or Z\n  parseTokenT = /T/i,\n      // T (ISO seperator)\n  parseTokenTimestampMs = /[\\+\\-]?\\d+(\\.\\d{1,3})?/,\n      // 123456789 123456789.123\n  // preliminary iso regex\n  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000)\n  isoRegex = /^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?([\\+\\-]\\d\\d:?\\d\\d|Z)?)?$/,\n      isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',\n      isoDates = ['YYYY-MM-DD', 'GGGG-[W]WW', 'GGGG-[W]WW-E', 'YYYY-DDD'],\n      // iso time formats and regexes\n  isoTimes = [['HH:mm:ss.SSSS', /(T| )\\d\\d:\\d\\d:\\d\\d\\.\\d{1,3}/], ['HH:mm:ss', /(T| )\\d\\d:\\d\\d:\\d\\d/], ['HH:mm', /(T| )\\d\\d:\\d\\d/], ['HH', /(T| )\\d\\d/]],\n      // timezone chunker \"+10:00\" > [\"10\", \"00\"] or \"-1530\" > [\"-15\", \"30\"]\n  parseTimezoneChunker = /([\\+\\-]|\\d\\d)/gi,\n      // getter and setter names\n  proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),\n      unitMillisecondFactors = {\n    'Milliseconds': 1,\n    'Seconds': 1e3,\n    'Minutes': 6e4,\n    'Hours': 36e5,\n    'Days': 864e5,\n    'Months': 2592e6,\n    'Years': 31536e6\n  },\n      unitAliases = {\n    ms: 'millisecond',\n    s: 'second',\n    m: 'minute',\n    h: 'hour',\n    d: 'day',\n    D: 'date',\n    w: 'week',\n    W: 'isoWeek',\n    M: 'month',\n    y: 'year',\n    DDD: 'dayOfYear',\n    e: 'weekday',\n    E: 'isoWeekday',\n    gg: 'weekYear',\n    GG: 'isoWeekYear'\n  },\n      camelFunctions = {\n    dayofyear: 'dayOfYear',\n    isoweekday: 'isoWeekday',\n    isoweek: 'isoWeek',\n    weekyear: 'weekYear',\n    isoweekyear: 'isoWeekYear'\n  },\n      // format function strings\n  formatFunctions = {},\n      // tokens to ordinalize and pad\n  ordinalizeTokens = 'DDD w W M D d'.split(' '),\n      paddedTokens = 'M D H h m s w W'.split(' '),\n      formatTokenFunctions = {\n    M: function M() {\n      return this.month() + 1;\n    },\n    MMM: function MMM(format) {\n      return this.lang().monthsShort(this, format);\n    },\n    MMMM: function MMMM(format) {\n      return this.lang().months(this, format);\n    },\n    D: function D() {\n      return this.date();\n    },\n    DDD: function DDD() {\n      return this.dayOfYear();\n    },\n    d: function d() {\n      return this.day();\n    },\n    dd: function dd(format) {\n      return this.lang().weekdaysMin(this, format);\n    },\n    ddd: function ddd(format) {\n      return this.lang().weekdaysShort(this, format);\n    },\n    dddd: function dddd(format) {\n      return this.lang().weekdays(this, format);\n    },\n    w: function w() {\n      return this.week();\n    },\n    W: function W() {\n      return this.isoWeek();\n    },\n    YY: function YY() {\n      return leftZeroFill(this.year() % 100, 2);\n    },\n    YYYY: function YYYY() {\n      return leftZeroFill(this.year(), 4);\n    },\n    YYYYY: function YYYYY() {\n      return leftZeroFill(this.year(), 5);\n    },\n    gg: function gg() {\n      return leftZeroFill(this.weekYear() % 100, 2);\n    },\n    gggg: function gggg() {\n      return this.weekYear();\n    },\n    ggggg: function ggggg() {\n      return leftZeroFill(this.weekYear(), 5);\n    },\n    GG: function GG() {\n      return leftZeroFill(this.isoWeekYear() % 100, 2);\n    },\n    GGGG: function GGGG() {\n      return this.isoWeekYear();\n    },\n    GGGGG: function GGGGG() {\n      return leftZeroFill(this.isoWeekYear(), 5);\n    },\n    e: function e() {\n      return this.weekday();\n    },\n    E: function E() {\n      return this.isoWeekday();\n    },\n    a: function a() {\n      return this.lang().meridiem(this.hours(), this.minutes(), true);\n    },\n    A: function A() {\n      return this.lang().meridiem(this.hours(), this.minutes(), false);\n    },\n    H: function H() {\n      return this.hours();\n    },\n    h: function h() {\n      return this.hours() % 12 || 12;\n    },\n    m: function m() {\n      return this.minutes();\n    },\n    s: function s() {\n      return this.seconds();\n    },\n    S: function S() {\n      return toInt(this.milliseconds() / 100);\n    },\n    SS: function SS() {\n      return leftZeroFill(toInt(this.milliseconds() / 10), 2);\n    },\n    SSS: function SSS() {\n      return leftZeroFill(this.milliseconds(), 3);\n    },\n    SSSS: function SSSS() {\n      return leftZeroFill(this.milliseconds(), 3);\n    },\n    Z: function Z() {\n      var a = -this.zone(),\n          b = \"+\";\n\n      if (a < 0) {\n        a = -a;\n        b = \"-\";\n      }\n\n      return b + leftZeroFill(toInt(a / 60), 2) + \":\" + leftZeroFill(toInt(a) % 60, 2);\n    },\n    ZZ: function ZZ() {\n      var a = -this.zone(),\n          b = \"+\";\n\n      if (a < 0) {\n        a = -a;\n        b = \"-\";\n      }\n\n      return b + leftZeroFill(toInt(10 * a / 6), 4);\n    },\n    z: function z() {\n      return this.zoneAbbr();\n    },\n    zz: function zz() {\n      return this.zoneName();\n    },\n    X: function X() {\n      return this.unix();\n    }\n  },\n      lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];\n\n  function padToken(func, count) {\n    return function (a) {\n      return leftZeroFill(func.call(this, a), count);\n    };\n  }\n\n  function ordinalizeToken(func, period) {\n    return function (a) {\n      return this.lang().ordinal(func.call(this, a), period);\n    };\n  }\n\n  while (ordinalizeTokens.length) {\n    i = ordinalizeTokens.pop();\n    formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);\n  }\n\n  while (paddedTokens.length) {\n    i = paddedTokens.pop();\n    formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);\n  }\n\n  formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);\n  /************************************\n      Constructors\n  ************************************/\n\n  function Language() {} // Moment prototype object\n\n\n  function Moment(config) {\n    checkOverflow(config);\n    extend(this, config);\n  } // Duration Constructor\n\n\n  function Duration(duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0; // store reference to input for deterministic cloning\n\n    this._input = duration; // representation for dateAddRemove\n\n    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n    minutes * 6e4 + // 1000 * 60\n    hours * 36e5; // 1000 * 60 * 60\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n\n    this._days = +days + weeks * 7; // It is impossible translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n\n    this._months = +months + years * 12;\n    this._data = {};\n\n    this._bubble();\n  }\n  /************************************\n      Helpers\n  ************************************/\n\n\n  function extend(a, b) {\n    for (var i in b) {\n      if (b.hasOwnProperty(i)) {\n        a[i] = b[i];\n      }\n    }\n\n    if (b.hasOwnProperty(\"toString\")) {\n      a.toString = b.toString;\n    }\n\n    if (b.hasOwnProperty(\"valueOf\")) {\n      a.valueOf = b.valueOf;\n    }\n\n    return a;\n  }\n\n  function absRound(number) {\n    if (number < 0) {\n      return Math.ceil(number);\n    } else {\n      return Math.floor(number);\n    }\n  } // left zero fill a number\n  // see http://jsperf.com/left-zero-filling for performance comparison\n\n\n  function leftZeroFill(number, targetLength) {\n    var output = number + '';\n\n    while (output.length < targetLength) {\n      output = '0' + output;\n    }\n\n    return output;\n  } // helper function for _.addTime and _.subtractTime\n\n\n  function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = duration._days,\n        months = duration._months,\n        minutes,\n        hours;\n\n    if (milliseconds) {\n      mom._d.setTime(+mom._d + milliseconds * isAdding);\n    } // store the minutes and hours so we can restore them\n\n\n    if (days || months) {\n      minutes = mom.minute();\n      hours = mom.hour();\n    }\n\n    if (days) {\n      mom.date(mom.date() + days * isAdding);\n    }\n\n    if (months) {\n      mom.month(mom.month() + months * isAdding);\n    }\n\n    if (milliseconds && !ignoreUpdateOffset) {\n      moment.updateOffset(mom);\n    } // restore the minutes and hours after possibly changing dst\n\n\n    if (days || months) {\n      mom.minute(minutes);\n      mom.hour(hours);\n    }\n  } // check if is an array\n\n\n  function isArray(input) {\n    return Object.prototype.toString.call(input) === '[object Array]';\n  }\n\n  function isDate(input) {\n    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\n  } // compare two arrays, return the number of differences\n\n\n  function compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n\n    for (i = 0; i < len; i++) {\n      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n        diffs++;\n      }\n    }\n\n    return diffs + lengthDiff;\n  }\n\n  function normalizeUnits(units) {\n    if (units) {\n      var lowered = units.toLowerCase().replace(/(.)s$/, '$1');\n      units = unitAliases[units] || camelFunctions[lowered] || lowered;\n    }\n\n    return units;\n  }\n\n  function normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop,\n        index;\n\n    for (prop in inputObject) {\n      if (inputObject.hasOwnProperty(prop)) {\n        normalizedProp = normalizeUnits(prop);\n\n        if (normalizedProp) {\n          normalizedInput[normalizedProp] = inputObject[prop];\n        }\n      }\n    }\n\n    return normalizedInput;\n  }\n\n  function makeList(field) {\n    var count, setter;\n\n    if (field.indexOf('week') === 0) {\n      count = 7;\n      setter = 'day';\n    } else if (field.indexOf('month') === 0) {\n      count = 12;\n      setter = 'month';\n    } else {\n      return;\n    }\n\n    moment[field] = function (format, index) {\n      var i,\n          getter,\n          method = moment.fn._lang[field],\n          results = [];\n\n      if (typeof format === 'number') {\n        index = format;\n        format = undefined;\n      }\n\n      getter = function getter(i) {\n        var m = moment().utc().set(setter, i);\n        return method.call(moment.fn._lang, m, format || '');\n      };\n\n      if (index != null) {\n        return getter(index);\n      } else {\n        for (i = 0; i < count; i++) {\n          results.push(getter(i));\n        }\n\n        return results;\n      }\n    };\n  }\n\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      if (coercedNumber >= 0) {\n        value = Math.floor(coercedNumber);\n      } else {\n        value = Math.ceil(coercedNumber);\n      }\n    }\n\n    return value;\n  }\n\n  function _daysInMonth(year, month) {\n    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n  }\n\n  function daysInYear(year) {\n    return _isLeapYear(year) ? 366 : 365;\n  }\n\n  function _isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n\n  function checkOverflow(m) {\n    var overflow;\n\n    if (m._a && m._pf.overflow === -2) {\n      overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > _daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;\n\n      if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n        overflow = DATE;\n      }\n\n      m._pf.overflow = overflow;\n    }\n  }\n\n  function initializeParsingFlags(config) {\n    config._pf = {\n      empty: false,\n      unusedTokens: [],\n      unusedInput: [],\n      overflow: -2,\n      charsLeftOver: 0,\n      nullInput: false,\n      invalidMonth: null,\n      invalidFormat: false,\n      userInvalidated: false,\n      iso: false\n    };\n  }\n\n  function _isValid(m) {\n    if (m._isValid == null) {\n      m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;\n\n      if (m._strict) {\n        m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0;\n      }\n    }\n\n    return m._isValid;\n  }\n\n  function normalizeLanguage(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n  }\n  /************************************\n      Languages\n  ************************************/\n\n\n  extend(Language.prototype, {\n    set: function set(config) {\n      var prop, i;\n\n      for (i in config) {\n        prop = config[i];\n\n        if (typeof prop === 'function') {\n          this[i] = prop;\n        } else {\n          this['_' + i] = prop;\n        }\n      }\n    },\n    _months: \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),\n    months: function months(m) {\n      return this._months[m.month()];\n    },\n    _monthsShort: \"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"),\n    monthsShort: function monthsShort(m) {\n      return this._monthsShort[m.month()];\n    },\n    monthsParse: function monthsParse(monthName) {\n      var i, mom, regex;\n\n      if (!this._monthsParse) {\n        this._monthsParse = [];\n      }\n\n      for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        if (!this._monthsParse[i]) {\n          mom = moment.utc([2000, i]);\n          regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n          this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        } // test the regex\n\n\n        if (this._monthsParse[i].test(monthName)) {\n          return i;\n        }\n      }\n    },\n    _weekdays: \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),\n    weekdays: function weekdays(m) {\n      return this._weekdays[m.day()];\n    },\n    _weekdaysShort: \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"),\n    weekdaysShort: function weekdaysShort(m) {\n      return this._weekdaysShort[m.day()];\n    },\n    _weekdaysMin: \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"),\n    weekdaysMin: function weekdaysMin(m) {\n      return this._weekdaysMin[m.day()];\n    },\n    weekdaysParse: function weekdaysParse(weekdayName) {\n      var i, mom, regex;\n\n      if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n      }\n\n      for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n        if (!this._weekdaysParse[i]) {\n          mom = moment([2000, 1]).day(i);\n          regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n          this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        } // test the regex\n\n\n        if (this._weekdaysParse[i].test(weekdayName)) {\n          return i;\n        }\n      }\n    },\n    _longDateFormat: {\n      LT: \"h:mm A\",\n      L: \"MM/DD/YYYY\",\n      LL: \"MMMM D YYYY\",\n      LLL: \"MMMM D YYYY LT\",\n      LLLL: \"dddd, MMMM D YYYY LT\"\n    },\n    longDateFormat: function longDateFormat(key) {\n      var output = this._longDateFormat[key];\n\n      if (!output && this._longDateFormat[key.toUpperCase()]) {\n        output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {\n          return val.slice(1);\n        });\n        this._longDateFormat[key] = output;\n      }\n\n      return output;\n    },\n    isPM: function isPM(input) {\n      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n      // Using charAt should be more compatible.\n      return (input + '').toLowerCase().charAt(0) === 'p';\n    },\n    _meridiemParse: /[ap]\\.?m?\\.?/i,\n    meridiem: function meridiem(hours, minutes, isLower) {\n      if (hours > 11) {\n        return isLower ? 'pm' : 'PM';\n      } else {\n        return isLower ? 'am' : 'AM';\n      }\n    },\n    _calendar: {\n      sameDay: '[Today at] LT',\n      nextDay: '[Tomorrow at] LT',\n      nextWeek: 'dddd [at] LT',\n      lastDay: '[Yesterday at] LT',\n      lastWeek: '[Last] dddd [at] LT',\n      sameElse: 'L'\n    },\n    calendar: function calendar(key, mom) {\n      var output = this._calendar[key];\n      return typeof output === 'function' ? output.apply(mom) : output;\n    },\n    _relativeTime: {\n      future: \"in %s\",\n      past: \"%s ago\",\n      s: \"a few seconds\",\n      m: \"a minute\",\n      mm: \"%d minutes\",\n      h: \"an hour\",\n      hh: \"%d hours\",\n      d: \"a day\",\n      dd: \"%d days\",\n      M: \"a month\",\n      MM: \"%d months\",\n      y: \"a year\",\n      yy: \"%d years\"\n    },\n    relativeTime: function relativeTime(number, withoutSuffix, string, isFuture) {\n      var output = this._relativeTime[string];\n      return typeof output === 'function' ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n    },\n    pastFuture: function pastFuture(diff, output) {\n      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n      return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);\n    },\n    ordinal: function ordinal(number) {\n      return this._ordinal.replace(\"%d\", number);\n    },\n    _ordinal: \"%d\",\n    preparse: function preparse(string) {\n      return string;\n    },\n    postformat: function postformat(string) {\n      return string;\n    },\n    week: function week(mom) {\n      return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    },\n    _week: {\n      dow: 0,\n      // Sunday is the first day of the week.\n      doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n    },\n    _invalidDate: 'Invalid date',\n    invalidDate: function invalidDate() {\n      return this._invalidDate;\n    }\n  }); // Loads a language definition into the `languages` cache.  The function\n  // takes a key and optionally values.  If not in the browser and no values\n  // are provided, it will load the language file module.  As a convenience,\n  // this function also returns the language values.\n\n  function loadLang(key, values) {\n    values.abbr = key;\n\n    if (!languages[key]) {\n      languages[key] = new Language();\n    }\n\n    languages[key].set(values);\n    return languages[key];\n  } // Remove a language from the `languages` cache. Mostly useful in tests.\n\n\n  function unloadLang(key) {\n    delete languages[key];\n  } // Determines which language definition to use and returns it.\n  //\n  // With no parameters, it will return the global language.  If you\n  // pass in a language key, such as 'en', it will return the\n  // definition for 'en', so long as 'en' has already been loaded using\n  // moment.lang.\n\n\n  function getLangDefinition(key) {\n    var i = 0,\n        j,\n        lang,\n        next,\n        split,\n        get = function get(k) {\n      if (!languages[k] && hasModule) {\n        try {\n          require('./lang/' + k);\n        } catch (e) {}\n      }\n\n      return languages[k];\n    };\n\n    if (!key) {\n      return moment.fn._lang;\n    }\n\n    if (!isArray(key)) {\n      //short-circuit everything else\n      lang = get(key);\n\n      if (lang) {\n        return lang;\n      }\n\n      key = [key];\n    } //pick the language from the array\n    //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\n\n    while (i < key.length) {\n      split = normalizeLanguage(key[i]).split('-');\n      j = split.length;\n      next = normalizeLanguage(key[i + 1]);\n      next = next ? next.split('-') : null;\n\n      while (j > 0) {\n        lang = get(split.slice(0, j).join('-'));\n\n        if (lang) {\n          return lang;\n        }\n\n        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n          //the next array item is better than a shallower substring of this one\n          break;\n        }\n\n        j--;\n      }\n\n      i++;\n    }\n\n    return moment.fn._lang;\n  }\n  /************************************\n      Formatting\n  ************************************/\n\n\n  function removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n      return input.replace(/^\\[|\\]$/g, \"\");\n    }\n\n    return input.replace(/\\\\/g, \"\");\n  }\n\n  function makeFormatFunction(format) {\n    var array = format.match(formattingTokens),\n        i,\n        length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n      if (formatTokenFunctions[array[i]]) {\n        array[i] = formatTokenFunctions[array[i]];\n      } else {\n        array[i] = removeFormattingTokens(array[i]);\n      }\n    }\n\n    return function (mom) {\n      var output = \"\";\n\n      for (i = 0; i < length; i++) {\n        output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];\n      }\n\n      return output;\n    };\n  } // format date using native date object\n\n\n  function formatMoment(m, format) {\n    if (!m.isValid()) {\n      return m.lang().invalidDate();\n    }\n\n    format = expandFormat(format, m.lang());\n\n    if (!formatFunctions[format]) {\n      formatFunctions[format] = makeFormatFunction(format);\n    }\n\n    return formatFunctions[format](m);\n  }\n\n  function expandFormat(format, lang) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n      return lang.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n\n    while (i >= 0 && localFormattingTokens.test(format)) {\n      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n      localFormattingTokens.lastIndex = 0;\n      i -= 1;\n    }\n\n    return format;\n  }\n  /************************************\n      Parsing\n  ************************************/\n  // get the regex to find the next token\n\n\n  function getParseRegexForToken(token, config) {\n    var a;\n\n    switch (token) {\n      case 'DDDD':\n        return parseTokenThreeDigits;\n\n      case 'YYYY':\n      case 'GGGG':\n      case 'gggg':\n        return parseTokenFourDigits;\n\n      case 'YYYYY':\n      case 'GGGGG':\n      case 'ggggg':\n        return parseTokenSixDigits;\n\n      case 'S':\n      case 'SS':\n      case 'SSS':\n      case 'DDD':\n        return parseTokenOneToThreeDigits;\n\n      case 'MMM':\n      case 'MMMM':\n      case 'dd':\n      case 'ddd':\n      case 'dddd':\n        return parseTokenWord;\n\n      case 'a':\n      case 'A':\n        return getLangDefinition(config._l)._meridiemParse;\n\n      case 'X':\n        return parseTokenTimestampMs;\n\n      case 'Z':\n      case 'ZZ':\n        return parseTokenTimezone;\n\n      case 'T':\n        return parseTokenT;\n\n      case 'SSSS':\n        return parseTokenDigits;\n\n      case 'MM':\n      case 'DD':\n      case 'YY':\n      case 'GG':\n      case 'gg':\n      case 'HH':\n      case 'hh':\n      case 'mm':\n      case 'ss':\n      case 'M':\n      case 'D':\n      case 'd':\n      case 'H':\n      case 'h':\n      case 'm':\n      case 's':\n      case 'w':\n      case 'ww':\n      case 'W':\n      case 'WW':\n      case 'e':\n      case 'E':\n        return parseTokenOneOrTwoDigits;\n\n      default:\n        a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\\\', '')), \"i\"));\n        return a;\n    }\n  }\n\n  function timezoneMinutesFromString(string) {\n    var tzchunk = (parseTokenTimezone.exec(string) || [])[0],\n        parts = (tzchunk + '').match(parseTimezoneChunker) || ['-', 0, 0],\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n    return parts[0] === '+' ? -minutes : minutes;\n  } // function to convert string input to date\n\n\n  function addTimeToArrayFromToken(token, input, config) {\n    var a,\n        datePartArray = config._a;\n\n    switch (token) {\n      // MONTH\n      case 'M': // fall through to MM\n\n      case 'MM':\n        if (input != null) {\n          datePartArray[MONTH] = toInt(input) - 1;\n        }\n\n        break;\n\n      case 'MMM': // fall through to MMMM\n\n      case 'MMMM':\n        a = getLangDefinition(config._l).monthsParse(input); // if we didn't find a month name, mark the date as invalid.\n\n        if (a != null) {\n          datePartArray[MONTH] = a;\n        } else {\n          config._pf.invalidMonth = input;\n        }\n\n        break;\n      // DAY OF MONTH\n\n      case 'D': // fall through to DD\n\n      case 'DD':\n        if (input != null) {\n          datePartArray[DATE] = toInt(input);\n        }\n\n        break;\n      // DAY OF YEAR\n\n      case 'DDD': // fall through to DDDD\n\n      case 'DDDD':\n        if (input != null) {\n          config._dayOfYear = toInt(input);\n        }\n\n        break;\n      // YEAR\n\n      case 'YY':\n        datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n        break;\n\n      case 'YYYY':\n      case 'YYYYY':\n        datePartArray[YEAR] = toInt(input);\n        break;\n      // AM / PM\n\n      case 'a': // fall through to A\n\n      case 'A':\n        config._isPm = getLangDefinition(config._l).isPM(input);\n        break;\n      // 24 HOUR\n\n      case 'H': // fall through to hh\n\n      case 'HH': // fall through to hh\n\n      case 'h': // fall through to hh\n\n      case 'hh':\n        datePartArray[HOUR] = toInt(input);\n        break;\n      // MINUTE\n\n      case 'm': // fall through to mm\n\n      case 'mm':\n        datePartArray[MINUTE] = toInt(input);\n        break;\n      // SECOND\n\n      case 's': // fall through to ss\n\n      case 'ss':\n        datePartArray[SECOND] = toInt(input);\n        break;\n      // MILLISECOND\n\n      case 'S':\n      case 'SS':\n      case 'SSS':\n      case 'SSSS':\n        datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);\n        break;\n      // UNIX TIMESTAMP WITH MS\n\n      case 'X':\n        config._d = new Date(parseFloat(input) * 1000);\n        break;\n      // TIMEZONE\n\n      case 'Z': // fall through to ZZ\n\n      case 'ZZ':\n        config._useUTC = true;\n        config._tzm = timezoneMinutesFromString(input);\n        break;\n\n      case 'w':\n      case 'ww':\n      case 'W':\n      case 'WW':\n      case 'd':\n      case 'dd':\n      case 'ddd':\n      case 'dddd':\n      case 'e':\n      case 'E':\n        token = token.substr(0, 1);\n\n      /* falls through */\n\n      case 'gg':\n      case 'gggg':\n      case 'GG':\n      case 'GGGG':\n      case 'GGGGG':\n        token = token.substr(0, 2);\n\n        if (input) {\n          config._w = config._w || {};\n          config._w[token] = input;\n        }\n\n        break;\n    }\n  } // convert an array to a date.\n  // the array should mirror the parameters below\n  // note: all values past the year are optional and will default to the lowest possible value.\n  // [year, month, day , hour, minute, second, millisecond]\n\n\n  function dateFromConfig(config) {\n    var i,\n        date,\n        input = [],\n        currentDate,\n        yearToUse,\n        fixYear,\n        w,\n        temp,\n        lang,\n        weekday,\n        week;\n\n    if (config._d) {\n      return;\n    }\n\n    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays\n\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n      fixYear = function fixYear(val) {\n        return val ? val.length < 3 ? parseInt(val, 10) > 68 ? '19' + val : '20' + val : val : config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR];\n      };\n\n      w = config._w;\n\n      if (w.GG != null || w.W != null || w.E != null) {\n        temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);\n      } else {\n        lang = getLangDefinition(config._l);\n        weekday = w.d != null ? parseWeekday(w.d, lang) : w.e != null ? parseInt(w.e, 10) + lang._week.dow : 0;\n        week = parseInt(w.w, 10) || 1; //if we're parsing 'd', then the low day numbers may be next week\n\n        if (w.d != null && weekday < lang._week.dow) {\n          week++;\n        }\n\n        temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);\n      }\n\n      config._a[YEAR] = temp.year;\n      config._dayOfYear = temp.dayOfYear;\n    } //if the day of the year is set, figure out what it is\n\n\n    if (config._dayOfYear) {\n      yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];\n\n      if (config._dayOfYear > daysInYear(yearToUse)) {\n        config._pf._overflowDayOfYear = true;\n      }\n\n      date = makeUTCDate(yearToUse, 0, config._dayOfYear);\n      config._a[MONTH] = date.getUTCMonth();\n      config._a[DATE] = date.getUTCDate();\n    } // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n\n\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n      config._a[i] = input[i] = currentDate[i];\n    } // Zero out whatever was not defaulted, including time\n\n\n    for (; i < 7; i++) {\n      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n    } // add the offsets to the time to be parsed so that we can have a clean array for checking isValid\n\n\n    input[HOUR] += toInt((config._tzm || 0) / 60);\n    input[MINUTE] += toInt((config._tzm || 0) % 60);\n    config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);\n  }\n\n  function dateFromObject(config) {\n    var normalizedInput;\n\n    if (config._d) {\n      return;\n    }\n\n    normalizedInput = normalizeObjectUnits(config._i);\n    config._a = [normalizedInput.year, normalizedInput.month, normalizedInput.day, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond];\n    dateFromConfig(config);\n  }\n\n  function currentDateArray(config) {\n    var now = new Date();\n\n    if (config._useUTC) {\n      return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];\n    } else {\n      return [now.getFullYear(), now.getMonth(), now.getDate()];\n    }\n  } // date from string and format string\n\n\n  function makeDateFromStringAndFormat(config) {\n    config._a = [];\n    config._pf.empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\n    var lang = getLangDefinition(config._l),\n        string = '' + config._i,\n        i,\n        parsedInput,\n        tokens,\n        token,\n        skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n    tokens = expandFormat(config._f, lang).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      parsedInput = (getParseRegexForToken(token, config).exec(string) || [])[0];\n\n      if (parsedInput) {\n        skipped = string.substr(0, string.indexOf(parsedInput));\n\n        if (skipped.length > 0) {\n          config._pf.unusedInput.push(skipped);\n        }\n\n        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n        totalParsedInputLength += parsedInput.length;\n      } // don't parse if it's not a known token\n\n\n      if (formatTokenFunctions[token]) {\n        if (parsedInput) {\n          config._pf.empty = false;\n        } else {\n          config._pf.unusedTokens.push(token);\n        }\n\n        addTimeToArrayFromToken(token, parsedInput, config);\n      } else if (config._strict && !parsedInput) {\n        config._pf.unusedTokens.push(token);\n      }\n    } // add remaining unparsed input length to the string\n\n\n    config._pf.charsLeftOver = stringLength - totalParsedInputLength;\n\n    if (string.length > 0) {\n      config._pf.unusedInput.push(string);\n    } // handle am pm\n\n\n    if (config._isPm && config._a[HOUR] < 12) {\n      config._a[HOUR] += 12;\n    } // if is 12 am, change hours to 0\n\n\n    if (config._isPm === false && config._a[HOUR] === 12) {\n      config._a[HOUR] = 0;\n    }\n\n    dateFromConfig(config);\n    checkOverflow(config);\n  }\n\n  function unescapeFormat(s) {\n    return s.replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n      return p1 || p2 || p3 || p4;\n    });\n  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\n\n  function regexpEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  } // date from string and array of format strings\n\n\n  function makeDateFromStringAndArray(config) {\n    var tempConfig, bestMoment, scoreToBeat, i, currentScore;\n\n    if (config._f.length === 0) {\n      config._pf.invalidFormat = true;\n      config._d = new Date(NaN);\n      return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n      currentScore = 0;\n      tempConfig = extend({}, config);\n      initializeParsingFlags(tempConfig);\n      tempConfig._f = config._f[i];\n      makeDateFromStringAndFormat(tempConfig);\n\n      if (!_isValid(tempConfig)) {\n        continue;\n      } // if there is any input that was not parsed add a penalty for that format\n\n\n      currentScore += tempConfig._pf.charsLeftOver; //or tokens\n\n      currentScore += tempConfig._pf.unusedTokens.length * 10;\n      tempConfig._pf.score = currentScore;\n\n      if (scoreToBeat == null || currentScore < scoreToBeat) {\n        scoreToBeat = currentScore;\n        bestMoment = tempConfig;\n      }\n    }\n\n    extend(config, bestMoment || tempConfig);\n  } // date from iso format\n\n\n  function makeDateFromString(config) {\n    var i,\n        string = config._i,\n        match = isoRegex.exec(string);\n\n    if (match) {\n      config._pf.iso = true;\n\n      for (i = 4; i > 0; i--) {\n        if (match[i]) {\n          // match[5] should be \"T\" or undefined\n          config._f = isoDates[i - 1] + (match[6] || \" \");\n          break;\n        }\n      }\n\n      for (i = 0; i < 4; i++) {\n        if (isoTimes[i][1].exec(string)) {\n          config._f += isoTimes[i][0];\n          break;\n        }\n      }\n\n      if (parseTokenTimezone.exec(string)) {\n        config._f += \"Z\";\n      }\n\n      makeDateFromStringAndFormat(config);\n    } else {\n      config._d = new Date(string);\n    }\n  }\n\n  function makeDateFromInput(config) {\n    var input = config._i,\n        matched = aspNetJsonRegex.exec(input);\n\n    if (input === undefined) {\n      config._d = new Date();\n    } else if (matched) {\n      config._d = new Date(+matched[1]);\n    } else if (typeof input === 'string') {\n      makeDateFromString(config);\n    } else if (isArray(input)) {\n      config._a = input.slice(0);\n      dateFromConfig(config);\n    } else if (isDate(input)) {\n      config._d = new Date(+input);\n    } else if (typeof input === 'object') {\n      dateFromObject(config);\n    } else {\n      config._d = new Date(input);\n    }\n  }\n\n  function makeDate(y, m, d, h, M, s, ms) {\n    //can't just apply() to create a date:\n    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply\n    var date = new Date(y, m, d, h, M, s, ms); //the date constructor doesn't accept years < 1970\n\n    if (y < 1970) {\n      date.setFullYear(y);\n    }\n\n    return date;\n  }\n\n  function makeUTCDate(y) {\n    var date = new Date(Date.UTC.apply(null, arguments));\n\n    if (y < 1970) {\n      date.setUTCFullYear(y);\n    }\n\n    return date;\n  }\n\n  function parseWeekday(input, language) {\n    if (typeof input === 'string') {\n      if (!isNaN(input)) {\n        input = parseInt(input, 10);\n      } else {\n        input = language.weekdaysParse(input);\n\n        if (typeof input !== 'number') {\n          return null;\n        }\n      }\n    }\n\n    return input;\n  }\n  /************************************\n      Relative Time\n  ************************************/\n  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\n\n  function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {\n    return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n  }\n\n  function relativeTime(milliseconds, withoutSuffix, lang) {\n    var seconds = round(Math.abs(milliseconds) / 1000),\n        minutes = round(seconds / 60),\n        hours = round(minutes / 60),\n        days = round(hours / 24),\n        years = round(days / 365),\n        args = seconds < 45 && ['s', seconds] || minutes === 1 && ['m'] || minutes < 45 && ['mm', minutes] || hours === 1 && ['h'] || hours < 22 && ['hh', hours] || days === 1 && ['d'] || days <= 25 && ['dd', days] || days <= 45 && ['M'] || days < 345 && ['MM', round(days / 30)] || years === 1 && ['y'] || ['yy', years];\n    args[2] = withoutSuffix;\n    args[3] = milliseconds > 0;\n    args[4] = lang;\n    return substituteTimeAgo.apply({}, args);\n  }\n  /************************************\n      Week of Year\n  ************************************/\n  // firstDayOfWeek       0 = sun, 6 = sat\n  //                      the day of the week that starts the week\n  //                      (usually sunday or monday)\n  // firstDayOfWeekOfYear 0 = sun, 6 = sat\n  //                      the first week is the week that contains the first\n  //                      of this day of the week\n  //                      (eg. ISO weeks use thursday (4))\n\n\n  function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {\n    var end = firstDayOfWeekOfYear - firstDayOfWeek,\n        daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),\n        adjustedMoment;\n\n    if (daysToDayOfWeek > end) {\n      daysToDayOfWeek -= 7;\n    }\n\n    if (daysToDayOfWeek < end - 7) {\n      daysToDayOfWeek += 7;\n    }\n\n    adjustedMoment = moment(mom).add('d', daysToDayOfWeek);\n    return {\n      week: Math.ceil(adjustedMoment.dayOfYear() / 7),\n      year: adjustedMoment.year()\n    };\n  } //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\n\n  function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {\n    var d = new Date(Date.UTC(year, 0)).getUTCDay(),\n        daysToAdd,\n        dayOfYear;\n    weekday = weekday != null ? weekday : firstDayOfWeek;\n    daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0);\n    dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;\n    return {\n      year: dayOfYear > 0 ? year : year - 1,\n      dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear\n    };\n  }\n  /************************************\n      Top Level Functions\n  ************************************/\n\n\n  function makeMoment(config) {\n    var input = config._i,\n        format = config._f;\n\n    if (typeof config._pf === 'undefined') {\n      initializeParsingFlags(config);\n    }\n\n    if (input === null) {\n      return moment.invalid({\n        nullInput: true\n      });\n    }\n\n    if (typeof input === 'string') {\n      config._i = input = getLangDefinition().preparse(input);\n    }\n\n    if (moment.isMoment(input)) {\n      config = extend({}, input);\n      config._d = new Date(+input._d);\n    } else if (format) {\n      if (isArray(format)) {\n        makeDateFromStringAndArray(config);\n      } else {\n        makeDateFromStringAndFormat(config);\n      }\n    } else {\n      makeDateFromInput(config);\n    }\n\n    return new Moment(config);\n  }\n\n  moment = function moment(input, format, lang, strict) {\n    if (typeof lang === \"boolean\") {\n      strict = lang;\n      lang = undefined;\n    }\n\n    return makeMoment({\n      _i: input,\n      _f: format,\n      _l: lang,\n      _strict: strict,\n      _isUTC: false\n    });\n  }; // creating with utc\n\n\n  moment.utc = function (input, format, lang, strict) {\n    var m;\n\n    if (typeof lang === \"boolean\") {\n      strict = lang;\n      lang = undefined;\n    }\n\n    m = makeMoment({\n      _useUTC: true,\n      _isUTC: true,\n      _l: lang,\n      _i: input,\n      _f: format,\n      _strict: strict\n    }).utc();\n    return m;\n  }; // creating with unix timestamp (in seconds)\n\n\n  moment.unix = function (input) {\n    return moment(input * 1000);\n  }; // duration\n\n\n  moment.duration = function (input, key) {\n    var isDuration = moment.isDuration(input),\n        isNumber = typeof input === 'number',\n        duration = isDuration ? input._input : isNumber ? {} : input,\n        // matching against regexp is expensive, do it on demand\n    match = null,\n        sign,\n        ret,\n        parseIso,\n        timeEmpty,\n        dateTimeEmpty;\n\n    if (isNumber) {\n      if (key) {\n        duration[key] = input;\n      } else {\n        duration.milliseconds = input;\n      }\n    } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {\n      sign = match[1] === \"-\" ? -1 : 1;\n      duration = {\n        y: 0,\n        d: toInt(match[DATE]) * sign,\n        h: toInt(match[HOUR]) * sign,\n        m: toInt(match[MINUTE]) * sign,\n        s: toInt(match[SECOND]) * sign,\n        ms: toInt(match[MILLISECOND]) * sign\n      };\n    } else if (!!(match = isoDurationRegex.exec(input))) {\n      sign = match[1] === \"-\" ? -1 : 1;\n\n      parseIso = function parseIso(inp) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it\n\n        return (isNaN(res) ? 0 : res) * sign;\n      };\n\n      duration = {\n        y: parseIso(match[2]),\n        M: parseIso(match[3]),\n        d: parseIso(match[4]),\n        h: parseIso(match[5]),\n        m: parseIso(match[6]),\n        s: parseIso(match[7]),\n        w: parseIso(match[8])\n      };\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration && input.hasOwnProperty('_lang')) {\n      ret._lang = input._lang;\n    }\n\n    return ret;\n  }; // version number\n\n\n  moment.version = VERSION; // default format\n\n  moment.defaultFormat = isoFormat; // This function will be called whenever a moment is mutated.\n  // It is intended to keep the offset in sync with the timezone.\n\n  moment.updateOffset = function () {}; // This function will load languages and then set the global language.  If\n  // no arguments are passed in, it will simply return the current global\n  // language key.\n\n\n  moment.lang = function (key, values) {\n    var r;\n\n    if (!key) {\n      return moment.fn._lang._abbr;\n    }\n\n    if (values) {\n      loadLang(normalizeLanguage(key), values);\n    } else if (values === null) {\n      unloadLang(key);\n      key = 'en';\n    } else if (!languages[key]) {\n      getLangDefinition(key);\n    }\n\n    r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);\n    return r._abbr;\n  }; // returns language data\n\n\n  moment.langData = function (key) {\n    if (key && key._lang && key._lang._abbr) {\n      key = key._lang._abbr;\n    }\n\n    return getLangDefinition(key);\n  }; // compare moment object\n\n\n  moment.isMoment = function (obj) {\n    return obj instanceof Moment;\n  }; // for typechecking Duration objects\n\n\n  moment.isDuration = function (obj) {\n    return obj instanceof Duration;\n  };\n\n  for (i = lists.length - 1; i >= 0; --i) {\n    makeList(lists[i]);\n  }\n\n  moment.normalizeUnits = function (units) {\n    return normalizeUnits(units);\n  };\n\n  moment.invalid = function (flags) {\n    var m = moment.utc(NaN);\n\n    if (flags != null) {\n      extend(m._pf, flags);\n    } else {\n      m._pf.userInvalidated = true;\n    }\n\n    return m;\n  };\n\n  moment.parseZone = function (input) {\n    return moment(input).parseZone();\n  };\n  /************************************\n      Moment Prototype\n  ************************************/\n\n\n  extend(moment.fn = Moment.prototype, {\n    clone: function clone() {\n      return moment(this);\n    },\n    valueOf: function valueOf() {\n      return +this._d + (this._offset || 0) * 60000;\n    },\n    unix: function unix() {\n      return Math.floor(+this / 1000);\n    },\n    toString: function toString() {\n      return this.clone().lang('en').format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\n    },\n    toDate: function toDate() {\n      return this._offset ? new Date(+this) : this._d;\n    },\n    toISOString: function toISOString() {\n      return formatMoment(moment(this).utc(), 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n    },\n    toArray: function toArray() {\n      var m = this;\n      return [m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()];\n    },\n    isValid: function isValid() {\n      return _isValid(this);\n    },\n    isDSTShifted: function isDSTShifted() {\n      if (this._a) {\n        return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;\n      }\n\n      return false;\n    },\n    parsingFlags: function parsingFlags() {\n      return extend({}, this._pf);\n    },\n    invalidAt: function invalidAt() {\n      return this._pf.overflow;\n    },\n    utc: function utc() {\n      return this.zone(0);\n    },\n    local: function local() {\n      this.zone(0);\n      this._isUTC = false;\n      return this;\n    },\n    format: function format(inputString) {\n      var output = formatMoment(this, inputString || moment.defaultFormat);\n      return this.lang().postformat(output);\n    },\n    add: function add(input, val) {\n      var dur; // switch args to support add('s', 1) and add(1, 's')\n\n      if (typeof input === 'string') {\n        dur = moment.duration(+val, input);\n      } else {\n        dur = moment.duration(input, val);\n      }\n\n      addOrSubtractDurationFromMoment(this, dur, 1);\n      return this;\n    },\n    subtract: function subtract(input, val) {\n      var dur; // switch args to support subtract('s', 1) and subtract(1, 's')\n\n      if (typeof input === 'string') {\n        dur = moment.duration(+val, input);\n      } else {\n        dur = moment.duration(input, val);\n      }\n\n      addOrSubtractDurationFromMoment(this, dur, -1);\n      return this;\n    },\n    diff: function diff(input, units, asFloat) {\n      var that = this._isUTC ? moment(input).zone(this._offset || 0) : moment(input).local(),\n          zoneDiff = (this.zone() - that.zone()) * 6e4,\n          diff,\n          output;\n      units = normalizeUnits(units);\n\n      if (units === 'year' || units === 'month') {\n        // average number of days in the months in the given dates\n        diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2\n        // difference in months\n\n        output = (this.year() - that.year()) * 12 + (this.month() - that.month()); // adjust by taking difference in days, average number of days\n        // and dst in the given months.\n\n        output += (this - moment(this).startOf('month') - (that - moment(that).startOf('month'))) / diff; // same as above but with zones, to negate all dst\n\n        output -= (this.zone() - moment(this).startOf('month').zone() - (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;\n\n        if (units === 'year') {\n          output = output / 12;\n        }\n      } else {\n        diff = this - that;\n        output = units === 'second' ? diff / 1e3 : // 1000\n        units === 'minute' ? diff / 6e4 : // 1000 * 60\n        units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60\n        units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n        units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n        diff;\n      }\n\n      return asFloat ? output : absRound(output);\n    },\n    from: function from(time, withoutSuffix) {\n      return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);\n    },\n    fromNow: function fromNow(withoutSuffix) {\n      return this.from(moment(), withoutSuffix);\n    },\n    calendar: function calendar() {\n      var diff = this.diff(moment().zone(this.zone()).startOf('day'), 'days', true),\n          format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';\n      return this.format(this.lang().calendar(format, this));\n    },\n    isLeapYear: function isLeapYear() {\n      return _isLeapYear(this.year());\n    },\n    isDST: function isDST() {\n      return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone();\n    },\n    day: function day(input) {\n      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\n      if (input != null) {\n        input = parseWeekday(input, this.lang());\n        return this.add({\n          d: input - day\n        });\n      } else {\n        return day;\n      }\n    },\n    month: function month(input) {\n      var utc = this._isUTC ? 'UTC' : '',\n          dayOfMonth;\n\n      if (input != null) {\n        if (typeof input === 'string') {\n          input = this.lang().monthsParse(input);\n\n          if (typeof input !== 'number') {\n            return this;\n          }\n        }\n\n        dayOfMonth = this.date();\n        this.date(1);\n\n        this._d['set' + utc + 'Month'](input);\n\n        this.date(Math.min(dayOfMonth, this.daysInMonth()));\n        moment.updateOffset(this);\n        return this;\n      } else {\n        return this._d['get' + utc + 'Month']();\n      }\n    },\n    startOf: function startOf(units) {\n      units = normalizeUnits(units); // the following switch intentionally omits break keywords\n      // to utilize falling through the cases.\n\n      switch (units) {\n        case 'year':\n          this.month(0);\n\n        /* falls through */\n\n        case 'month':\n          this.date(1);\n\n        /* falls through */\n\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n          this.hours(0);\n\n        /* falls through */\n\n        case 'hour':\n          this.minutes(0);\n\n        /* falls through */\n\n        case 'minute':\n          this.seconds(0);\n\n        /* falls through */\n\n        case 'second':\n          this.milliseconds(0);\n\n        /* falls through */\n      } // weeks are a special case\n\n\n      if (units === 'week') {\n        this.weekday(0);\n      } else if (units === 'isoWeek') {\n        this.isoWeekday(1);\n      }\n\n      return this;\n    },\n    endOf: function endOf(units) {\n      units = normalizeUnits(units);\n      return this.startOf(units).add(units === 'isoWeek' ? 'week' : units, 1).subtract('ms', 1);\n    },\n    isAfter: function isAfter(input, units) {\n      units = typeof units !== 'undefined' ? units : 'millisecond';\n      return +this.clone().startOf(units) > +moment(input).startOf(units);\n    },\n    isBefore: function isBefore(input, units) {\n      units = typeof units !== 'undefined' ? units : 'millisecond';\n      return +this.clone().startOf(units) < +moment(input).startOf(units);\n    },\n    isSame: function isSame(input, units) {\n      units = typeof units !== 'undefined' ? units : 'millisecond';\n      return +this.clone().startOf(units) === +moment(input).startOf(units);\n    },\n    min: function min(other) {\n      other = moment.apply(null, arguments);\n      return other < this ? this : other;\n    },\n    max: function max(other) {\n      other = moment.apply(null, arguments);\n      return other > this ? this : other;\n    },\n    zone: function zone(input) {\n      var offset = this._offset || 0;\n\n      if (input != null) {\n        if (typeof input === \"string\") {\n          input = timezoneMinutesFromString(input);\n        }\n\n        if (Math.abs(input) < 16) {\n          input = input * 60;\n        }\n\n        this._offset = input;\n        this._isUTC = true;\n\n        if (offset !== input) {\n          addOrSubtractDurationFromMoment(this, moment.duration(offset - input, 'm'), 1, true);\n        }\n      } else {\n        return this._isUTC ? offset : this._d.getTimezoneOffset();\n      }\n\n      return this;\n    },\n    zoneAbbr: function zoneAbbr() {\n      return this._isUTC ? \"UTC\" : \"\";\n    },\n    zoneName: function zoneName() {\n      return this._isUTC ? \"Coordinated Universal Time\" : \"\";\n    },\n    parseZone: function parseZone() {\n      if (typeof this._i === 'string') {\n        this.zone(this._i);\n      }\n\n      return this;\n    },\n    hasAlignedHourOffset: function hasAlignedHourOffset(input) {\n      if (!input) {\n        input = 0;\n      } else {\n        input = moment(input).zone();\n      }\n\n      return (this.zone() - input) % 60 === 0;\n    },\n    daysInMonth: function daysInMonth() {\n      return _daysInMonth(this.year(), this.month());\n    },\n    dayOfYear: function dayOfYear(input) {\n      var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;\n      return input == null ? dayOfYear : this.add(\"d\", input - dayOfYear);\n    },\n    weekYear: function weekYear(input) {\n      var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;\n      return input == null ? year : this.add(\"y\", input - year);\n    },\n    isoWeekYear: function isoWeekYear(input) {\n      var year = weekOfYear(this, 1, 4).year;\n      return input == null ? year : this.add(\"y\", input - year);\n    },\n    week: function week(input) {\n      var week = this.lang().week(this);\n      return input == null ? week : this.add(\"d\", (input - week) * 7);\n    },\n    isoWeek: function isoWeek(input) {\n      var week = weekOfYear(this, 1, 4).week;\n      return input == null ? week : this.add(\"d\", (input - week) * 7);\n    },\n    weekday: function weekday(input) {\n      var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;\n      return input == null ? weekday : this.add(\"d\", input - weekday);\n    },\n    isoWeekday: function isoWeekday(input) {\n      // behaves the same as moment#day except\n      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n      // as a setter, sunday should belong to the previous week.\n      return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);\n    },\n    get: function get(units) {\n      units = normalizeUnits(units);\n      return this[units]();\n    },\n    set: function set(units, value) {\n      units = normalizeUnits(units);\n\n      if (typeof this[units] === 'function') {\n        this[units](value);\n      }\n\n      return this;\n    },\n    // If passed a language key, it will set the language for this\n    // instance.  Otherwise, it will return the language configuration\n    // variables for this instance.\n    lang: function lang(key) {\n      if (key === undefined) {\n        return this._lang;\n      } else {\n        this._lang = getLangDefinition(key);\n        return this;\n      }\n    }\n  }); // helper for adding shortcuts\n\n  function makeGetterAndSetter(name, key) {\n    moment.fn[name] = moment.fn[name + 's'] = function (input) {\n      var utc = this._isUTC ? 'UTC' : '';\n\n      if (input != null) {\n        this._d['set' + utc + key](input);\n\n        moment.updateOffset(this);\n        return this;\n      } else {\n        return this._d['get' + utc + key]();\n      }\n    };\n  } // loop through and add shortcuts (Month, Date, Hours, Minutes, Seconds, Milliseconds)\n\n\n  for (i = 0; i < proxyGettersAndSetters.length; i++) {\n    makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ''), proxyGettersAndSetters[i]);\n  } // add shortcut for year (uses different syntax than the getter/setter 'year' == 'FullYear')\n\n\n  makeGetterAndSetter('year', 'FullYear'); // add plural methods\n\n  moment.fn.days = moment.fn.day;\n  moment.fn.months = moment.fn.month;\n  moment.fn.weeks = moment.fn.week;\n  moment.fn.isoWeeks = moment.fn.isoWeek; // add aliased format methods\n\n  moment.fn.toJSON = moment.fn.toISOString;\n  /************************************\n      Duration Prototype\n  ************************************/\n\n  extend(moment.duration.fn = Duration.prototype, {\n    _bubble: function _bubble() {\n      var milliseconds = this._milliseconds,\n          days = this._days,\n          months = this._months,\n          data = this._data,\n          seconds,\n          minutes,\n          hours,\n          years; // The following code bubbles up values, see the tests for\n      // examples of what that means.\n\n      data.milliseconds = milliseconds % 1000;\n      seconds = absRound(milliseconds / 1000);\n      data.seconds = seconds % 60;\n      minutes = absRound(seconds / 60);\n      data.minutes = minutes % 60;\n      hours = absRound(minutes / 60);\n      data.hours = hours % 24;\n      days += absRound(hours / 24);\n      data.days = days % 30;\n      months += absRound(days / 30);\n      data.months = months % 12;\n      years = absRound(months / 12);\n      data.years = years;\n    },\n    weeks: function weeks() {\n      return absRound(this.days() / 7);\n    },\n    valueOf: function valueOf() {\n      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n    },\n    humanize: function humanize(withSuffix) {\n      var difference = +this,\n          output = relativeTime(difference, !withSuffix, this.lang());\n\n      if (withSuffix) {\n        output = this.lang().pastFuture(difference, output);\n      }\n\n      return this.lang().postformat(output);\n    },\n    add: function add(input, val) {\n      // supports only 2.0-style add(1, 's') or add(moment)\n      var dur = moment.duration(input, val);\n      this._milliseconds += dur._milliseconds;\n      this._days += dur._days;\n      this._months += dur._months;\n\n      this._bubble();\n\n      return this;\n    },\n    subtract: function subtract(input, val) {\n      var dur = moment.duration(input, val);\n      this._milliseconds -= dur._milliseconds;\n      this._days -= dur._days;\n      this._months -= dur._months;\n\n      this._bubble();\n\n      return this;\n    },\n    get: function get(units) {\n      units = normalizeUnits(units);\n      return this[units.toLowerCase() + 's']();\n    },\n    as: function as(units) {\n      units = normalizeUnits(units);\n      return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();\n    },\n    lang: moment.fn.lang,\n    toIsoString: function toIsoString() {\n      // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n      var years = Math.abs(this.years()),\n          months = Math.abs(this.months()),\n          days = Math.abs(this.days()),\n          hours = Math.abs(this.hours()),\n          minutes = Math.abs(this.minutes()),\n          seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);\n\n      if (!this.asSeconds()) {\n        // this is the same as C#'s (Noda) and python (isodate)...\n        // but not other JS (goog.date)\n        return 'P0D';\n      }\n\n      return (this.asSeconds() < 0 ? '-' : '') + 'P' + (years ? years + 'Y' : '') + (months ? months + 'M' : '') + (days ? days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hours + 'H' : '') + (minutes ? minutes + 'M' : '') + (seconds ? seconds + 'S' : '');\n    }\n  });\n\n  function makeDurationGetter(name) {\n    moment.duration.fn[name] = function () {\n      return this._data[name];\n    };\n  }\n\n  function makeDurationAsGetter(name, factor) {\n    moment.duration.fn['as' + name] = function () {\n      return +this / factor;\n    };\n  }\n\n  for (i in unitMillisecondFactors) {\n    if (unitMillisecondFactors.hasOwnProperty(i)) {\n      makeDurationAsGetter(i, unitMillisecondFactors[i]);\n      makeDurationGetter(i.toLowerCase());\n    }\n  }\n\n  makeDurationAsGetter('Weeks', 6048e5);\n\n  moment.duration.fn.asMonths = function () {\n    return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;\n  };\n  /************************************\n      Default Lang\n  ************************************/\n  // Set default language, other languages will inherit from English.\n\n\n  moment.lang('en', {\n    ordinal: function ordinal(number) {\n      var b = number % 10,\n          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\n      return number + output;\n    }\n  });\n  /* EMBED_LANGUAGES */\n\n  /************************************\n      Exposing Moment\n  ************************************/\n\n  function makeGlobal(deprecate) {\n    var warned = false,\n        local_moment = moment;\n    /*global ender:false */\n\n    if (typeof ender !== 'undefined') {\n      return;\n    } // here, `this` means `window` in the browser, or `global` on the server\n    // add `moment` as a global object via a string identifier,\n    // for Closure Compiler \"advanced\" mode\n\n\n    if (deprecate) {\n      this.moment = function () {\n        if (!warned && console && console.warn) {\n          warned = true;\n          console.warn(\"Accessing Moment through the global scope is \" + \"deprecated, and will be removed in an upcoming \" + \"release.\");\n        }\n\n        return local_moment.apply(null, arguments);\n      };\n    } else {\n      this['moment'] = moment;\n    }\n  } // CommonJS module is defined\n\n\n  if (hasModule) {\n    module.exports = moment;\n    makeGlobal(true);\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"moment\", function (require, exports, module) {\n      if (module.config().noGlobal !== true) {\n        // If user provided noGlobal, he is aware of global\n        makeGlobal(module.config().noGlobal === undefined);\n      }\n\n      return moment;\n    });\n  } else {\n    makeGlobal();\n  }\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}