{"ast":null,"code":"\"use strict\";\n\nvar request = require(\"request\");\n\nvar _require = require(\"events\"),\n    EventEmitter = _require.EventEmitter;\n\nvar Event = require(\"./generated/Event\");\n\nvar ProgressEvent = require(\"./generated/ProgressEvent\");\n\nvar fs = require(\"fs\");\n\nvar _require2 = require(\"whatwg-url\"),\n    URL = _require2.URL;\n\nvar parseDataURL = require(\"data-urls\");\n\nvar DOMException = require(\"domexception\");\n\nvar xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nvar headerListSeparatorRegexp = /,[ \\t]*/;\nvar simpleMethods = new Set([\"GET\", \"HEAD\", \"POST\"]);\nvar simpleHeaders = new Set([\"accept\", \"accept-language\", \"content-language\", \"content-type\"]);\nvar preflightHeaders = new Set([\"access-control-expose-headers\", \"access-control-allow-headers\", \"access-control-allow-credentials\", \"access-control-allow-origin\"]);\n\nfunction wrapCookieJarForRequest(cookieJar) {\n  var jarWrapper = request.jar();\n  jarWrapper._jar = cookieJar;\n  return jarWrapper;\n}\n\nfunction getRequestHeader(requestHeaders, header) {\n  var lcHeader = header.toLowerCase();\n  var keys = Object.keys(requestHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return requestHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction updateRequestHeader(requestHeaders, header, newValue) {\n  var lcHeader = header.toLowerCase();\n  var keys = Object.keys(requestHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      requestHeaders[key] = newValue;\n    }\n  }\n}\n\nfunction mergeHeaders(lhs, rhs) {\n  var rhsParts = rhs.split(\",\");\n  var lhsParts = lhs.split(\",\");\n  return rhsParts.concat(lhsParts.filter(function (p) {\n    return rhsParts.indexOf(p) < 0;\n  })).join(\",\");\n}\n\nfunction dispatchError(xhr) {\n  var errMessage = xhr[xhrSymbols.properties].error;\n  requestErrorSteps(xhr, \"error\", new DOMException(errMessage, \"NetworkError\"));\n\n  if (xhr._ownerDocument) {\n    var error = new Error(errMessage);\n    error.type = \"XMLHttpRequest\";\n\n    xhr._ownerDocument._defaultView._virtualConsole.emit(\"jsdomError\", error);\n  }\n}\n\nfunction validCORSHeaders(xhr, response, flag, properties, origin) {\n  var acaoStr = response.headers[\"access-control-allow-origin\"];\n  var acao = acaoStr ? acaoStr.trim() : null;\n\n  if (acao !== \"*\" && acao !== origin) {\n    properties.error = \"Cross origin \" + origin + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  var acacStr = response.headers[\"access-control-allow-credentials\"];\n  var acac = acacStr ? acacStr.trim() : null;\n\n  if (flag.withCredentials && acac !== \"true\") {\n    properties.error = \"Credentials forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction validCORSPreflightHeaders(xhr, response, flag, properties) {\n  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n    return false;\n  }\n\n  var acahStr = response.headers[\"access-control-allow-headers\"];\n  var acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);\n  var forbiddenHeaders = Object.keys(flag.requestHeaders).filter(function (header) {\n    var lcHeader = header.toLowerCase();\n    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);\n  });\n\n  if (forbiddenHeaders.length > 0) {\n    properties.error = \"Headers \" + forbiddenHeaders + \" forbidden\";\n    dispatchError(xhr);\n    return false;\n  }\n\n  return true;\n}\n\nfunction requestErrorSteps(xhr, event, exception) {\n  var properties = xhr[xhrSymbols.properties];\n  var flag = xhr[xhrSymbols.flag];\n  properties.readyState = xhr.DONE;\n  properties.send = false;\n  setResponseToNetworkError(xhr);\n\n  if (flag.synchronous) {\n    throw exception;\n  }\n\n  xhr.dispatchEvent(Event.create([\"readystatechange\"]));\n\n  if (!properties.uploadComplete) {\n    properties.uploadComplete = true;\n\n    if (properties.uploadListener) {\n      xhr.upload.dispatchEvent(ProgressEvent.create([event, {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      }]));\n      xhr.upload.dispatchEvent(ProgressEvent.create([\"loadend\", {\n        loaded: 0,\n        total: 0,\n        lengthComputable: false\n      }]));\n    }\n  }\n\n  xhr.dispatchEvent(ProgressEvent.create([event, {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  }]));\n  xhr.dispatchEvent(ProgressEvent.create([\"loadend\", {\n    loaded: 0,\n    total: 0,\n    lengthComputable: false\n  }]));\n}\n\nfunction setResponseToNetworkError(xhr) {\n  var properties = xhr[xhrSymbols.properties];\n  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;\n  properties.responseHeaders = {};\n  properties.status = 0;\n  properties.statusText = \"\";\n} // return a \"request\" client object or an event emitter matching the same behaviour for unsupported protocols\n// the callback should be called with a \"request\" response object or an event emitter matching the same behaviour too\n\n\nfunction createClient(xhr) {\n  var flag = xhr[xhrSymbols.flag];\n  var properties = xhr[xhrSymbols.properties];\n  var urlObj = new URL(flag.uri);\n  var uri = urlObj.href;\n  var ucMethod = flag.method.toUpperCase();\n  var requestManager = flag.requestManager;\n\n  if (urlObj.protocol === \"file:\") {\n    var response = new EventEmitter();\n    response.statusCode = 200;\n    response.rawHeaders = [];\n    response.headers = {};\n    response.request = {\n      uri: urlObj\n    };\n    var filePath = urlObj.pathname.replace(/^file:\\/\\//, \"\").replace(/^\\/([a-z]):\\//i, \"$1:/\").replace(/%20/g, \" \");\n\n    var _client = new EventEmitter();\n\n    var readableStream = fs.createReadStream(filePath, {\n      encoding: null\n    });\n    readableStream.on(\"data\", function (chunk) {\n      response.emit(\"data\", chunk);\n\n      _client.emit(\"data\", chunk);\n    });\n    readableStream.on(\"end\", function () {\n      response.emit(\"end\");\n\n      _client.emit(\"end\");\n    });\n    readableStream.on(\"error\", function (err) {\n      response.emit(\"error\", err);\n\n      _client.emit(\"error\", err);\n    });\n\n    _client.abort = function () {\n      readableStream.destroy();\n\n      _client.emit(\"abort\");\n    };\n\n    if (requestManager) {\n      var req = {\n        abort: function abort() {\n          properties.abortError = true;\n          xhr.abort();\n        }\n      };\n      requestManager.add(req);\n      var rmReq = requestManager.remove.bind(requestManager, req);\n\n      _client.on(\"abort\", rmReq);\n\n      _client.on(\"error\", rmReq);\n\n      _client.on(\"end\", rmReq);\n    }\n\n    process.nextTick(function () {\n      return _client.emit(\"response\", response);\n    });\n    return _client;\n  }\n\n  if (urlObj.protocol === \"data:\") {\n    var _response = new EventEmitter();\n\n    _response.request = {\n      uri: urlObj\n    };\n\n    var _client2 = new EventEmitter();\n\n    var buffer;\n\n    try {\n      var parsed = parseDataURL(uri);\n      var contentType = parsed.mimeType.toString();\n      buffer = parsed.body;\n      _response.statusCode = 200;\n      _response.rawHeaders = [\"Content-Type\", contentType];\n      _response.headers = {\n        \"content-type\": contentType\n      };\n    } catch (err) {\n      process.nextTick(function () {\n        return _client2.emit(\"error\", err);\n      });\n      return _client2;\n    }\n\n    _client2.abort = function () {// do nothing\n    };\n\n    process.nextTick(function () {\n      _client2.emit(\"response\", _response);\n\n      process.nextTick(function () {\n        _response.emit(\"data\", buffer);\n\n        _client2.emit(\"data\", buffer);\n\n        _response.emit(\"end\");\n\n        _client2.emit(\"end\");\n      });\n    });\n    return _client2;\n  }\n\n  var requestHeaders = {};\n\n  for (var header in flag.requestHeaders) {\n    requestHeaders[header] = flag.requestHeaders[header];\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"referer\") === null) {\n    requestHeaders.Referer = flag.referrer;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"user-agent\") === null) {\n    requestHeaders[\"User-Agent\"] = flag.userAgent;\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept-language\") === null) {\n    requestHeaders[\"Accept-Language\"] = \"en\";\n  }\n\n  if (getRequestHeader(flag.requestHeaders, \"accept\") === null) {\n    requestHeaders.Accept = \"*/*\";\n  }\n\n  var crossOrigin = flag.origin !== urlObj.origin;\n\n  if (crossOrigin) {\n    requestHeaders.Origin = flag.origin;\n  }\n\n  var options = {\n    uri: uri,\n    method: flag.method,\n    headers: requestHeaders,\n    gzip: true,\n    maxRedirects: 21,\n    followAllRedirects: true,\n    encoding: null,\n    pool: flag.pool,\n    agentOptions: flag.agentOptions,\n    strictSSL: flag.strictSSL\n  };\n\n  if (flag.auth) {\n    options.auth = {\n      user: flag.auth.user || \"\",\n      pass: flag.auth.pass || \"\",\n      sendImmediately: false\n    };\n  }\n\n  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {\n    options.jar = wrapCookieJarForRequest(flag.cookieJar);\n  }\n\n  if (flag.proxy) {\n    options.proxy = flag.proxy;\n  }\n\n  var body = flag.body;\n  var hasBody = body !== undefined && body !== null && body !== \"\" && !(ucMethod === \"HEAD\" || ucMethod === \"GET\");\n\n  if (hasBody && !flag.formData) {\n    options.body = body;\n  }\n\n  if (hasBody && getRequestHeader(flag.requestHeaders, \"content-type\") === null) {\n    requestHeaders[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n  }\n\n  function doRequest() {\n    try {\n      var _client3 = request(options);\n\n      if (hasBody && flag.formData) {\n        var form = _client3.form();\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var entry = _step.value;\n            form.append(entry.name, entry.value, entry.options);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return _client3;\n    } catch (e) {\n      var _client4 = new EventEmitter();\n\n      process.nextTick(function () {\n        return _client4.emit(\"error\", e);\n      });\n      return _client4;\n    }\n  }\n\n  var client;\n  var nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(function (header) {\n    return !simpleHeaders.has(header.toLowerCase());\n  });\n\n  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {\n    client = new EventEmitter();\n    var preflightRequestHeaders = [];\n\n    for (var _header in requestHeaders) {\n      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer\n      var lcHeader = _header.toLowerCase();\n\n      if (lcHeader === \"origin\" || lcHeader === \"referrer\") {\n        preflightRequestHeaders[_header] = requestHeaders[_header];\n      }\n    }\n\n    preflightRequestHeaders[\"Access-Control-Request-Method\"] = flag.method;\n\n    if (nonSimpleHeaders.length > 0) {\n      preflightRequestHeaders[\"Access-Control-Request-Headers\"] = nonSimpleHeaders.join(\", \");\n    }\n\n    preflightRequestHeaders[\"User-Agent\"] = flag.userAgent;\n    flag.preflight = true;\n    var preflightOptions = {\n      uri: uri,\n      method: \"OPTIONS\",\n      headers: preflightRequestHeaders,\n      followRedirect: false,\n      encoding: null,\n      pool: flag.pool,\n      agentOptions: flag.agentOptions,\n      strictSSL: flag.strictSSL\n    };\n\n    if (flag.proxy) {\n      preflightOptions.proxy = flag.proxy;\n    }\n\n    var preflightClient = request(preflightOptions);\n    preflightClient.on(\"response\", function (resp) {\n      // don't send the real request if the preflight request returned an error\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        client.emit(\"error\", new Error(\"Response for preflight has invalid HTTP status code \" + resp.statusCode));\n        return;\n      } // don't send the real request if we aren't allowed to use the headers\n\n\n      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {\n        setResponseToNetworkError(xhr);\n        return;\n      }\n\n      var realClient = doRequest();\n      realClient.on(\"response\", function (res) {\n        for (var _header2 in resp.headers) {\n          if (preflightHeaders.has(_header2)) {\n            res.headers[_header2] = Object.prototype.hasOwnProperty.call(res.headers, _header2) ? mergeHeaders(res.headers[_header2], resp.headers[_header2]) : resp.headers[_header2];\n          }\n        }\n\n        client.emit(\"response\", res);\n      });\n      realClient.on(\"data\", function (chunk) {\n        return client.emit(\"data\", chunk);\n      });\n      realClient.on(\"end\", function () {\n        return client.emit(\"end\");\n      });\n      realClient.on(\"abort\", function () {\n        return client.emit(\"abort\");\n      });\n      realClient.on(\"request\", function (req) {\n        client.headers = realClient.headers;\n        client.emit(\"request\", req);\n      });\n      realClient.on(\"redirect\", function () {\n        client.response = realClient.response;\n        client.emit(\"redirect\");\n      });\n      realClient.on(\"error\", function (err) {\n        return client.emit(\"error\", err);\n      });\n\n      client.abort = function () {\n        realClient.abort();\n      };\n    });\n    preflightClient.on(\"error\", function (err) {\n      return client.emit(\"error\", err);\n    });\n\n    client.abort = function () {\n      preflightClient.abort();\n    };\n  } else {\n    client = doRequest();\n  }\n\n  if (requestManager) {\n    var _req = {\n      abort: function abort() {\n        properties.abortError = true;\n        xhr.abort();\n      }\n    };\n    requestManager.add(_req);\n\n    var _rmReq = requestManager.remove.bind(requestManager, _req);\n\n    client.on(\"abort\", _rmReq);\n    client.on(\"error\", _rmReq);\n    client.on(\"end\", _rmReq);\n  }\n\n  return client;\n}\n\nexports.headerListSeparatorRegexp = headerListSeparatorRegexp;\nexports.simpleHeaders = simpleHeaders;\nexports.preflightHeaders = preflightHeaders;\nexports.wrapCookieJarForRequest = wrapCookieJarForRequest;\nexports.getRequestHeader = getRequestHeader;\nexports.updateRequestHeader = updateRequestHeader;\nexports.dispatchError = dispatchError;\nexports.validCORSHeaders = validCORSHeaders;\nexports.requestErrorSteps = requestErrorSteps;\nexports.setResponseToNetworkError = setResponseToNetworkError;\nexports.createClient = createClient;","map":null,"metadata":{},"sourceType":"script"}