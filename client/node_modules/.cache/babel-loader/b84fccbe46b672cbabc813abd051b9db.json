{"ast":null,"code":"'use strict';\n\nvar acorn = require('acorn');\n\nvar walk = require('acorn-walk');\n\nfunction isScope(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration' || node.type === 'ArrowFunctionExpression' || node.type === 'Program';\n}\n\nfunction isBlockScope(node) {\n  return node.type === 'BlockStatement' || isScope(node);\n}\n\nfunction declaresArguments(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction declaresThis(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\nfunction reallyParse(source, options) {\n  var parseOptions = Object.assign({}, options, {\n    allowReturnOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowHashBang: true\n  });\n  return acorn.parse(source, parseOptions);\n}\n\nmodule.exports = findGlobals;\nmodule.exports.parse = reallyParse;\n\nfunction findGlobals(source, options) {\n  options = options || {};\n  var globals = [];\n  var ast; // istanbul ignore else\n\n  if (typeof source === 'string') {\n    ast = reallyParse(source, options);\n  } else {\n    ast = source;\n  } // istanbul ignore if\n\n\n  if (!(ast && typeof ast === 'object' && ast.type === 'Program')) {\n    throw new TypeError('Source must be either a string of JavaScript or an acorn AST');\n  }\n\n  var declareFunction = function declareFunction(node) {\n    var fn = node;\n    fn.locals = fn.locals || {};\n    node.params.forEach(function (node) {\n      declarePattern(node, fn);\n    });\n\n    if (node.id) {\n      fn.locals[node.id.name] = true;\n    }\n  };\n\n  var declarePattern = function declarePattern(node, parent) {\n    switch (node.type) {\n      case 'Identifier':\n        parent.locals[node.name] = true;\n        break;\n\n      case 'ObjectPattern':\n        node.properties.forEach(function (node) {\n          declarePattern(node.value || node.argument, parent);\n        });\n        break;\n\n      case 'ArrayPattern':\n        node.elements.forEach(function (node) {\n          if (node) declarePattern(node, parent);\n        });\n        break;\n\n      case 'RestElement':\n        declarePattern(node.argument, parent);\n        break;\n\n      case 'AssignmentPattern':\n        declarePattern(node.left, parent);\n        break;\n      // istanbul ignore next\n\n      default:\n        throw new Error('Unrecognized pattern type: ' + node.type);\n    }\n  };\n\n  var declareModuleSpecifier = function declareModuleSpecifier(node, parents) {\n    ast.locals = ast.locals || {};\n    ast.locals[node.local.name] = true;\n  };\n\n  walk.ancestor(ast, {\n    'VariableDeclaration': function VariableDeclaration(node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 1; i >= 0 && parent === null; i--) {\n        if (node.kind === 'var' ? isScope(parents[i]) : isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || {};\n      node.declarations.forEach(function (declaration) {\n        declarePattern(declaration.id, parent);\n      });\n    },\n    'FunctionDeclaration': function FunctionDeclaration(node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || {};\n\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n\n      declareFunction(node);\n    },\n    'Function': declareFunction,\n    'ClassDeclaration': function ClassDeclaration(node, parents) {\n      var parent = null;\n\n      for (var i = parents.length - 2; i >= 0 && parent === null; i--) {\n        if (isBlockScope(parents[i])) {\n          parent = parents[i];\n        }\n      }\n\n      parent.locals = parent.locals || {};\n\n      if (node.id) {\n        parent.locals[node.id.name] = true;\n      }\n    },\n    'TryStatement': function TryStatement(node) {\n      if (node.handler === null) return;\n      node.handler.locals = node.handler.locals || {};\n      node.handler.locals[node.handler.param.name] = true;\n    },\n    'ImportDefaultSpecifier': declareModuleSpecifier,\n    'ImportSpecifier': declareModuleSpecifier,\n    'ImportNamespaceSpecifier': declareModuleSpecifier\n  });\n\n  function identifier(node, parents) {\n    var name = node.name;\n    if (name === 'undefined') return;\n\n    for (var i = 0; i < parents.length; i++) {\n      if (name === 'arguments' && declaresArguments(parents[i])) {\n        return;\n      }\n\n      if (parents[i].locals && name in parents[i].locals) {\n        return;\n      }\n    }\n\n    node.parents = parents.slice();\n    globals.push(node);\n  }\n\n  walk.ancestor(ast, {\n    'VariablePattern': identifier,\n    'Identifier': identifier,\n    'ThisExpression': function ThisExpression(node, parents) {\n      for (var i = 0; i < parents.length; i++) {\n        if (declaresThis(parents[i])) {\n          return;\n        }\n      }\n\n      node.parents = parents.slice();\n      globals.push(node);\n    }\n  });\n  var groupedGlobals = {};\n  globals.forEach(function (node) {\n    var name = node.type === 'ThisExpression' ? 'this' : node.name;\n    groupedGlobals[name] = groupedGlobals[name] || [];\n    groupedGlobals[name].push(node);\n  });\n  return Object.keys(groupedGlobals).sort().map(function (name) {\n    return {\n      name: name,\n      nodes: groupedGlobals[name]\n    };\n  });\n}","map":null,"metadata":{},"sourceType":"script"}