{"ast":null,"code":"'use strict';\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SymbolTreeNode = require('./SymbolTreeNode');\n\nvar TreePosition = require('./TreePosition');\n\nvar TreeIterator = require('./TreeIterator');\n\nfunction returnTrue() {\n  return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n  return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nvar SymbolTree =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @alias module:symbol-tree\n   * @param {string} [description='SymbolTree data'] Description used for the Symbol\n   */\n  function SymbolTree(description) {\n    _classCallCheck(this, SymbolTree);\n\n    this.symbol = Symbol(description || 'SymbolTree data');\n  }\n  /**\n   * You can use this function to (optionally) initialize an object right after its creation,\n   * to take advantage of V8's fast properties. Also useful if you would like to\n   * freeze your object.\n   *\n   * `O(1)`\n   *\n   * @method\n   * @alias module:symbol-tree#initialize\n   * @param {Object} object\n   * @return {Object} object\n   */\n\n\n  _createClass(SymbolTree, [{\n    key: \"initialize\",\n    value: function initialize(object) {\n      this._node(object);\n\n      return object;\n    }\n  }, {\n    key: \"_node\",\n    value: function _node(object) {\n      if (!object) {\n        return null;\n      }\n\n      var node = object[this.symbol];\n\n      if (node) {\n        return node;\n      }\n\n      return object[this.symbol] = new SymbolTreeNode();\n    }\n    /**\n     * Returns `true` if the object has any children. Otherwise it returns `false`.\n     *\n     * * `O(1)`\n     *\n     * @method hasChildren\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren(object) {\n      return this._node(object).hasChildren;\n    }\n    /**\n     * Returns the first child of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method firstChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"firstChild\",\n    value: function firstChild(object) {\n      return this._node(object).firstChild;\n    }\n    /**\n     * Returns the last child of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method lastChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"lastChild\",\n    value: function lastChild(object) {\n      return this._node(object).lastChild;\n    }\n    /**\n     * Returns the previous sibling of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method previousSibling\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"previousSibling\",\n    value: function previousSibling(object) {\n      return this._node(object).previousSibling;\n    }\n    /**\n     * Returns the next sibling of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method nextSibling\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"nextSibling\",\n    value: function nextSibling(object) {\n      return this._node(object).nextSibling;\n    }\n    /**\n     * Return the parent of the given object.\n     *\n     * * `O(1)`\n     *\n     * @method parent\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent(object) {\n      return this._node(object).parent;\n    }\n    /**\n     * Find the inclusive descendant that is last in tree order of the given object.\n     *\n     * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n     *\n     * @method lastInclusiveDescendant\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object}\n     */\n\n  }, {\n    key: \"lastInclusiveDescendant\",\n    value: function lastInclusiveDescendant(object) {\n      var lastChild;\n      var current = object;\n\n      while (lastChild = this._node(current).lastChild) {\n        current = lastChild;\n      }\n\n      return current;\n    }\n    /**\n     * Find the preceding object (A) of the given object (B).\n     * An object A is preceding an object B if A and B are in the same tree\n     * and A comes before B in tree order.\n     *\n     * * `O(n)` (worst case)\n     * * `O(1)` (amortized when walking the entire tree)\n     *\n     * @method preceding\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @param {Object} [options]\n     * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n     *        of the return value (or else null is returned). This check _assumes_\n     *        that `root` is also an inclusive ancestor of the given `object`\n     * @return {?Object}\n     */\n\n  }, {\n    key: \"preceding\",\n    value: function preceding(object, options) {\n      var treeRoot = options && options.root;\n\n      if (object === treeRoot) {\n        return null;\n      }\n\n      var previousSibling = this._node(object).previousSibling;\n\n      if (previousSibling) {\n        return this.lastInclusiveDescendant(previousSibling);\n      } // if there is no previous sibling return the parent (might be null)\n\n\n      return this._node(object).parent;\n    }\n    /**\n     * Find the following object (A) of the given object (B).\n     * An object A is following an object B if A and B are in the same tree\n     * and A comes after B in tree order.\n     *\n     * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n     * * `O(1)` (amortized when walking the entire tree)\n     *\n     * @method following\n     * @memberOf module:symbol-tree#\n     * @param {!Object} object\n     * @param {Object} [options]\n     * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n     *        of the return value (or else null is returned). This check _assumes_\n     *        that `root` is also an inclusive ancestor of the given `object`\n     * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n     * @return {?Object}\n     */\n\n  }, {\n    key: \"following\",\n    value: function following(object, options) {\n      var treeRoot = options && options.root;\n      var skipChildren = options && options.skipChildren;\n\n      var firstChild = !skipChildren && this._node(object).firstChild;\n\n      if (firstChild) {\n        return firstChild;\n      }\n\n      var current = object;\n\n      do {\n        if (current === treeRoot) {\n          return null;\n        }\n\n        var nextSibling = this._node(current).nextSibling;\n\n        if (nextSibling) {\n          return nextSibling;\n        }\n\n        current = this._node(current).parent;\n      } while (current);\n\n      return null;\n    }\n    /**\n     * Append all children of the given object to an array.\n     *\n     * * `O(n)` where `n` is the amount of children of the given `parent`\n     *\n     * @method childrenToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"childrenToArray\",\n    value: function childrenToArray(parent, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n\n      var parentNode = this._node(parent);\n\n      var object = parentNode.firstChild;\n      var index = 0;\n\n      while (object) {\n        var node = this._node(object);\n\n        node.setCachedIndex(parentNode, index);\n\n        if (filter.call(thisArg, object)) {\n          array.push(object);\n        }\n\n        object = node.nextSibling;\n        ++index;\n      }\n\n      return array;\n    }\n    /**\n     * Append all inclusive ancestors of the given object to an array.\n     *\n     * * `O(n)` where `n` is the amount of ancestors of the given `object`\n     *\n     * @method ancestorsToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"ancestorsToArray\",\n    value: function ancestorsToArray(object, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n      var ancestor = object;\n\n      while (ancestor) {\n        if (filter.call(thisArg, ancestor)) {\n          array.push(ancestor);\n        }\n\n        ancestor = this._node(ancestor).parent;\n      }\n\n      return array;\n    }\n    /**\n     * Append all descendants of the given object to an array (in tree order).\n     *\n     * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n     *\n     * @method treeToArray\n     * @memberOf module:symbol-tree#\n     * @param {Object} root\n     * @param {Object} [options]\n     * @param {Object[]} [options.array=[]]\n     * @param {Function} [options.filter] Function to test each object before it is added to the array.\n     *                            Invoked with arguments (object). Should return `true` if an object\n     *                            is to be included.\n     * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n     * @return {Object[]}\n     */\n\n  }, {\n    key: \"treeToArray\",\n    value: function treeToArray(root, options) {\n      var array = options && options.array || [];\n      var filter = options && options.filter || returnTrue;\n      var thisArg = options && options.thisArg || undefined;\n      var object = root;\n\n      while (object) {\n        if (filter.call(thisArg, object)) {\n          array.push(object);\n        }\n\n        object = this.following(object, {\n          root: root\n        });\n      }\n\n      return array;\n    }\n    /**\n     * Iterate over all children of the given object\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method childrenIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @param {Object} [options]\n     * @param {Boolean} [options.reverse=false]\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"childrenIterator\",\n    value: function childrenIterator(parent, options) {\n      var reverse = options && options.reverse;\n\n      var parentNode = this._node(parent);\n\n      return new TreeIterator(this, parent, reverse ? parentNode.lastChild : parentNode.firstChild, reverse ? TreeIterator.PREV : TreeIterator.NEXT);\n    }\n    /**\n     * Iterate over all the previous siblings of the given object. (in reverse tree order)\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method previousSiblingsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"previousSiblingsIterator\",\n    value: function previousSiblingsIterator(object) {\n      return new TreeIterator(this, object, this._node(object).previousSibling, TreeIterator.PREV);\n    }\n    /**\n     * Iterate over all the next siblings of the given object. (in tree order)\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method nextSiblingsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"nextSiblingsIterator\",\n    value: function nextSiblingsIterator(object) {\n      return new TreeIterator(this, object, this._node(object).nextSibling, TreeIterator.NEXT);\n    }\n    /**\n     * Iterate over all inclusive ancestors of the given object\n     *\n     * * `O(1)` for a single iteration\n     *\n     * @method ancestorsIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} object\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"ancestorsIterator\",\n    value: function ancestorsIterator(object) {\n      return new TreeIterator(this, object, object, TreeIterator.PARENT);\n    }\n    /**\n     * Iterate over all descendants of the given object (in tree order).\n     *\n     * Where `n` is the amount of objects in the sub-tree of the given `root`:\n     *\n     * * `O(n)` (worst case for a single iteration)\n     * * `O(n)` (amortized, when completing the iterator)\n     *\n     * @method treeIterator\n     * @memberOf module:symbol-tree#\n     * @param {Object} root\n     * @param {Object} options\n     * @param {Boolean} [options.reverse=false]\n     * @return {Object} An iterable iterator (ES6)\n     */\n\n  }, {\n    key: \"treeIterator\",\n    value: function treeIterator(root, options) {\n      var reverse = options && options.reverse;\n      return new TreeIterator(this, root, reverse ? this.lastInclusiveDescendant(root) : root, reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING);\n    }\n    /**\n     * Find the index of the given object (the number of preceding siblings).\n     *\n     * * `O(n)` where `n` is the amount of preceding siblings\n     * * `O(1)` (amortized, if the tree is not modified)\n     *\n     * @method index\n     * @memberOf module:symbol-tree#\n     * @param {Object} child\n     * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n     */\n\n  }, {\n    key: \"index\",\n    value: function index(child) {\n      var childNode = this._node(child);\n\n      var parentNode = this._node(childNode.parent);\n\n      if (!parentNode) {\n        // In principal, you could also find out the number of preceding siblings\n        // for objects that do not have a parent. This method limits itself only to\n        // objects that have a parent because that lets us optimize more.\n        return -1;\n      }\n\n      var currentIndex = childNode.getCachedIndex(parentNode);\n\n      if (currentIndex >= 0) {\n        return currentIndex;\n      }\n\n      currentIndex = 0;\n      var object = parentNode.firstChild;\n\n      if (parentNode.childIndexCachedUpTo) {\n        var cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n\n        object = cachedUpToNode.nextSibling;\n        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n      }\n\n      while (object) {\n        var node = this._node(object);\n\n        node.setCachedIndex(parentNode, currentIndex);\n\n        if (object === child) {\n          break;\n        }\n\n        ++currentIndex;\n        object = node.nextSibling;\n      }\n\n      parentNode.childIndexCachedUpTo = child;\n      return currentIndex;\n    }\n    /**\n     * Calculate the number of children.\n     *\n     * * `O(n)` where `n` is the amount of children\n     * * `O(1)` (amortized, if the tree is not modified)\n     *\n     * @method childrenCount\n     * @memberOf module:symbol-tree#\n     * @param {Object} parent\n     * @return {Number}\n     */\n\n  }, {\n    key: \"childrenCount\",\n    value: function childrenCount(parent) {\n      var parentNode = this._node(parent);\n\n      if (!parentNode.lastChild) {\n        return 0;\n      }\n\n      return this.index(parentNode.lastChild) + 1;\n    }\n    /**\n     * Compare the position of an object relative to another object. A bit set is returned:\n     *\n     * <ul>\n     *     <li>DISCONNECTED : 1</li>\n     *     <li>PRECEDING : 2</li>\n     *     <li>FOLLOWING : 4</li>\n     *     <li>CONTAINS : 8</li>\n     *     <li>CONTAINED_BY : 16</li>\n     * </ul>\n     *\n     * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n     * DISCONNECTED never occurs with any other bit.\n     *\n     * where `n` and `m` are the amount of ancestors of `left` and `right`;\n     * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n     *\n     * * `O(n + m + o)` (worst case)\n     * * `O(n + m)` (amortized, if the tree is not modified)\n     *\n     * @method compareTreePosition\n     * @memberOf module:symbol-tree#\n     * @param {Object} left\n     * @param {Object} right\n     * @return {Number}\n     */\n\n  }, {\n    key: \"compareTreePosition\",\n    value: function compareTreePosition(left, right) {\n      // In DOM terms:\n      // left = reference / context object\n      // right = other\n      if (left === right) {\n        return 0;\n      }\n      /* jshint -W016 */\n\n\n      var leftAncestors = [];\n      {\n        // inclusive\n        var leftAncestor = left;\n\n        while (leftAncestor) {\n          if (leftAncestor === right) {\n            return TreePosition.CONTAINS | TreePosition.PRECEDING; // other is ancestor of reference\n          }\n\n          leftAncestors.push(leftAncestor);\n          leftAncestor = this.parent(leftAncestor);\n        }\n      }\n      var rightAncestors = [];\n      {\n        var rightAncestor = right;\n\n        while (rightAncestor) {\n          if (rightAncestor === left) {\n            return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n          }\n\n          rightAncestors.push(rightAncestor);\n          rightAncestor = this.parent(rightAncestor);\n        }\n      }\n      var root = reverseArrayIndex(leftAncestors, 0);\n\n      if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n        // note: unlike DOM, preceding / following is not set here\n        return TreePosition.DISCONNECTED;\n      } // find the lowest common ancestor\n\n\n      var commonAncestorIndex = 0;\n      var ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n      for (var i = 0; i < ancestorsMinLength; ++i) {\n        var _leftAncestor = reverseArrayIndex(leftAncestors, i);\n\n        var _rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n        if (_leftAncestor !== _rightAncestor) {\n          break;\n        }\n\n        commonAncestorIndex = i;\n      } // indexes within the common ancestor\n\n\n      var leftIndex = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n      var rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n      return rightIndex < leftIndex ? TreePosition.PRECEDING : TreePosition.FOLLOWING;\n    }\n    /**\n     * Remove the object from this tree.\n     * Has no effect if already removed.\n     *\n     * * `O(1)`\n     *\n     * @method remove\n     * @memberOf module:symbol-tree#\n     * @param {Object} removeObject\n     * @return {Object} removeObject\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(removeObject) {\n      var removeNode = this._node(removeObject);\n\n      var parentNode = this._node(removeNode.parent);\n\n      var prevNode = this._node(removeNode.previousSibling);\n\n      var nextNode = this._node(removeNode.nextSibling);\n\n      if (parentNode) {\n        if (parentNode.firstChild === removeObject) {\n          parentNode.firstChild = removeNode.nextSibling;\n        }\n\n        if (parentNode.lastChild === removeObject) {\n          parentNode.lastChild = removeNode.previousSibling;\n        }\n      }\n\n      if (prevNode) {\n        prevNode.nextSibling = removeNode.nextSibling;\n      }\n\n      if (nextNode) {\n        nextNode.previousSibling = removeNode.previousSibling;\n      }\n\n      removeNode.parent = null;\n      removeNode.previousSibling = null;\n      removeNode.nextSibling = null;\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return removeObject;\n    }\n    /**\n     * Insert the given object before the reference object.\n     * `newObject` is now the previous sibling of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method insertBefore\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var prevNode = this._node(referenceNode.previousSibling);\n\n      var newNode = this._node(newObject);\n\n      var parentNode = this._node(referenceNode.parent);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      newNode.parent = referenceNode.parent;\n      newNode.previousSibling = referenceNode.previousSibling;\n      newNode.nextSibling = referenceObject;\n      referenceNode.previousSibling = newObject;\n\n      if (prevNode) {\n        prevNode.nextSibling = newObject;\n      }\n\n      if (parentNode && parentNode.firstChild === referenceObject) {\n        parentNode.firstChild = newObject;\n      }\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object after the reference object.\n     * `newObject` is now the next sibling of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method insertAfter\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var nextNode = this._node(referenceNode.nextSibling);\n\n      var newNode = this._node(newObject);\n\n      var parentNode = this._node(referenceNode.parent);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      newNode.parent = referenceNode.parent;\n      newNode.previousSibling = referenceObject;\n      newNode.nextSibling = referenceNode.nextSibling;\n      referenceNode.nextSibling = newObject;\n\n      if (nextNode) {\n        nextNode.previousSibling = newObject;\n      }\n\n      if (parentNode && parentNode.lastChild === referenceObject) {\n        parentNode.lastChild = newObject;\n      }\n\n      if (parentNode) {\n        parentNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object as the first child of the given reference object.\n     * `newObject` is now the first child of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method prependChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"prependChild\",\n    value: function prependChild(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var newNode = this._node(newObject);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      if (referenceNode.hasChildren) {\n        this.insertBefore(referenceNode.firstChild, newObject);\n      } else {\n        newNode.parent = referenceObject;\n        referenceNode.firstChild = newObject;\n        referenceNode.lastChild = newObject;\n        referenceNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n    /**\n     * Insert the given object as the last child of the given reference object.\n     * `newObject` is now the last child of `referenceObject`.\n     *\n     * * `O(1)`\n     *\n     * @method appendChild\n     * @memberOf module:symbol-tree#\n     * @param {Object} referenceObject\n     * @param {Object} newObject\n     * @throws {Error} If the newObject is already present in this SymbolTree\n     * @return {Object} newObject\n     */\n\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(referenceObject, newObject) {\n      var referenceNode = this._node(referenceObject);\n\n      var newNode = this._node(newObject);\n\n      if (newNode.isAttached) {\n        throw Error('Given object is already present in this SymbolTree, remove it first');\n      }\n\n      if (referenceNode.hasChildren) {\n        this.insertAfter(referenceNode.lastChild, newObject);\n      } else {\n        newNode.parent = referenceObject;\n        referenceNode.firstChild = newObject;\n        referenceNode.lastChild = newObject;\n        referenceNode.childrenChanged();\n      }\n\n      return newObject;\n    }\n  }]);\n\n  return SymbolTree;\n}();\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;","map":null,"metadata":{},"sourceType":"script"}