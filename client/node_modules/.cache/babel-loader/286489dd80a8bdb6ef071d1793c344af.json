{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _inherits = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar HTTP_STATUS_CODES = require(\"http\").STATUS_CODES;\n\nvar _require = require(\"child_process\"),\n    spawnSync = _require.spawnSync;\n\nvar _require2 = require(\"whatwg-url\"),\n    URL = _require2.URL;\n\nvar whatwgEncoding = require(\"whatwg-encoding\");\n\nvar tough = require(\"tough-cookie\");\n\nvar MIMEType = require(\"whatwg-mimetype\");\n\nvar conversions = require(\"webidl-conversions\");\n\nvar xhrUtils = require(\"./xhr-utils\");\n\nvar DOMException = require(\"domexception\");\n\nvar xhrSymbols = require(\"./xmlhttprequest-symbols\");\n\nvar _require3 = require(\"../utils\"),\n    addConstants = _require3.addConstants;\n\nvar _require4 = require(\"./helpers/document-base-url\"),\n    documentBaseURLSerialized = _require4.documentBaseURLSerialized;\n\nvar _require5 = require(\"./helpers/strings\"),\n    asciiCaseInsensitiveMatch = _require5.asciiCaseInsensitiveMatch;\n\nvar idlUtils = require(\"./generated/utils\");\n\nvar Document = require(\"./generated/Document\");\n\nvar Blob = require(\"./generated/Blob\");\n\nvar FormData = require(\"./generated/FormData\");\n\nvar XMLHttpRequestEventTarget = require(\"./generated/XMLHttpRequestEventTarget\");\n\nvar XMLHttpRequestUpload = require(\"./generated/XMLHttpRequestUpload\");\n\nvar _require6 = require(\"../browser/domtohtml\"),\n    domToHtml = _require6.domToHtml;\n\nvar _require7 = require(\"./helpers/create-event-accessor\"),\n    setupForSimpleEventAccessors = _require7.setupForSimpleEventAccessors;\n\nvar _require8 = require(\"./helpers/json\"),\n    parseJSONFromBytes = _require8.parseJSONFromBytes;\n\nvar syncWorkerFile = require.resolve ? require.resolve(\"./xhr-sync-worker.js\") : null;\nvar tokenRegexp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\nvar fieldValueRegexp = /^[ \\t]*(?:[\\x21-\\x7E\\x80-\\xFF](?:[ \\t][\\x21-\\x7E\\x80-\\xFF])?)*[ \\t]*$/;\nvar forbiddenRequestHeaders = new Set([\"accept-charset\", \"accept-encoding\", \"access-control-request-headers\", \"access-control-request-method\", \"connection\", \"content-length\", \"cookie\", \"cookie2\", \"date\", \"dnt\", \"expect\", \"host\", \"keep-alive\", \"origin\", \"referer\", \"te\", \"trailer\", \"transfer-encoding\", \"upgrade\", \"via\"]);\nvar forbiddenResponseHeaders = new Set([\"set-cookie\", \"set-cookie2\"]);\nvar uniqueResponseHeaders = new Set([\"content-type\", \"content-length\", \"user-agent\", \"referer\", \"host\", \"authorization\", \"proxy-authorization\", \"if-modified-since\", \"if-unmodified-since\", \"from\", \"location\", \"max-forwards\"]);\nvar corsSafeResponseHeaders = new Set([\"cache-control\", \"content-language\", \"content-type\", \"expires\", \"last-modified\", \"pragma\"]);\nvar allowedRequestMethods = new Set([\"OPTIONS\", \"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\"]);\nvar forbiddenRequestMethods = new Set([\"TRACK\", \"TRACE\", \"CONNECT\"]);\nvar XMLHttpRequestResponseType = new Set([\"\", \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"]);\n\nmodule.exports = function createXMLHttpRequest(window) {\n  var Event = window.Event,\n      ProgressEvent = window.ProgressEvent;\n\n  var XMLHttpRequest =\n  /*#__PURE__*/\n  function (_XMLHttpRequestEventT) {\n    _inherits(XMLHttpRequest, _XMLHttpRequestEventT);\n\n    function XMLHttpRequest() {\n      var _this;\n\n      _classCallCheck(this, XMLHttpRequest);\n\n      // eslint-disable-line constructor-super\n      var theThis = Object.create((this instanceof XMLHttpRequest ? this.constructor : void 0).prototype);\n      XMLHttpRequestEventTarget.setup(theThis);\n      theThis.upload = XMLHttpRequestUpload.create();\n      theThis.upload._ownerDocument = window.document;\n      theThis[xhrSymbols.flag] = {\n        synchronous: false,\n        withCredentials: false,\n        mimeType: null,\n        auth: null,\n        method: undefined,\n        responseType: \"\",\n        requestHeaders: {},\n        referrer: theThis._ownerDocument.URL,\n        uri: \"\",\n        timeout: 0,\n        body: undefined,\n        formData: false,\n        preflight: false,\n        requestManager: theThis._ownerDocument._requestManager,\n        pool: theThis._ownerDocument._pool,\n        agentOptions: theThis._ownerDocument._agentOptions,\n        strictSSL: theThis._ownerDocument._strictSSL,\n        proxy: theThis._ownerDocument._proxy,\n        cookieJar: theThis._ownerDocument._cookieJar,\n        encoding: theThis._ownerDocument._encoding,\n        origin: theThis._ownerDocument.origin,\n        userAgent: window.navigator.userAgent\n      };\n      theThis[xhrSymbols.properties] = {\n        beforeSend: false,\n        send: false,\n        timeoutStart: 0,\n        timeoutId: 0,\n        timeoutFn: null,\n        client: null,\n        responseHeaders: {},\n        filteredResponseHeaders: [],\n        responseBuffer: null,\n        responseCache: null,\n        responseTextCache: null,\n        responseXMLCache: null,\n        responseURL: \"\",\n        readyState: XMLHttpRequest.UNSENT,\n        status: 0,\n        statusText: \"\",\n        error: \"\",\n        uploadComplete: false,\n        uploadListener: false,\n        // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.\n        // In that case the termination reason is \"fatal\", not \"end-user abort\".\n        abortError: false,\n        cookieJar: theThis._ownerDocument._cookieJar,\n        bufferStepSize: 1 * 1024 * 1024,\n        // pre-allocate buffer increase step size. init value is 1MB\n        totalReceivedChunkSize: 0\n      };\n      return _possibleConstructorReturn(_this, theThis);\n    }\n\n    _createClass(XMLHttpRequest, [{\n      key: \"abort\",\n      value: function abort() {\n        var properties = this[xhrSymbols.properties]; // Terminate the request\n\n        clearTimeout(properties.timeoutId);\n        properties.timeoutFn = null;\n        properties.timeoutStart = 0;\n        var client = properties.client;\n\n        if (client) {\n          client.abort();\n          properties.client = null;\n        }\n\n        if (properties.abortError) {\n          // Special case that ideally shouldn't be going through the public API at all.\n          // Run the https://xhr.spec.whatwg.org/#handle-errors \"fatal\" steps.\n          properties.readyState = XMLHttpRequest.DONE;\n          properties.send = false;\n          xhrUtils.setResponseToNetworkError(this);\n          return;\n        }\n\n        if (this.readyState === XMLHttpRequest.OPENED && properties.send || this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {\n          xhrUtils.requestErrorSteps(this, \"abort\");\n        }\n\n        if (this.readyState === XMLHttpRequest.DONE) {\n          properties.readyState = XMLHttpRequest.UNSENT;\n          xhrUtils.setResponseToNetworkError(this);\n        }\n      }\n    }, {\n      key: \"getAllResponseHeaders\",\n      value: function getAllResponseHeaders() {\n        var properties = this[xhrSymbols.properties];\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n          return \"\";\n        }\n\n        return Object.keys(properties.responseHeaders).filter(function (key) {\n          return properties.filteredResponseHeaders.indexOf(key) === -1;\n        }).map(function (key) {\n          return [conversions.ByteString(key).toLowerCase(), properties.responseHeaders[key]].join(\": \");\n        }).join(\"\\r\\n\");\n      }\n    }, {\n      key: \"getResponseHeader\",\n      value: function getResponseHeader(header) {\n        var properties = this[xhrSymbols.properties];\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.UNSENT || readyState === XMLHttpRequest.OPENED) {\n          return null;\n        }\n\n        var lcHeader = conversions.ByteString(header).toLowerCase();\n\n        if (properties.filteredResponseHeaders.find(function (filtered) {\n          return lcHeader === filtered.toLowerCase();\n        })) {\n          return null;\n        }\n\n        return _getResponseHeader(this, lcHeader);\n      }\n    }, {\n      key: \"open\",\n      value: function open(method, uri, asynchronous, user, password) {\n        if (!this._ownerDocument) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n        var argumentCount = arguments.length;\n\n        if (argumentCount < 2) {\n          throw new TypeError(\"Not enough arguments (expected at least 2)\");\n        }\n\n        method = conversions.ByteString(method);\n        uri = conversions.USVString(uri);\n\n        if (user) {\n          user = conversions.USVString(user);\n        }\n\n        if (password) {\n          password = conversions.USVString(password);\n        }\n\n        if (!tokenRegexp.test(method)) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        var upperCaseMethod = method.toUpperCase();\n\n        if (forbiddenRequestMethods.has(upperCaseMethod)) {\n          throw new DOMException(\"The operation is insecure.\", \"SecurityError\");\n        }\n\n        var client = properties.client;\n\n        if (client && typeof client.abort === \"function\") {\n          client.abort();\n        }\n\n        if (allowedRequestMethods.has(upperCaseMethod)) {\n          method = upperCaseMethod;\n        }\n\n        if (typeof asynchronous !== \"undefined\") {\n          flag.synchronous = !asynchronous;\n        } else {\n          flag.synchronous = false;\n        }\n\n        if (flag.responseType && flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        if (flag.synchronous && flag.timeout) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        flag.method = method;\n        var urlObj;\n\n        try {\n          urlObj = new URL(uri, documentBaseURLSerialized(this._ownerDocument));\n        } catch (e) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        if (user || password && !urlObj.username) {\n          flag.auth = {\n            user: user,\n            pass: password\n          };\n          urlObj.username = \"\";\n          urlObj.password = \"\";\n        }\n\n        flag.uri = urlObj.href;\n        flag.requestHeaders = {};\n        flag.preflight = false;\n        properties.send = false;\n        properties.uploadListener = false;\n        properties.requestBuffer = null;\n        properties.requestCache = null;\n        properties.abortError = false;\n        properties.responseURL = \"\";\n        readyStateChange(this, XMLHttpRequest.OPENED);\n      }\n    }, {\n      key: \"overrideMimeType\",\n      value: function overrideMimeType(mime) {\n        mime = String(mime);\n        var readyState = this.readyState;\n\n        if (readyState === XMLHttpRequest.LOADING || readyState === XMLHttpRequest.DONE) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        this[xhrSymbols.flag].overrideMIMEType = \"application/octet-stream\"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157\n\n        var parsed = MIMEType.parse(mime);\n\n        if (parsed) {\n          this[xhrSymbols.flag].overrideMIMEType = parsed.essence;\n          var charset = parsed.parameters.get(\"charset\");\n\n          if (charset) {\n            this[xhrSymbols.flag].overrideCharset = whatwgEncoding.labelToName(charset);\n          }\n        }\n      }\n    }, {\n      key: \"send\",\n      value: function send(body) {\n        var _this2 = this;\n\n        body = coerceBodyArg(body); // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65\n\n        if (!this._ownerDocument) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        properties.beforeSend = true;\n\n        try {\n          if (flag.method === \"GET\" || flag.method === \"HEAD\") {\n            body = null;\n          }\n\n          if (body !== null) {\n            var encoding = null;\n            var mimeType = null;\n\n            if (Document.isImpl(body)) {\n              encoding = \"UTF-8\";\n              mimeType = (body._parsingMode === \"html\" ? \"text/html\" : \"application/xml\") + \";charset=UTF-8\";\n              flag.body = domToHtml([body]);\n            } else {\n              if (typeof body === \"string\") {\n                encoding = \"UTF-8\";\n              }\n\n              var _extractBody = extractBody(body),\n                  buffer = _extractBody.buffer,\n                  formData = _extractBody.formData,\n                  contentType = _extractBody.contentType;\n\n              mimeType = contentType;\n              flag.body = buffer || formData;\n              flag.formData = Boolean(formData);\n            }\n\n            var existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, \"content-type\");\n\n            if (mimeType !== null && existingContentType === null) {\n              flag.requestHeaders[\"Content-Type\"] = mimeType;\n            } else if (existingContentType !== null && encoding !== null) {\n              // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what\n              // the spec will be, in the meantime.\n              var parsed = MIMEType.parse(existingContentType);\n\n              if (parsed) {\n                var charset = parsed.parameters.get(\"charset\");\n\n                if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {\n                  parsed.parameters.set(\"charset\", encoding);\n                }\n\n                xhrUtils.updateRequestHeader(flag.requestHeaders, \"content-type\", parsed.toString());\n              }\n            }\n          }\n        } finally {\n          if (properties.beforeSend) {\n            properties.beforeSend = false;\n          } else {\n            throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n          }\n        }\n\n        if (Object.keys(idlUtils.implForWrapper(this.upload)._eventListeners).length > 0) {\n          properties.uploadListener = true;\n        } // request doesn't like zero-length bodies\n\n\n        if (flag.body && flag.body.byteLength === 0) {\n          flag.body = null;\n        }\n\n        if (flag.synchronous) {\n          var flagStr = JSON.stringify(flag, function (k, v) {\n            if (this === flag && k === \"requestManager\") {\n              return null;\n            }\n\n            if (this === flag && k === \"pool\" && v) {\n              return {\n                maxSockets: v.maxSockets\n              };\n            }\n\n            return v;\n          });\n          var res = spawnSync(process.execPath, [syncWorkerFile], {\n            input: flagStr\n          });\n\n          if (res.status !== 0) {\n            throw new Error(res.stderr.toString());\n          }\n\n          if (res.error) {\n            if (typeof res.error === \"string\") {\n              res.error = new Error(res.error);\n            }\n\n            throw res.error;\n          }\n\n          var response = JSON.parse(res.stdout.toString());\n\n          if (response.properties.responseBuffer && response.properties.responseBuffer.data) {\n            response.properties.responseBuffer = Buffer.from(response.properties.responseBuffer.data);\n          }\n\n          if (response.properties.cookieJar) {\n            response.properties.cookieJar = tough.CookieJar.deserializeSync(response.properties.cookieJar, this._ownerDocument._cookieJar.store);\n          }\n\n          response.properties.readyState = XMLHttpRequest.LOADING;\n          this[xhrSymbols.properties] = response.properties;\n\n          if (response.properties.error) {\n            xhrUtils.dispatchError(this);\n            throw new DOMException(response.properties.error, \"NetworkError\");\n          } else {\n            var responseBuffer = this[xhrSymbols.properties].responseBuffer;\n            var contentLength = _getResponseHeader(this, \"content-length\") || \"0\";\n            var bufferLength = parseInt(contentLength) || responseBuffer.length;\n            var progressObj = {\n              lengthComputable: false\n            };\n\n            if (bufferLength !== 0) {\n              progressObj.total = bufferLength;\n              progressObj.loaded = bufferLength;\n              progressObj.lengthComputable = true;\n            }\n\n            this.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n            readyStateChange(this, XMLHttpRequest.DONE);\n            this.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n            this.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n          }\n        } else {\n          properties.send = true;\n          this.dispatchEvent(new ProgressEvent(\"loadstart\"));\n          var client = xhrUtils.createClient(this);\n          properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize\n\n          properties.totalReceivedChunkSize = 0;\n          properties.bufferStepSize = 1 * 1024 * 1024;\n          properties.origin = flag.origin;\n          client.on(\"error\", function (err) {\n            client.removeAllListeners();\n            properties.error = err;\n            xhrUtils.dispatchError(_this2);\n          });\n          client.on(\"response\", function (res) {\n            return receiveResponse(_this2, res);\n          });\n          client.on(\"redirect\", function () {\n            var response = client.response;\n            var destUrlObj = new URL(response.request.headers.Referer);\n            var urlObj = new URL(response.request.uri.href);\n\n            if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {\n              properties.origin = \"null\";\n            }\n\n            response.request.headers.Origin = properties.origin;\n\n            if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n              if (!xhrUtils.validCORSHeaders(_this2, response, flag, properties, flag.origin)) {\n                return;\n              }\n\n              if (urlObj.username || urlObj.password) {\n                properties.error = \"Userinfo forbidden in cors redirect\";\n                xhrUtils.dispatchError(_this2);\n              }\n            }\n          });\n\n          if (body !== null && body !== \"\") {\n            properties.uploadComplete = false;\n            setDispatchProgressEvents(this);\n          } else {\n            properties.uploadComplete = true;\n          }\n\n          if (this.timeout > 0) {\n            properties.timeoutStart = new Date().getTime();\n\n            properties.timeoutFn = function () {\n              client.abort();\n\n              if (!(_this2.readyState === XMLHttpRequest.UNSENT || _this2.readyState === XMLHttpRequest.OPENED && !properties.send || _this2.readyState === XMLHttpRequest.DONE)) {\n                properties.send = false;\n                var stateChanged = false;\n\n                if (!properties.uploadComplete) {\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"progress\"));\n\n                  readyStateChange(_this2, XMLHttpRequest.DONE);\n\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"timeout\"));\n\n                  _this2.upload.dispatchEvent(new ProgressEvent(\"loadend\"));\n\n                  stateChanged = true;\n                }\n\n                _this2.dispatchEvent(new ProgressEvent(\"progress\"));\n\n                if (!stateChanged) {\n                  readyStateChange(_this2, XMLHttpRequest.DONE);\n                }\n\n                _this2.dispatchEvent(new ProgressEvent(\"timeout\"));\n\n                _this2.dispatchEvent(new ProgressEvent(\"loadend\"));\n              }\n\n              properties.readyState = XMLHttpRequest.UNSENT;\n            };\n\n            properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);\n          }\n        }\n\n        flag.body = undefined;\n        flag.formData = false;\n      }\n    }, {\n      key: \"setRequestHeader\",\n      value: function setRequestHeader(header, value) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (arguments.length !== 2) {\n          throw new TypeError(\"2 arguments required for setRequestHeader\");\n        }\n\n        header = conversions.ByteString(header);\n        value = conversions.ByteString(value);\n\n        if (this.readyState !== XMLHttpRequest.OPENED || properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        value = normalizeHeaderValue(value);\n\n        if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {\n          throw new DOMException(\"The string did not match the expected pattern.\", \"SyntaxError\");\n        }\n\n        var lcHeader = header.toLowerCase();\n\n        if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith(\"sec-\") || lcHeader.startsWith(\"proxy-\")) {\n          return;\n        }\n\n        var keys = Object.keys(flag.requestHeaders);\n        var n = keys.length;\n\n        while (n--) {\n          var key = keys[n];\n\n          if (key.toLowerCase() === lcHeader) {\n            flag.requestHeaders[key] += \", \" + value;\n            return;\n          }\n        }\n\n        flag.requestHeaders[header] = value;\n      }\n    }, {\n      key: \"readyState\",\n      get: function get() {\n        return this[xhrSymbols.properties].readyState;\n      }\n    }, {\n      key: \"status\",\n      get: function get() {\n        return this[xhrSymbols.properties].status;\n      }\n    }, {\n      key: \"statusText\",\n      get: function get() {\n        return this[xhrSymbols.properties].statusText;\n      }\n    }, {\n      key: \"responseType\",\n      get: function get() {\n        return this[xhrSymbols.flag].responseType;\n      },\n      set: function set(responseType) {\n        var flag = this[xhrSymbols.flag];\n\n        if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState === XMLHttpRequest.OPENED && flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        if (!XMLHttpRequestResponseType.has(responseType)) {\n          responseType = \"\";\n        }\n\n        flag.responseType = responseType;\n      }\n    }, {\n      key: \"response\",\n      get: function get() {\n        var properties = this[xhrSymbols.properties];\n\n        if (properties.responseCache) {\n          return properties.responseCache;\n        }\n\n        var res = \"\";\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        switch (this.responseType) {\n          case \"\":\n          case \"text\":\n            {\n              res = this.responseText;\n              break;\n            }\n\n          case \"arraybuffer\":\n            {\n              if (!responseBuffer) {\n                return null;\n              }\n\n              res = new Uint8Array(responseBuffer).buffer;\n              break;\n            }\n\n          case \"blob\":\n            {\n              if (!responseBuffer) {\n                return null;\n              }\n\n              var contentType = finalMIMEType(this);\n              res = Blob.create([[new Uint8Array(responseBuffer)], {\n                type: contentType || \"\"\n              }]);\n              break;\n            }\n\n          case \"document\":\n            {\n              res = this.responseXML;\n              break;\n            }\n\n          case \"json\":\n            {\n              if (this.readyState !== XMLHttpRequest.DONE || !responseBuffer) {\n                res = null;\n              }\n\n              try {\n                res = parseJSONFromBytes(responseBuffer);\n              } catch (e) {\n                res = null;\n              }\n\n              break;\n            }\n        }\n\n        properties.responseCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseText\",\n      get: function get() {\n        var properties = this[xhrSymbols.properties];\n\n        if (this.responseType !== \"\" && this.responseType !== \"text\") {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState !== XMLHttpRequest.LOADING && this.readyState !== XMLHttpRequest.DONE) {\n          return \"\";\n        }\n\n        if (properties.responseTextCache) {\n          return properties.responseTextCache;\n        }\n\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        if (!responseBuffer) {\n          return \"\";\n        }\n\n        var fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n        var res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);\n        properties.responseTextCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseXML\",\n      get: function get() {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (this.responseType !== \"\" && this.responseType !== \"document\") {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (this.readyState !== XMLHttpRequest.DONE) {\n          return null;\n        }\n\n        if (properties.responseXMLCache) {\n          return properties.responseXMLCache;\n        }\n\n        var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;\n\n        if (!responseBuffer) {\n          return null;\n        }\n\n        var contentType = finalMIMEType(this);\n        var isHTML = false;\n        var isXML = false;\n        var parsed = MIMEType.parse(contentType);\n\n        if (parsed) {\n          isHTML = parsed.isHTML();\n          isXML = parsed.isXML();\n\n          if (!isXML && !isHTML) {\n            return null;\n          }\n        }\n\n        if (this.responseType === \"\" && isHTML) {\n          return null;\n        }\n\n        var encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || \"UTF-8\";\n        var resText = whatwgEncoding.decode(responseBuffer, encoding);\n\n        if (!resText) {\n          return null;\n        }\n\n        var res = Document.create([], {\n          options: {\n            url: flag.uri,\n            lastModified: new Date(_getResponseHeader(this, \"last-modified\")),\n            parsingMode: isHTML ? \"html\" : \"xml\",\n            cookieJar: {\n              setCookieSync: function setCookieSync() {\n                return undefined;\n              },\n              getCookieStringSync: function getCookieStringSync() {\n                return \"\";\n              }\n            },\n            encoding: encoding,\n            parseOptions: this._ownerDocument._parseOptions\n          }\n        });\n        var resImpl = idlUtils.implForWrapper(res);\n\n        try {\n          resImpl._htmlToDom.appendToDocument(resText, resImpl);\n        } catch (e) {\n          properties.responseXMLCache = null;\n          return null;\n        }\n\n        res.close();\n        properties.responseXMLCache = res;\n        return res;\n      }\n    }, {\n      key: \"responseURL\",\n      get: function get() {\n        return this[xhrSymbols.properties].responseURL;\n      }\n    }, {\n      key: \"timeout\",\n      get: function get() {\n        return this[xhrSymbols.flag].timeout;\n      },\n      set: function set(val) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (flag.synchronous) {\n          throw new DOMException(\"The object does not support the operation or argument.\", \"InvalidAccessError\");\n        }\n\n        flag.timeout = val;\n        clearTimeout(properties.timeoutId);\n\n        if (val > 0 && properties.timeoutFn) {\n          properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));\n        } else {\n          properties.timeoutFn = null;\n          properties.timeoutStart = 0;\n        }\n      }\n    }, {\n      key: \"withCredentials\",\n      get: function get() {\n        return this[xhrSymbols.flag].withCredentials;\n      },\n      set: function set(val) {\n        var flag = this[xhrSymbols.flag];\n        var properties = this[xhrSymbols.properties];\n\n        if (!(this.readyState === XMLHttpRequest.UNSENT || this.readyState === XMLHttpRequest.OPENED)) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        if (properties.send) {\n          throw new DOMException(\"The object is in an invalid state.\", \"InvalidStateError\");\n        }\n\n        flag.withCredentials = val;\n      }\n    }, {\n      key: \"_ownerDocument\",\n      get: function get() {\n        return idlUtils.implForWrapper(window.document);\n      }\n    }]);\n\n    return XMLHttpRequest;\n  }(XMLHttpRequestEventTarget.interface);\n\n  Object.defineProperty(XMLHttpRequest.prototype, Symbol.toStringTag, {\n    value: \"XMLHttpRequest\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n  setupForSimpleEventAccessors(XMLHttpRequest.prototype, [\"readystatechange\"]);\n  addConstants(XMLHttpRequest, {\n    UNSENT: 0,\n    OPENED: 1,\n    HEADERS_RECEIVED: 2,\n    LOADING: 3,\n    DONE: 4\n  });\n\n  function readyStateChange(xhr, readyState) {\n    var properties = xhr[xhrSymbols.properties];\n\n    if (properties.readyState === readyState) {\n      return;\n    }\n\n    properties.readyState = readyState;\n    var readyStateChangeEvent = new Event(\"readystatechange\");\n    xhr.dispatchEvent(readyStateChangeEvent);\n  }\n\n  function receiveResponse(xhr, response) {\n    var properties = xhr[xhrSymbols.properties];\n    var flag = xhr[xhrSymbols.flag];\n    var statusCode = response.statusCode;\n    var byteOffset = 0;\n    var headers = {};\n    var filteredResponseHeaders = [];\n    var headerMap = {};\n    var rawHeaders = response.rawHeaders;\n    var n = Number(rawHeaders.length);\n\n    for (var i = 0; i < n; i += 2) {\n      var k = rawHeaders[i];\n      var kl = k.toLowerCase();\n      var v = rawHeaders[i + 1];\n\n      if (uniqueResponseHeaders.has(kl)) {\n        if (headerMap[kl] !== undefined) {\n          delete headers[headerMap[kl]];\n        }\n\n        headers[k] = v;\n      } else if (headerMap[kl] !== undefined) {\n        headers[headerMap[kl]] += \", \" + v;\n      } else {\n        headers[k] = v;\n      }\n\n      headerMap[kl] = k;\n    }\n\n    var destUrlObj = new URL(response.request.uri.href);\n\n    if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== \"data:\") {\n      if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {\n        return;\n      }\n\n      var acehStr = response.headers[\"access-control-expose-headers\"];\n      var aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);\n\n      for (var header in headers) {\n        var lcHeader = header.toLowerCase();\n\n        if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {\n          filteredResponseHeaders.push(header);\n        }\n      }\n    }\n\n    for (var _header in headers) {\n      var _lcHeader = _header.toLowerCase();\n\n      if (forbiddenResponseHeaders.has(_lcHeader)) {\n        filteredResponseHeaders.push(_header);\n      }\n    }\n\n    properties.responseURL = destUrlObj.href;\n    properties.status = statusCode;\n    properties.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || \"\";\n    properties.responseHeaders = headers;\n    properties.filteredResponseHeaders = filteredResponseHeaders;\n    var contentLength = _getResponseHeader(xhr, \"content-length\") || \"0\";\n    var bufferLength = parseInt(contentLength) || 0;\n    var progressObj = {\n      lengthComputable: false\n    };\n    var lastProgressReported;\n\n    if (bufferLength !== 0) {\n      progressObj.total = bufferLength;\n      progressObj.loaded = 0;\n      progressObj.lengthComputable = true;\n    } // pre-allocate buffer.\n\n\n    properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);\n    properties.responseCache = null;\n    properties.responseTextCache = null;\n    properties.responseXMLCache = null;\n    readyStateChange(xhr, XMLHttpRequest.HEADERS_RECEIVED);\n\n    if (!properties.client) {\n      // The request was aborted in reaction to the readystatechange event.\n      return;\n    } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the\n    // Content-Length).\n\n\n    response.on(\"data\", function (chunk) {\n      byteOffset += chunk.length;\n      progressObj.loaded = byteOffset;\n    });\n    properties.client.on(\"data\", function (chunk) {\n      properties.totalReceivedChunkSize += chunk.length;\n\n      if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n        properties.bufferStepSize *= 2;\n\n        while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {\n          properties.bufferStepSize *= 2;\n        }\n\n        var tmpBuf = Buffer.alloc(properties.bufferStepSize);\n        properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);\n        properties.responseBuffer = tmpBuf;\n      }\n\n      chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);\n      properties.responseCache = null;\n      properties.responseTextCache = null;\n      properties.responseXMLCache = null;\n\n      if (properties.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n        properties.readyState = XMLHttpRequest.LOADING;\n      }\n\n      xhr.dispatchEvent(new Event(\"readystatechange\"));\n\n      if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {\n        if (lastProgressReported !== progressObj.loaded) {\n          // This is a necessary check in the gzip case where we can be getting new data from the client, as it\n          // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.\n          lastProgressReported = progressObj.loaded;\n          xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n        }\n      }\n    });\n    properties.client.on(\"end\", function () {\n      clearTimeout(properties.timeoutId);\n      properties.timeoutFn = null;\n      properties.timeoutStart = 0;\n      properties.client = null;\n      xhr.dispatchEvent(new ProgressEvent(\"progress\", progressObj));\n      readyStateChange(xhr, XMLHttpRequest.DONE);\n      xhr.dispatchEvent(new ProgressEvent(\"load\", progressObj));\n      xhr.dispatchEvent(new ProgressEvent(\"loadend\", progressObj));\n    });\n  }\n\n  function setDispatchProgressEvents(xhr) {\n    var properties = xhr[xhrSymbols.properties];\n    var client = properties.client;\n    var upload = xhr.upload;\n    var total = 0;\n    var lengthComputable = false;\n    var length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, \"content-length\"));\n\n    if (length) {\n      total = length;\n      lengthComputable = true;\n    }\n\n    var initProgress = {\n      lengthComputable: lengthComputable,\n      total: total,\n      loaded: 0\n    };\n\n    if (properties.uploadListener) {\n      upload.dispatchEvent(new ProgressEvent(\"loadstart\", initProgress));\n    }\n\n    client.on(\"request\", function (req) {\n      req.on(\"response\", function () {\n        properties.uploadComplete = true;\n\n        if (!properties.uploadListener) {\n          return;\n        }\n\n        var progress = {\n          lengthComputable: lengthComputable,\n          total: total,\n          loaded: total\n        };\n        upload.dispatchEvent(new ProgressEvent(\"progress\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"load\", progress));\n        upload.dispatchEvent(new ProgressEvent(\"loadend\", progress));\n      });\n    });\n  }\n\n  return XMLHttpRequest;\n};\n\nfunction finalMIMEType(xhr) {\n  var flag = xhr[xhrSymbols.flag];\n  return flag.overrideMIMEType || _getResponseHeader(xhr, \"content-type\");\n}\n\nfunction finalCharset(xhr) {\n  var flag = xhr[xhrSymbols.flag];\n\n  if (flag.overrideCharset) {\n    return flag.overrideCharset;\n  }\n\n  var parsedContentType = MIMEType.parse(_getResponseHeader(xhr, \"content-type\"));\n\n  if (parsedContentType) {\n    return whatwgEncoding.labelToName(parsedContentType.parameters.get(\"charset\"));\n  }\n\n  return null;\n}\n\nfunction _getResponseHeader(xhr, lcHeader) {\n  var properties = xhr[xhrSymbols.properties];\n  var keys = Object.keys(properties.responseHeaders);\n  var n = keys.length;\n\n  while (n--) {\n    var key = keys[n];\n\n    if (key.toLowerCase() === lcHeader) {\n      return properties.responseHeaders[key];\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeHeaderValue(value) {\n  return value.replace(/^[\\x09\\x0A\\x0D\\x20]+/, \"\").replace(/[\\x09\\x0A\\x0D\\x20]+$/, \"\");\n}\n\nfunction coerceBodyArg(body) {\n  // Implements the IDL conversion for `optional (Document or BodyInit)? body = null`\n  if (body === undefined || body === null) {\n    return null;\n  }\n\n  if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n    return body;\n  }\n\n  var impl = idlUtils.implForWrapper(body);\n\n  if (impl) {\n    // TODO: allow URLSearchParams or ReadableStream\n    if (Blob.isImpl(impl) || FormData.isImpl(impl) || Document.isImpl(impl)) {\n      return impl;\n    }\n  }\n\n  return conversions.USVString(body);\n}\n\nfunction extractBody(bodyInit) {\n  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n  // except we represent the body as a Node.js Buffer instead,\n  // or a special case for FormData since we want request to handle that. Probably it would be\n  // cleaner (and allow a future without request) if we did the form encoding ourself.\n  if (Blob.isImpl(bodyInit)) {\n    return {\n      buffer: bodyInit._buffer,\n      contentType: bodyInit.type === \"\" ? null : bodyInit.type\n    };\n  } else if (bodyInit instanceof ArrayBuffer) {\n    return {\n      buffer: Buffer.from(bodyInit),\n      contentType: null\n    };\n  } else if (ArrayBuffer.isView(bodyInit)) {\n    return {\n      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),\n      contentType: null\n    };\n  } else if (FormData.isImpl(bodyInit)) {\n    var formData = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = bodyInit._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var entry = _step.value;\n        var val = void 0;\n\n        if (Blob.isImpl(entry.value)) {\n          var blob = entry.value;\n          val = {\n            name: entry.name,\n            value: blob._buffer,\n            options: {\n              filename: blob.name,\n              contentType: blob.type,\n              knownLength: blob.size\n            }\n          };\n        } else {\n          val = entry;\n        }\n\n        formData.push(val);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      formData: formData\n    };\n  } // Must be a string\n\n\n  return {\n    buffer: Buffer.from(bodyInit, \"utf-8\"),\n    contentType: \"text/plain;charset=UTF-8\"\n  };\n}","map":null,"metadata":{},"sourceType":"script"}