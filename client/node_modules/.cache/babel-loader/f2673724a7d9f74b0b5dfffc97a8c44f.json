{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar conversions = require(\"webidl-conversions\");\n\nvar utils = require(\"./utils.js\");\n\nvar impl = utils.implSymbol;\n\nfunction SVGStringList() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\nObject.defineProperty(SVGStringList, \"prototype\", {\n  value: SVGStringList.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nObject.defineProperty(SVGStringList.prototype, Symbol.iterator, {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n  value: Array.prototype[Symbol.iterator]\n});\n\nSVGStringList.prototype.clear = function clear() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  return this[impl].clear();\n};\n\nSVGStringList.prototype.initialize = function initialize(newItem) {\n  var _this$impl;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'initialize' on 'SVGStringList': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"DOMString\"](curArg, {\n      context: \"Failed to execute 'initialize' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return (_this$impl = this[impl]).initialize.apply(_this$impl, args);\n};\n\nSVGStringList.prototype.getItem = function getItem(index) {\n  var _this$impl2;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getItem' on 'SVGStringList': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"unsigned long\"](curArg, {\n      context: \"Failed to execute 'getItem' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return (_this$impl2 = this[impl]).getItem.apply(_this$impl2, args);\n};\n\nSVGStringList.prototype.insertItemBefore = function insertItemBefore(newItem, index) {\n  var _this$impl3;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'insertItemBefore' on 'SVGStringList': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"DOMString\"](curArg, {\n      context: \"Failed to execute 'insertItemBefore' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  {\n    var _curArg = arguments[1];\n    _curArg = conversions[\"unsigned long\"](_curArg, {\n      context: \"Failed to execute 'insertItemBefore' on 'SVGStringList': parameter 2\"\n    });\n    args.push(_curArg);\n  }\n  return (_this$impl3 = this[impl]).insertItemBefore.apply(_this$impl3, args);\n};\n\nSVGStringList.prototype.replaceItem = function replaceItem(newItem, index) {\n  var _this$impl4;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'replaceItem' on 'SVGStringList': 2 arguments required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"DOMString\"](curArg, {\n      context: \"Failed to execute 'replaceItem' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  {\n    var _curArg2 = arguments[1];\n    _curArg2 = conversions[\"unsigned long\"](_curArg2, {\n      context: \"Failed to execute 'replaceItem' on 'SVGStringList': parameter 2\"\n    });\n    args.push(_curArg2);\n  }\n  return (_this$impl4 = this[impl]).replaceItem.apply(_this$impl4, args);\n};\n\nSVGStringList.prototype.removeItem = function removeItem(index) {\n  var _this$impl5;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'removeItem' on 'SVGStringList': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"unsigned long\"](curArg, {\n      context: \"Failed to execute 'removeItem' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return (_this$impl5 = this[impl]).removeItem.apply(_this$impl5, args);\n};\n\nSVGStringList.prototype.appendItem = function appendItem(newItem) {\n  var _this$impl6;\n\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'appendItem' on 'SVGStringList': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n\n  var args = [];\n  {\n    var curArg = arguments[0];\n    curArg = conversions[\"DOMString\"](curArg, {\n      context: \"Failed to execute 'appendItem' on 'SVGStringList': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return (_this$impl6 = this[impl]).appendItem.apply(_this$impl6, args);\n};\n\nObject.defineProperty(SVGStringList.prototype, \"length\", {\n  get: function get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    return this[impl][\"length\"];\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(SVGStringList.prototype, \"numberOfItems\", {\n  get: function get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    return this[impl][\"numberOfItems\"];\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(SVGStringList.prototype, Symbol.toStringTag, {\n  value: \"SVGStringList\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nvar iface = {\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\n  // implementing this mixin interface.\n  _mixedIntoPredicates: [],\n  is: function is(obj) {\n    if (obj) {\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = module.exports._mixedIntoPredicates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var isMixedInto = _step.value;\n\n          if (isMixedInto(obj)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n  isImpl: function isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      var wrapper = utils.wrapperForImpl(obj);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = module.exports._mixedIntoPredicates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var isMixedInto = _step2.value;\n\n          if (isMixedInto(wrapper)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n\n    return false;\n  },\n  convert: function convert(obj) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$context = _ref.context,\n        context = _ref$context === void 0 ? \"The provided value\" : _ref$context;\n\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n\n    throw new TypeError(\"\".concat(context, \" is not of type 'SVGStringList'.\"));\n  },\n  create: function create(constructorArgs, privateData) {\n    var obj = Object.create(SVGStringList.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl: function createImpl(constructorArgs, privateData) {\n    var obj = Object.create(SVGStringList.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup: function _internalSetup(obj) {},\n  setup: function setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    obj = new Proxy(obj, {\n      get: function get(target, P, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.get(target, P, receiver);\n        }\n\n        var desc = this.getOwnPropertyDescriptor(target, P);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(target);\n\n          if (parent === null) {\n            return undefined;\n          }\n\n          return Reflect.get(target, P, receiver);\n        }\n\n        if (!desc.get && !desc.set) {\n          return desc.value;\n        }\n\n        var getter = desc.get;\n\n        if (getter === undefined) {\n          return undefined;\n        }\n\n        return Reflect.apply(getter, receiver, []);\n      },\n      has: function has(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.has(target, P);\n        }\n\n        var desc = this.getOwnPropertyDescriptor(target, P);\n\n        if (desc !== undefined) {\n          return true;\n        }\n\n        var parent = Object.getPrototypeOf(target);\n\n        if (parent !== null) {\n          return Reflect.has(parent, P);\n        }\n\n        return false;\n      },\n      ownKeys: function ownKeys(target) {\n        var keys = new Set();\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = target[impl][utils.supportedPropertyIndices][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var key = _step3.value;\n            keys.add(\"\".concat(key));\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = Reflect.ownKeys(target)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _key = _step4.value;\n            keys.add(_key);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        return _toConsumableArray(keys);\n      },\n      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.getOwnPropertyDescriptor(target, P);\n        }\n\n        var ignoreNamedProps = false;\n\n        if (utils.isArrayIndexPropName(P)) {\n          var index = P >>> 0;\n\n          if (target[impl][utils.supportsPropertyIndex](index)) {\n            var indexedValue = target[impl].getItem(index);\n            return {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(indexedValue)\n            };\n          }\n\n          ignoreNamedProps = true;\n        }\n\n        return Reflect.getOwnPropertyDescriptor(target, P);\n      },\n      set: function set(target, P, V, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.set(target, P, V, receiver);\n        }\n\n        if (target === receiver) {\n          if (utils.isArrayIndexPropName(P)) {\n            var index = P >>> 0;\n            var indexedValue = V;\n            indexedValue = conversions[\"DOMString\"](indexedValue, {\n              context: \"Failed to set the \" + index + \" property on 'SVGStringList': The provided value\"\n            });\n            var creating = !target[impl][utils.supportsPropertyIndex](index);\n\n            if (creating) {\n              target[impl][utils.indexedSetNew](index, indexedValue);\n            } else {\n              target[impl][utils.indexedSetExisting](index, indexedValue);\n            }\n\n            return true;\n          }\n        }\n\n        var ownDesc;\n\n        if (utils.isArrayIndexPropName(P)) {\n          var _index = P >>> 0;\n\n          if (target[impl][utils.supportsPropertyIndex](_index)) {\n            var _indexedValue = target[impl].getItem(_index);\n\n            ownDesc = {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(_indexedValue)\n            };\n          }\n        }\n\n        if (ownDesc === undefined) {\n          ownDesc = Reflect.getOwnPropertyDescriptor(target, P);\n        }\n\n        if (ownDesc === undefined) {\n          var parent = Reflect.getPrototypeOf(target);\n\n          if (parent !== null) {\n            return Reflect.set(parent, P, V, receiver);\n          }\n\n          ownDesc = {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: undefined\n          };\n        }\n\n        if (!ownDesc.writable) {\n          return false;\n        }\n\n        if (!utils.isObject(receiver)) {\n          return false;\n        }\n\n        var existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);\n        var valueDesc;\n\n        if (existingDesc !== undefined) {\n          if (existingDesc.get || existingDesc.set) {\n            return false;\n          }\n\n          if (!existingDesc.writable) {\n            return false;\n          }\n\n          valueDesc = {\n            value: V\n          };\n        } else {\n          valueDesc = {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: V\n          };\n        }\n\n        return Reflect.defineProperty(receiver, P, valueDesc);\n      },\n      defineProperty: function defineProperty(target, P, desc) {\n        if (typeof P === \"symbol\") {\n          return Reflect.defineProperty(target, P, desc);\n        }\n\n        if (utils.isArrayIndexPropName(P)) {\n          if (desc.get || desc.set) {\n            return false;\n          }\n\n          var index = P >>> 0;\n          var indexedValue = desc.value;\n          indexedValue = conversions[\"DOMString\"](indexedValue, {\n            context: \"Failed to set the \" + index + \" property on 'SVGStringList': The provided value\"\n          });\n          var creating = !target[impl][utils.supportsPropertyIndex](index);\n\n          if (creating) {\n            target[impl][utils.indexedSetNew](index, indexedValue);\n          } else {\n            target[impl][utils.indexedSetExisting](index, indexedValue);\n          }\n\n          return true;\n        }\n\n        return Reflect.defineProperty(target, P, desc);\n      },\n      deleteProperty: function deleteProperty(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.deleteProperty(target, P);\n        }\n\n        if (utils.isArrayIndexPropName(P)) {\n          var index = P >>> 0;\n          return !target[impl][utils.supportsPropertyIndex](index);\n        }\n\n        return Reflect.deleteProperty(target, P);\n      },\n      preventExtensions: function preventExtensions() {\n        return false;\n      }\n    });\n    obj[impl][utils.wrapperSymbol] = obj;\n\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n\n    return obj;\n  },\n  interface: SVGStringList,\n  expose: {\n    Window: {\n      SVGStringList: SVGStringList\n    }\n  }\n}; // iface\n\nmodule.exports = iface;\n\nvar Impl = require(\"../svg/SVGStringList-impl.js\");","map":null,"metadata":{},"sourceType":"script"}