{"ast":null,"code":"/*\n * Copyright (C) 2007-2019 Diego Perini\n * All rights reserved.\n *\n * nwsapi.js - Fast CSS Selectors API Engine\n *\n * Author: Diego Perini <diego.perini at gmail com>\n * Version: 2.1.3\n * Created: 20070722\n * Release: 20190330\n *\n * License:\n *  http://javascript.nwbox.com/nwsapi/MIT-LICENSE\n * Download:\n *  http://javascript.nwbox.com/nwsapi/nwsapi.js\n */\n(function Export(global, factory) {\n  'use strict';\n\n  if (typeof module == 'object' && typeof exports == 'object') {\n    module.exports = factory;\n  } else if (typeof define == 'function' && define['amd']) {\n    define(factory);\n  } else {\n    global.NW || (global.NW = {});\n    global.NW.Dom = factory(global, Export);\n  }\n})(this, function Factory(global, Export) {\n  var version = 'nwsapi-2.1.3',\n      doc = global.document,\n      root = doc.documentElement,\n      WSP = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]',\n      CFG = {\n    // extensions\n    operators: '[~*^$|]=|=',\n    combinators: '[\\\\x20\\\\t>+~](?=[^>+~])'\n  },\n      NOT = {\n    // not enclosed in double/single/parens/square\n    double_enc: '(?=(?:[^\"]*[\"][^\"]*[\"])*[^\"]*$)',\n    single_enc: \"(?=(?:[^']*['][^']*['])*[^']*$)\",\n    parens_enc: '(?![^\\\\x28]*\\\\x29)',\n    square_enc: '(?![^\\\\x5b]*\\\\x5d)'\n  },\n      REX = {\n    // regular expressions\n    HasEscapes: RegExp('\\\\\\\\'),\n    HexNumbers: RegExp('^[0-9a-fA-F]'),\n    EscOrQuote: RegExp('^\\\\\\\\|[\\\\x22\\\\x27]'),\n    RegExpChar: RegExp('(?:(?!\\\\\\\\)[\\\\\\\\^$.*+?()[\\\\]{}|\\\\/])', 'g'),\n    TrimSpaces: RegExp('[\\\\r\\\\n\\\\f]|^' + WSP + '+|' + WSP + '+$', 'g'),\n    CommaGroup: RegExp('(\\\\s*,\\\\s*)' + NOT.square_enc + NOT.parens_enc, 'g'),\n    SplitGroup: RegExp('((?:\\\\x28[^\\\\x29]*\\\\x29|\\\\[[^\\\\]]*\\\\]|\\\\\\\\.|[^,])+)', 'g'),\n    FixEscapes: RegExp('\\\\\\\\([0-9a-fA-F]{1,6}' + WSP + '?|.)|([\\\\x22\\\\x27])', 'g'),\n    CombineWSP: RegExp('[\\\\n\\\\r\\\\f\\\\x20]+' + NOT.single_enc + NOT.double_enc, 'g'),\n    TabCharWSP: RegExp('(\\\\x20?\\\\t+\\\\x20?)' + NOT.single_enc + NOT.double_enc, 'g'),\n    PseudosWSP: RegExp('\\\\s+([-+])\\\\s+' + NOT.square_enc, 'g')\n  },\n      STD = {\n    combinator: RegExp('\\\\s?([>+~])\\\\s?', 'g'),\n    apimethods: RegExp('^(?:[a-z]+|\\\\*)\\\\|', 'i'),\n    namespaces: RegExp('(\\\\*|[a-z]+)\\\\|[-a-z]+', 'i')\n  },\n      GROUPS = {\n    // pseudo-classes requiring parameters\n    linguistic: '(dir|lang)\\\\x28\\\\s?([-\\\\w]{2,})\\\\s?(?:\\\\x29|$)',\n    logicalsel: '(matches|not)\\\\x28\\\\s?([^()]*|[^\\\\x28]*\\\\x28[^\\\\x29]*\\\\x29)\\\\s?(?:\\\\x29|$)',\n    treestruct: '(nth(?:-last)?(?:-child|-of-type))(?:\\\\x28\\\\s?(even|odd|(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)?)\\\\s?(?:\\\\x29|$))',\n    // pseudo-classes not requiring parameters\n    locationpc: '(link|visited|target)\\\\b',\n    useraction: '(hover|active|focus|focus-within)\\\\b',\n    structural: '(root|empty|(?:(?:first|last|only)(?:-child|-of-type)))\\\\b',\n    inputstate: '(enabled|disabled|read-only|read-write|placeholder-shown|default)\\\\b',\n    inputvalue: '(checked|indeterminate|required|optional|valid|invalid|in-range|out-of-range)\\\\b',\n    pseudo_dbl: '(after|before|first-letter|first-line|-webkit-[-a-zA-Z0-9]{2,})\\\\b',\n    pseudo_sng: ':(after|before|first-letter|first-line|selection|placeholder)\\\\b'\n  },\n      Patterns = {\n    // pseudo-classes\n    treestruct: RegExp('^:(?:' + GROUPS.treestruct + ')(.*)', 'i'),\n    structural: RegExp('^:(?:' + GROUPS.structural + ')(.*)', 'i'),\n    linguistic: RegExp('^:(?:' + GROUPS.linguistic + ')(.*)', 'i'),\n    useraction: RegExp('^:(?:' + GROUPS.useraction + ')(.*)', 'i'),\n    inputstate: RegExp('^:(?:' + GROUPS.inputstate + ')(.*)', 'i'),\n    inputvalue: RegExp('^:(?:' + GROUPS.inputvalue + ')(.*)', 'i'),\n    locationpc: RegExp('^:(?:' + GROUPS.locationpc + ')(.*)', 'i'),\n    logicalsel: RegExp('^:(?:' + GROUPS.logicalsel + ')(.*)', 'i'),\n    pseudo_dbl: RegExp('^:(?:' + GROUPS.pseudo_dbl + ')(.*)', 'i'),\n    pseudo_sng: RegExp('^:(?:' + GROUPS.pseudo_sng + ')(.*)', 'i'),\n    // combinators symbols\n    children: RegExp('^' + WSP + '?\\\\>' + WSP + '?(.*)'),\n    adjacent: RegExp('^' + WSP + '?\\\\+' + WSP + '?(.*)'),\n    relative: RegExp('^' + WSP + '?\\\\~' + WSP + '?(.*)'),\n    ancestor: RegExp('^' + WSP + '+(.*)'),\n    // universal & namespace\n    universal: RegExp('^\\\\*(.*)'),\n    namespace: RegExp('^(\\\\w+|\\\\*)?\\\\|(.*)')\n  },\n      // regexp to aproximate detection of RTL languages (Arabic)\n  RTL = RegExp(\"^[\\\\u0591-\\\\u08ff\\\\ufb1d-\\\\ufdfd\\\\ufe70-\\\\ufefc ]+$\"),\n      // emulate firefox error strings\n  qsNotArgs = 'Not enough arguments',\n      qsInvalid = ' is not a valid selector',\n      // detect structural pseudo-classes in selectors\n  reNthElem = RegExp('(:nth(?:-last)?-child)', 'i'),\n      reNthType = RegExp('(:nth(?:-last)?-of-type)', 'i'),\n      // placeholder for global regexp\n  reOptimizer,\n      reValidator,\n      // special handling configuration flags\n  Config = {\n    IDS_DUPES: true,\n    LIVECACHE: false,\n    MIXEDCASE: true,\n    LOGERRORS: true,\n    VERBOSITY: true\n  },\n      NAMESPACE,\n      QUIRKS_MODE,\n      HTML_DOCUMENT,\n      ATTR_STD_OPS = {\n    '=': 1,\n    '^=': 1,\n    '$=': 1,\n    '|=': 1,\n    '*=': 1,\n    '~=': 1\n  },\n      HTML_TABLE = {\n    'accept': 1,\n    'accept-charset': 1,\n    'align': 1,\n    'alink': 1,\n    'axis': 1,\n    'bgcolor': 1,\n    'charset': 1,\n    'checked': 1,\n    'clear': 1,\n    'codetype': 1,\n    'color': 1,\n    'compact': 1,\n    'declare': 1,\n    'defer': 1,\n    'dir': 1,\n    'direction': 1,\n    'disabled': 1,\n    'enctype': 1,\n    'face': 1,\n    'frame': 1,\n    'hreflang': 1,\n    'http-equiv': 1,\n    'lang': 1,\n    'language': 1,\n    'link': 1,\n    'media': 1,\n    'method': 1,\n    'multiple': 1,\n    'nohref': 1,\n    'noresize': 1,\n    'noshade': 1,\n    'nowrap': 1,\n    'readonly': 1,\n    'rel': 1,\n    'rev': 1,\n    'rules': 1,\n    'scope': 1,\n    'scrolling': 1,\n    'selected': 1,\n    'shape': 1,\n    'target': 1,\n    'text': 1,\n    'type': 1,\n    'valign': 1,\n    'valuetype': 1,\n    'vlink': 1\n  },\n      Combinators = {},\n      Selectors = {},\n      Operators = {\n    '=': {\n      p1: '^',\n      p2: '$',\n      p3: 'true'\n    },\n    '^=': {\n      p1: '^',\n      p2: '',\n      p3: 'true'\n    },\n    '$=': {\n      p1: '',\n      p2: '$',\n      p3: 'true'\n    },\n    '*=': {\n      p1: '',\n      p2: '',\n      p3: 'true'\n    },\n    '|=': {\n      p1: '^',\n      p2: '(-|$)',\n      p3: 'true'\n    },\n    '~=': {\n      p1: '(^|\\\\s)',\n      p2: '(\\\\s|$)',\n      p3: 'true'\n    }\n  },\n      concatCall = function concatCall(nodes, callback) {\n    var i = 0,\n        l = nodes.length,\n        list = Array(l);\n\n    while (l > i) {\n      if (false === callback(list[i] = nodes[i])) break;\n      ++i;\n    }\n\n    return list;\n  },\n      concatList = function concatList(list, nodes) {\n    var i = -1,\n        l = nodes.length;\n\n    while (l--) {\n      list[list.length] = nodes[++i];\n    }\n\n    return list;\n  },\n      documentOrder = function documentOrder(a, b) {\n    if (!hasDupes && a === b) {\n      hasDupes = true;\n      return 0;\n    }\n\n    return a.compareDocumentPosition(b) & 4 ? -1 : 1;\n  },\n      hasDupes = false,\n      unique = function unique(nodes) {\n    var i = 0,\n        j = -1,\n        l = nodes.length + 1,\n        list = [];\n\n    while (--l) {\n      if (nodes[i++] === nodes[i]) continue;\n      list[++j] = nodes[i - 1];\n    }\n\n    hasDupes = false;\n    return list;\n  },\n      // check context for mixed content\n  hasMixedCaseTagNames = function hasMixedCaseTagNames(context) {\n    var ns,\n        api = 'getElementsByTagNameNS'; // current host context (ownerDocument)\n\n    context = context.ownerDocument || context; // documentElement (root) element namespace or default html/xhtml namespace\n\n    ns = context.documentElement.namespaceURI || 'http://www.w3.org/1999/xhtml'; // checking the number of non HTML nodes in the document\n\n    return context[api]('*', '*').length - context[api](ns, '*').length > 0;\n  },\n      switchContext = function switchContext(context, force) {\n    var oldDoc = doc;\n    doc = context.ownerDocument || context;\n\n    if (force || oldDoc !== doc) {\n      // force a new check for each document change\n      // performed before the next select operation\n      root = doc.documentElement;\n      HTML_DOCUMENT = isHTML(doc);\n      QUIRKS_MODE = HTML_DOCUMENT && doc.compatMode.indexOf('CSS') < 0;\n      NAMESPACE = root && root.namespaceURI;\n      Snapshot.doc = doc;\n      Snapshot.root = root;\n    }\n\n    return Snapshot.from = context;\n  },\n      // convert single codepoint to UTF-16 encoding\n  codePointToUTF16 = function codePointToUTF16(codePoint) {\n    // out of range, use replacement character\n    if (codePoint < 1 || codePoint > 0x10ffff || codePoint > 0xd7ff && codePoint < 0xe000) {\n      return \"\\\\ufffd\";\n    } // javascript strings are UTF-16 encoded\n\n\n    if (codePoint < 0x10000) {\n      var lowHex = '000' + codePoint.toString(16);\n      return \"\\\\u\" + lowHex.substr(lowHex.length - 4);\n    } // supplementary high + low surrogates\n\n\n    return \"\\\\u\" + ((codePoint - 0x10000 >> 0x0a) + 0xd800).toString(16) + \"\\\\u\" + ((codePoint - 0x10000) % 0x400 + 0xdc00).toString(16);\n  },\n      // convert single codepoint to string\n  stringFromCodePoint = function stringFromCodePoint(codePoint) {\n    // out of range, use replacement character\n    if (codePoint < 1 || codePoint > 0x10ffff || codePoint > 0xd7ff && codePoint < 0xe000) {\n      return \"\\uFFFD\";\n    }\n\n    if (codePoint < 0x10000) {\n      return String.fromCharCode(codePoint);\n    }\n\n    return String.fromCodePoint ? String.fromCodePoint(codePoint) : String.fromCharCode((codePoint - 0x10000 >> 0x0a) + 0xd800, (codePoint - 0x10000) % 0x400 + 0xdc00);\n  },\n      // convert escape sequence in a CSS string or identifier\n  // to javascript string with javascript escape sequences\n  convertEscapes = function convertEscapes(str) {\n    return REX.HasEscapes.test(str) ? str.replace(REX.FixEscapes, function (substring, p1, p2) {\n      // unescaped \" or '\n      return p2 ? '\\\\' + p2 : // javascript strings are UTF-16 encoded\n      REX.HexNumbers.test(p1) ? codePointToUTF16(parseInt(p1, 16)) : // \\' \\\"\n      REX.EscOrQuote.test(p1) ? substring : // \\g \\h \\. \\# etc\n      p1;\n    }) : str;\n  },\n      // convert escape sequence in a CSS string or identifier\n  // to javascript string with characters representations\n  unescapeIdentifier = function unescapeIdentifier(str) {\n    return REX.HasEscapes.test(str) ? str.replace(REX.FixEscapes, function (substring, p1, p2) {\n      // unescaped \" or '\n      return p2 ? p2 : // javascript strings are UTF-16 encoded\n      REX.HexNumbers.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) : // \\' \\\"\n      REX.EscOrQuote.test(p1) ? substring : // \\g \\h \\. \\# etc\n      p1;\n    }) : str;\n  },\n      method = {\n    '#': 'getElementById',\n    '*': 'getElementsByTagName',\n    '.': 'getElementsByClassName'\n  },\n      compat = {\n    '#': function _(c, n) {\n      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byId(n, c);\n      };\n    },\n    '*': function _(c, n) {\n      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byTag(n, c);\n      };\n    },\n    '.': function _(c, n) {\n      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n      return function (e, f) {\n        return byClass(n, c);\n      };\n    }\n  },\n      // find duplicate ids using iterative walk\n  byIdRaw = function byIdRaw(id, context) {\n    var node = context,\n        nodes = [],\n        next = node.firstElementChild;\n\n    while (node = next) {\n      node.id == id && (nodes[nodes.length] = node);\n      if (next = node.firstElementChild || node.nextElementSibling) continue;\n\n      while (!next && (node = node.parentElement) && node !== context) {\n        next = node.nextElementSibling;\n      }\n    }\n\n    return nodes;\n  },\n      // context agnostic getElementById\n  byId = function byId(id, context) {\n    var e,\n        nodes,\n        api = method['#']; // duplicates id allowed\n\n    if (Config.IDS_DUPES === false) {\n      if (api in context) {\n        return (e = context[api](id)) ? [e] : none;\n      }\n    } else {\n      if ('all' in context) {\n        if (e = context.all[id]) {\n          if (e.nodeType == 1) return e.getAttribute('id') != id ? [] : [e];else if (id == 'length') return (e = context[api](id)) ? [e] : none;\n\n          for (i = 0, l = e.length, nodes = []; l > i; ++i) {\n            if (e[i].id == id) nodes[nodes.length] = e[i];\n          }\n\n          return nodes && nodes.length ? nodes : [nodes];\n        } else return none;\n      }\n    }\n\n    return byIdRaw(id, context);\n  },\n      // context agnostic getElementsByTagName\n  byTag = function byTag(tag, context) {\n    var e,\n        nodes,\n        api = method['*']; // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n\n    if (api in context) {\n      return context[api](tag);\n    } else {\n      // DOCUMENT_FRAGMENT_NODE (11)\n      if (e = context.firstElementChild) {\n        tag = tag.toLowerCase();\n\n        if (!(e.nextElementSibling || tag == '*' || e.nodeName.toLowerCase() == tag)) {\n          return e[api](tag);\n        } else {\n          nodes = [];\n\n          do {\n            if (tag == '*' || e.nodeName.toLowerCase() == tag) nodes[nodes.length] = e;\n            concatList(nodes, e[api](tag));\n          } while (e = e.nextElementSibling);\n        }\n      } else nodes = none;\n    }\n\n    return nodes;\n  },\n      // context agnostic getElementsByClassName\n  byClass = function byClass(cls, context) {\n    var e,\n        nodes,\n        api = method['.'],\n        reCls; // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n\n    if (api in context) {\n      return context[api](cls);\n    } else {\n      // DOCUMENT_FRAGMENT_NODE (11)\n      if (e = context.firstElementChild) {\n        reCls = RegExp('(^|\\\\s)' + cls + '(\\\\s|$)', QUIRKS_MODE ? 'i' : '');\n\n        if (!(e.nextElementSibling || reCls.test(e.className))) {\n          return e[api](cls);\n        } else {\n          nodes = [];\n\n          do {\n            if (reCls.test(e.className)) nodes[nodes.length] = e;\n            concatList(nodes, e[api](cls));\n          } while (e = e.nextElementSibling);\n        }\n      } else nodes = none;\n    }\n\n    return nodes;\n  },\n      // namespace aware hasAttribute\n  // helper for XML/XHTML documents\n  hasAttributeNS = function hasAttributeNS(e, name) {\n    var i,\n        l,\n        attr = e.getAttributeNames();\n    HTML_DOCUMENT && (name = name.toLowerCase());\n\n    for (i = 0, l = attr.length; l > i; ++i) {\n      if (name == attr[i].toLowerCase()) return true;\n    }\n\n    return false;\n  },\n      // fast resolver for the :nth-child() and :nth-last-child() pseudo-classes\n  nthElement = function () {\n    var idx = 0,\n        len = 0,\n        set = 0,\n        parent = undefined,\n        parents = Array(),\n        nodes = Array();\n    return function (element, dir) {\n      // ensure caches are emptied after each run, invoking with dir = 2\n      if (dir == 2) {\n        idx = 0;\n        len = 0;\n        set = 0;\n        nodes.length = 0;\n        parents.length = 0;\n        parent = undefined;\n        return -1;\n      }\n\n      var e, i, j, k, l;\n\n      if (parent === element.parentElement) {\n        i = set;\n        j = idx;\n        l = len;\n      } else {\n        l = parents.length;\n        parent = element.parentElement;\n\n        for (i = -1, j = 0, k = l - 1; l > j; ++j, --k) {\n          if (parents[j] === parent) {\n            i = j;\n            break;\n          }\n\n          if (parents[k] === parent) {\n            i = k;\n            break;\n          }\n        }\n\n        if (i < 0) {\n          parents[i = l] = parent;\n          l = 0;\n          nodes[i] = Array();\n          e = parent && parent.firstElementChild || element;\n\n          while (e) {\n            nodes[i][l] = e;\n            if (e === element) j = l;\n            e = e.nextElementSibling;\n            ++l;\n          }\n\n          set = i;\n          idx = 0;\n          len = l;\n          if (l < 2) return l;\n        } else {\n          l = nodes[i].length;\n          set = i;\n        }\n      }\n\n      if (element !== nodes[i][j] && element !== nodes[i][j = 0]) {\n        for (j = 0, e = nodes[i], k = l - 1; l > j; ++j, --k) {\n          if (e[j] === element) {\n            break;\n          }\n\n          if (e[k] === element) {\n            j = k;\n            break;\n          }\n        }\n      }\n\n      idx = j + 1;\n      len = l;\n      return dir ? l - j : idx;\n    };\n  }(),\n      // fast resolver for the :nth-of-type() and :nth-last-of-type() pseudo-classes\n  nthOfType = function () {\n    var idx = 0,\n        len = 0,\n        set = 0,\n        parent = undefined,\n        parents = Array(),\n        nodes = Array();\n    return function (element, dir) {\n      // ensure caches are emptied after each run, invoking with dir = 2\n      if (dir == 2) {\n        idx = 0;\n        len = 0;\n        set = 0;\n        nodes.length = 0;\n        parents.length = 0;\n        parent = undefined;\n        return -1;\n      }\n\n      var e,\n          i,\n          j,\n          k,\n          l,\n          name = element.nodeName;\n\n      if (nodes[set] && nodes[set][name] && parent === element.parentElement) {\n        i = set;\n        j = idx;\n        l = len;\n      } else {\n        l = parents.length;\n        parent = element.parentElement;\n\n        for (i = -1, j = 0, k = l - 1; l > j; ++j, --k) {\n          if (parents[j] === parent) {\n            i = j;\n            break;\n          }\n\n          if (parents[k] === parent) {\n            i = k;\n            break;\n          }\n        }\n\n        if (i < 0 || !nodes[i][name]) {\n          parents[i = l] = parent;\n          nodes[i] || (nodes[i] = Object());\n          l = 0;\n          nodes[i][name] = Array();\n          e = parent && parent.firstElementChild || element;\n\n          while (e) {\n            if (e === element) j = l;\n\n            if (e.nodeName == name) {\n              nodes[i][name][l] = e;\n              ++l;\n            }\n\n            e = e.nextElementSibling;\n          }\n\n          set = i;\n          idx = j;\n          len = l;\n          if (l < 2) return l;\n        } else {\n          l = nodes[i][name].length;\n          set = i;\n        }\n      }\n\n      if (element !== nodes[i][name][j] && element !== nodes[i][name][j = 0]) {\n        for (j = 0, e = nodes[i][name], k = l - 1; l > j; ++j, --k) {\n          if (e[j] === element) {\n            break;\n          }\n\n          if (e[k] === element) {\n            j = k;\n            break;\n          }\n        }\n      }\n\n      idx = j + 1;\n      len = l;\n      return dir ? l - j : idx;\n    };\n  }(),\n      // check if the document type is HTML\n  isHTML = function isHTML(node) {\n    var doc = node.ownerDocument || node;\n    return doc.nodeType == 9 && // contentType not in IE <= 11\n    'contentType' in doc ? doc.contentType.indexOf('/html') > 0 : doc.createElement('DiV').nodeName == 'DIV';\n  },\n      // configure the engine to use special handling\n  configure = function configure(option, clear) {\n    if (typeof option == 'string') {\n      return !!Config[option];\n    }\n\n    if (typeof option != 'object') {\n      return Config;\n    }\n\n    for (var i in option) {\n      Config[i] = !!option[i];\n    } // clear lambda cache\n\n\n    if (clear) {\n      matchResolvers = {};\n      selectResolvers = {};\n    }\n\n    setIdentifierSyntax();\n    return true;\n  },\n      // centralized error and exceptions handling\n  emit = function emit(message, proto) {\n    var err;\n\n    if (Config.VERBOSITY) {\n      if (proto) {\n        err = new proto(message);\n      } else {\n        err = new global.DOMException(message, 'SyntaxError');\n      }\n\n      throw err;\n    }\n\n    if (Config.LOGERRORS && console && console.log) {\n      console.log(message);\n    }\n  },\n      // execute the engine initialization code\n  initialize = function initialize(doc) {\n    setIdentifierSyntax();\n    lastContext = switchContext(doc, true);\n  },\n      // build validation regexps used by the engine\n  setIdentifierSyntax = function setIdentifierSyntax() {\n    //\n    // NOTE: SPECIAL CASES IN CSS SYNTAX PARSING RULES\n    //\n    // The <EOF-token> https://drafts.csswg.org/css-syntax/#typedef-eof-token\n    // allow mangled|unclosed selector syntax at the end of selectors strings\n    //\n    // Literal equivalent hex representations of the characters: \" ' ` ] )\n    //\n    //     \\\\x22 = \" - double quotes    \\\\x5b = [ - open square bracket\n    //     \\\\x27 = ' - single quote     \\\\x5d = ] - closed square bracket\n    //     \\\\x60 = ` - back tick        \\\\x28 = ( - open round parens\n    //     \\\\x5c = \\ - back slash       \\\\x29 = ) - closed round parens\n    //\n    // using hex format prevents false matches of opened/closed instances\n    // pairs, coloring breakage and other editors highlightning problems.\n    //\n    var identifier = // doesn't start with a digit\n    '(?=[^0-9])' + // can start with double dash\n    '(?:-{2}' + // may include ascii chars\n    '|[a-zA-Z0-9-_]' + // non-ascii chars\n    '|[^\\\\x00-\\\\x9f]' + // escaped chars\n    '|\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F]' + // unicode chars\n    '|\\\\\\\\[0-9a-fA-F]{1,6}(?:\\\\r\\\\n|\\\\s)?' + // any escaped chars\n    '|\\\\\\\\.' + ')+',\n        pseudonames = '[-\\\\w]+',\n        pseudoparms = '(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)',\n        doublequote = '\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(?:\"|$)',\n        singlequote = \"'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*(?:'|$)\",\n        attrparser = identifier + '|' + doublequote + '|' + singlequote,\n        attrvalues = '([\\\\x22\\\\x27]?)((?!\\\\3)*|(?:\\\\\\\\?.)*?)(?:\\\\3|$)',\n        attributes = '\\\\[' + // attribute presence\n    '(?:\\\\*\\\\|)?' + WSP + '?' + '(' + identifier + '(?::' + identifier + ')?)' + WSP + '?' + '(?:' + '(' + CFG.operators + ')' + WSP + '?' + '(?:' + attrparser + ')' + ')?' + // attribute case sensitivity\n    WSP + '?' + '(i)?' + WSP + '?' + '(?:\\\\]|$)',\n        attrmatcher = attributes.replace(attrparser, attrvalues),\n        pseudoclass = '(?:\\\\x28' + WSP + '*' + '(?:' + pseudoparms + '?)?|' + // universal * &\n    // namespace *|*\n    '(?:\\\\*|\\\\|)|' + '(?:' + '(?::' + pseudonames + '(?:\\\\x28' + pseudoparms + '?(?:\\\\x29|$))?|' + ')|' + '(?:[.#]?' + identifier + ')|' + '(?:' + attributes + ')' + ')+|' + '(?:' + WSP + '?,' + WSP + '?)|' + '(?:' + WSP + '?)|' + '(?:\\\\x29|$))*',\n        standardValidator = '(?=' + WSP + '?[^>+~(){}<>])' + '(?:' + // universal * &\n    // namespace *|*\n    '(?:\\\\*|\\\\|)|' + '(?:[.#]?' + identifier + ')+|' + '(?:' + attributes + ')+|' + '(?:::?' + pseudonames + pseudoclass + ')|' + '(?:' + WSP + '?' + CFG.combinators + WSP + '?)|' + '(?:' + WSP + '?,' + WSP + '?)|' + '(?:' + WSP + '?)' + ')+'; // the following global RE is used to return the\n    // deepest nodeName in selector strings and then\n    // use it to retrieve all possible matching nodes\n    // that will be filtered by compiled resolvers\n\n    reOptimizer = RegExp('(?:([.:#*]?)' + '(' + identifier + ')' + '(?:' + ':[-\\\\w]+|' + '\\\\[[^\\\\]]+(?:\\\\]|$)|' + '\\\\x28[^\\\\x29]+(?:\\\\x29|$)' + ')*)$'); // global\n\n    reValidator = RegExp(standardValidator, 'g');\n    Patterns.id = RegExp('^#(' + identifier + ')(.*)');\n    Patterns.tagName = RegExp('^(' + identifier + ')(.*)');\n    Patterns.className = RegExp('^\\\\.(' + identifier + ')(.*)');\n    Patterns.attribute = RegExp('^(?:' + attrmatcher + ')(.*)');\n  },\n      F_INIT = '\"use strict\";return function Resolver(c,f,x,r)',\n      S_HEAD = 'var e,n,o,j=r.length-1,k=-1',\n      M_HEAD = 'var e,n,o',\n      S_LOOP = 'main:while((e=c[++k]))',\n      N_LOOP = 'main:while((e=c.item(++k)))',\n      M_LOOP = 'e=c;',\n      S_BODY = 'r[++j]=c[k];',\n      N_BODY = 'r[++j]=c.item(k);',\n      M_BODY = '',\n      S_TAIL = 'continue main;',\n      M_TAIL = 'r=true;',\n      S_TEST = 'if(f(c[k])){break main;}',\n      N_TEST = 'if(f(c.item(k))){break main;}',\n      M_TEST = 'f(c);',\n      S_VARS = [],\n      M_VARS = [],\n      // compile groups or single selector strings into\n  // executable functions for matching or selecting\n  compile = function compile(selector, mode, callback) {\n    var factory,\n        token,\n        head = '',\n        loop = '',\n        macro = '',\n        source = '',\n        vars = ''; // 'mode' can be boolean or null\n    // true = select / false = match\n    // null to use collection.item()\n\n    switch (mode) {\n      case true:\n        if (selectLambdas[selector]) {\n          return selectLambdas[selector];\n        }\n\n        macro = S_BODY + (callback ? S_TEST : '') + S_TAIL;\n        head = S_HEAD;\n        loop = S_LOOP;\n        break;\n\n      case false:\n        if (matchLambdas[selector]) {\n          return matchLambdas[selector];\n        }\n\n        macro = M_BODY + (callback ? M_TEST : '') + M_TAIL;\n        head = M_HEAD;\n        loop = M_LOOP;\n        break;\n\n      case null:\n        if (selectLambdas[selector]) {\n          return selectLambdas[selector];\n        }\n\n        macro = N_BODY + (callback ? N_TEST : '') + S_TAIL;\n        head = S_HEAD;\n        loop = N_LOOP;\n        break;\n\n      default:\n        break;\n    }\n\n    source = compileSelector(selector, macro, mode, callback, false);\n    loop += mode || mode === null ? '{' + source + '}' : source;\n\n    if (mode || mode === null && selector.includes(':nth')) {\n      loop += reNthElem.test(selector) ? 's.nthElement(null, 2);' : '';\n      loop += reNthType.test(selector) ? 's.nthOfType(null, 2);' : '';\n    }\n\n    if (S_VARS[0] || M_VARS[0]) {\n      vars = ',' + (S_VARS.join(',') || M_VARS.join(','));\n      S_VARS.length = 0;\n      M_VARS.length = 0;\n    }\n\n    factory = Function('s', F_INIT + '{' + head + vars + ';' + loop + 'return r;}')(Snapshot);\n    return mode || mode === null ? selectLambdas[selector] = factory : matchLambdas[selector] = factory;\n  },\n      // build conditional code to check components of selector strings\n  compileSelector = function compileSelector(expression, source, mode, callback, not) {\n    // N is the negation pseudo-class flag\n    // D is the default inverted negation flag\n    var a,\n        b,\n        n,\n        f,\n        i,\n        l,\n        name,\n        nested,\n        NS,\n        N = not ? '!' : '',\n        D = not ? '' : '!',\n        compat,\n        expr,\n        match,\n        result,\n        status,\n        symbol,\n        test,\n        type,\n        selector = expression,\n        selector_string,\n        vars; // original 'select' or 'match' selector string before normalization\n\n    selector_string = mode ? lastSelected : lastMatched; // isolate selector combinators/components and normalize whitespace\n\n    selector = selector.replace(STD.combinator, '$1'); //.replace(STD.whitespace, ' ');\n\n    while (selector) {\n      // get namespace prefix if present or get first char of selector\n      symbol = STD.apimethods.test(selector) ? '|' : selector[0];\n\n      switch (symbol) {\n        // universal resolver\n        case '*':\n          match = selector.match(Patterns.universal);\n\n          if (N == '!') {\n            source = 'if(' + N + 'true' + '){' + source + '}';\n          }\n\n          break;\n        // id resolver\n\n        case '#':\n          match = selector.match(Patterns.id);\n          source = 'if(' + N + '(/^' + match[1] + '$/.test(e.getAttribute(\"id\"))' + ')){' + source + '}';\n          break;\n        // class name resolver\n\n        case '.':\n          match = selector.match(Patterns.className);\n          compat = (QUIRKS_MODE ? 'i' : '') + '.test(e.getAttribute(\"class\"))';\n          source = 'if(' + N + '(/(^|\\\\s)' + match[1] + '(\\\\s|$)/' + compat + ')){' + source + '}';\n          break;\n        // tag name resolver\n\n        case /[a-z]/i.test(symbol) ? symbol : undefined:\n          match = selector.match(Patterns.tagName);\n          source = 'if(' + N + '(e.nodeName' + (Config.MIXEDCASE || hasMixedCaseTagNames(doc) ? '.toLowerCase()==\"' + match[1].toLowerCase() + '\"' : '==\"' + match[1].toUpperCase() + '\"') + ')){' + source + '}';\n          break;\n        // namespace resolver\n\n        case '|':\n          match = selector.match(Patterns.namespace);\n\n          if (match[1] == '*') {\n            source = 'if(' + N + 'true){' + source + '}';\n          } else if (!match[1]) {\n            source = 'if(' + N + '(!e.namespaceURI)){' + source + '}';\n          } else if (typeof match[1] == 'string' && root.prefix == match[1]) {\n            source = 'if(' + N + '(e.namespaceURI==\"' + NAMESPACE + '\")){' + source + '}';\n          } else {\n            emit('\\'' + selector_string + '\\'' + qsInvalid);\n          }\n\n          break;\n        // attributes resolver\n\n        case '[':\n          match = selector.match(Patterns.attribute);\n          NS = match[0].match(STD.namespaces);\n          name = match[1];\n          expr = name.split(':');\n          expr = expr.length == 2 ? expr[1] : expr[0];\n\n          if (match[2] && !(test = Operators[match[2]])) {\n            emit('\\'' + selector_string + '\\'' + qsInvalid);\n            return '';\n          }\n\n          if (match[4] === '') {\n            test = match[2] == '~=' ? {\n              p1: '^\\\\s',\n              p2: '+$',\n              p3: 'true'\n            } : match[2] in ATTR_STD_OPS && match[2] != '~=' ? {\n              p1: '^',\n              p2: '$',\n              p3: 'true'\n            } : test;\n          } else if (match[2] == '~=' && match[4].includes(' ')) {\n            // whitespace separated list but value contains space\n            source = 'if(' + N + 'false){' + source + '}';\n            break;\n          } else if (match[4]) {\n            match[4] = convertEscapes(match[4]).replace(REX.RegExpChar, '\\\\$&');\n          }\n\n          type = HTML_DOCUMENT && HTML_TABLE[expr.toLowerCase()] ? 'i' : '';\n          source = 'if(' + N + '(' + (!match[2] ? NS ? 's.hasAttributeNS(e,\"' + name + '\")' : 'e.hasAttribute(\"' + name + '\")' : !match[4] && ATTR_STD_OPS[match[2]] && match[2] != '~=' ? 'e.getAttribute(\"' + name + '\")==\"\"' : '(/' + test.p1 + match[4] + test.p2 + '/' + type + ').test(e.getAttribute(\"' + name + '\"))==' + test.p3) + ')){' + source + '}';\n          break;\n        // *** General sibling combinator\n        // E ~ F (F relative sibling of E)\n\n        case '~':\n          match = selector.match(Patterns.relative);\n          source = 'n=e;while((e=e.previousElementSibling)){' + source + '}e=n;';\n          break;\n        // *** Adjacent sibling combinator\n        // E + F (F adiacent sibling of E)\n\n        case '+':\n          match = selector.match(Patterns.adjacent);\n          source = 'n=e;if((e=e.previousElementSibling)){' + source + '}e=n;';\n          break;\n        // *** Descendant combinator\n        // E F (E ancestor of F)\n\n        case '\\x09':\n        case '\\x20':\n          match = selector.match(Patterns.ancestor);\n          source = 'n=e;while((e=e.parentElement)){' + source + '}e=n;';\n          break;\n        // *** Child combinator\n        // E > F (F children of E)\n\n        case '>':\n          match = selector.match(Patterns.children);\n          source = 'n=e;if((e=e.parentElement)){' + source + '}e=n;';\n          break;\n        // *** user supplied combinators extensions\n\n        case symbol in Combinators ? symbol : undefined:\n          // for other registered combinators extensions\n          match[match.length - 1] = '*';\n          source = Combinators[symbol](match) + source;\n          break;\n        // *** tree-structural pseudo-classes\n        // :root, :empty, :first-child, :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type\n\n        case ':':\n          if (match = selector.match(Patterns.structural)) {\n            match[1] = match[1].toLowerCase();\n\n            switch (match[1]) {\n              case 'root':\n                // there can only be one :root element, so exit the loop once found\n                source = 'if(' + N + '(e===s.root)){' + source + (mode ? 'break main;' : '') + '}';\n                break;\n\n              case 'empty':\n                // matches elements that don't contain elements or text nodes\n                source = 'n=e.firstChild;while(n&&!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(' + D + 'n){' + source + '}';\n                break;\n              // *** child-indexed pseudo-classes\n              // :first-child, :last-child, :only-child\n\n              case 'only-child':\n                source = 'if(' + N + '(!e.nextElementSibling&&!e.previousElementSibling)){' + source + '}';\n                break;\n\n              case 'last-child':\n                source = 'if(' + N + '(!e.nextElementSibling)){' + source + '}';\n                break;\n\n              case 'first-child':\n                source = 'if(' + N + '(!e.previousElementSibling)){' + source + '}';\n                break;\n              // *** typed child-indexed pseudo-classes\n              // :only-of-type, :last-of-type, :first-of-type\n\n              case 'only-of-type':\n                source = 'o=e.nodeName;' + 'n=e;while((n=n.nextElementSibling)&&n.nodeName!=o);if(!n){' + 'n=e;while((n=n.previousElementSibling)&&n.nodeName!=o);}if(' + D + 'n){' + source + '}';\n                break;\n\n              case 'last-of-type':\n                source = 'n=e;o=e.nodeName;while((n=n.nextElementSibling)&&n.nodeName!=o);if(' + D + 'n){' + source + '}';\n                break;\n\n              case 'first-of-type':\n                source = 'n=e;o=e.nodeName;while((n=n.previousElementSibling)&&n.nodeName!=o);if(' + D + 'n){' + source + '}';\n                break;\n\n              default:\n                emit('\\'' + selector_string + '\\'' + qsInvalid);\n                break;\n            }\n          } // *** child-indexed & typed child-indexed pseudo-classes\n          // :nth-child, :nth-of-type, :nth-last-child, :nth-last-of-type\n          else if (match = selector.match(Patterns.treestruct)) {\n              match[1] = match[1].toLowerCase();\n\n              switch (match[1]) {\n                case 'nth-child':\n                case 'nth-of-type':\n                case 'nth-last-child':\n                case 'nth-last-of-type':\n                  expr = /-of-type/i.test(match[1]);\n\n                  if (match[1] && match[2]) {\n                    type = /last/i.test(match[1]);\n\n                    if (match[2] == 'n') {\n                      source = 'if(' + N + 'true){' + source + '}';\n                      break;\n                    } else if (match[2] == '1') {\n                      test = type ? 'next' : 'previous';\n                      source = expr ? 'n=e;o=e.nodeName;' + 'while((n=n.' + test + 'ElementSibling)&&n.nodeName!=o);if(' + D + 'n){' + source + '}' : 'if(' + N + '!e.' + test + 'ElementSibling){' + source + '}';\n                      break;\n                    } else if (match[2] == 'even' || match[2] == '2n0' || match[2] == '2n+0' || match[2] == '2n') {\n                      test = 'n%2==0';\n                    } else if (match[2] == 'odd' || match[2] == '2n1' || match[2] == '2n+1') {\n                      test = 'n%2==1';\n                    } else {\n                      f = /n/i.test(match[2]);\n                      n = match[2].split('n');\n                      a = parseInt(n[0], 10) || 0;\n                      b = parseInt(n[1], 10) || 0;\n\n                      if (n[0] == '-') {\n                        a = -1;\n                      }\n\n                      if (n[0] == '+') {\n                        a = +1;\n                      }\n\n                      test = (b ? '(n' + (b > 0 ? '-' : '+') + Math.abs(b) + ')' : 'n') + '%' + a + '==0';\n                      test = a >= +1 ? f ? 'n>' + (b - 1) + (Math.abs(a) != 1 ? '&&' + test : '') : 'n==' + a : a <= -1 ? f ? 'n<' + (b + 1) + (Math.abs(a) != 1 ? '&&' + test : '') : 'n==' + a : a === 0 ? n[0] ? 'n==' + b : 'n>' + (b - 1) : 'false';\n                    }\n\n                    expr = expr ? 'OfType' : 'Element';\n                    type = type ? 'true' : 'false';\n                    source = 'n=s.nth' + expr + '(e,' + type + ');if(' + N + '(' + test + ')){' + source + '}';\n                  } else {\n                    emit('\\'' + selector_string + '\\'' + qsInvalid);\n                  }\n\n                  break;\n\n                default:\n                  emit('\\'' + selector_string + '\\'' + qsInvalid);\n                  break;\n              }\n            } // *** logical combination pseudo-classes\n            // :matches( s1, [ s2, ... ]), :not( s1, [ s2, ... ])\n            else if (match = selector.match(Patterns.logicalsel)) {\n                match[1] = match[1].toLowerCase();\n\n                switch (match[1]) {\n                  case 'matches':\n                    if (not == true || nested == true) {\n                      emit(':matches() pseudo-class cannot be nested');\n                    }\n\n                    nested = true;\n                    expr = match[2].replace(REX.CommaGroup, ',').replace(REX.TrimSpaces, ''); // check nested compound selectors s1, s2\n\n                    expr = match[2].match(REX.SplitGroup);\n\n                    for (i = 0, l = expr.length; l > i; ++i) {\n                      expr[i] = expr[i].replace(REX.TrimSpaces, '');\n                      source = 'if(s.match(\"' + expr[i].replace(/\\x22/g, '\\\\\"') + '\",e)){' + source + '}';\n                    }\n\n                    break;\n\n                  case 'not':\n                    if (not == true || nested == true) {\n                      emit(':not() pseudo-class cannot be nested');\n                    }\n\n                    expr = match[2].replace(REX.CommaGroup, ',').replace(REX.TrimSpaces, ''); // check nested compound selectors s1, s2\n\n                    expr = match[2].match(REX.SplitGroup);\n\n                    for (i = 0, l = expr.length; l > i; ++i) {\n                      expr[i] = expr[i].replace(REX.TrimSpaces, '');\n                      source = compileSelector(expr[i], source, false, callback, true);\n                    }\n\n                    break;\n\n                  default:\n                    emit('\\'' + selector_string + '\\'' + qsInvalid);\n                    break;\n                }\n              } // *** linguistic pseudo-classes\n              // :dir( ltr / rtl ), :lang( en )\n              else if (match = selector.match(Patterns.linguistic)) {\n                  match[1] = match[1].toLowerCase();\n\n                  switch (match[1]) {\n                    case 'dir':\n                      source = 'var p;if(' + N + '(' + '(/' + match[2] + '/i.test(e.dir))||(p=s.ancestor(\"[dir]\", e))&&' + '(/' + match[2] + '/i.test(p.dir))||(e.dir==\"\"||e.dir==\"auto\")&&' + '(' + (match[2] == 'ltr' ? '!' : '') + RTL + '.test(e.textContent)))' + '){' + source + '};';\n                      break;\n\n                    case 'lang':\n                      expr = '(?:^|-)' + match[2] + '(?:-|$)';\n                      source = 'var p;if(' + N + '(' + '(e.isConnected&&(e.lang==\"\"&&(p=s.ancestor(\"[lang]\",e)))&&' + '(p.lang==\"' + match[2] + '\")||/' + expr + '/i.test(e.lang)))' + '){' + source + '};';\n                      break;\n\n                    default:\n                      emit('\\'' + selector_string + '\\'' + qsInvalid);\n                      break;\n                  }\n                } // *** location pseudo-classes\n                // :link, :visited, :target\n                else if (match = selector.match(Patterns.locationpc)) {\n                    match[1] = match[1].toLowerCase();\n\n                    switch (match[1]) {\n                      case 'link':\n                        source = 'if(' + N + '(/^a|area|link$/i.test(e.nodeName)&&e.hasAttribute(\"href\"))){' + source + '}';\n                        break;\n\n                      case 'visited':\n                        source = 'if(' + N + '(/^a|area|link$/i.test(e.nodeName)&&e.hasAttribute(\"href\")&&e.visited)){' + source + '}';\n                        break;\n\n                      case 'target':\n                        source = 'if(' + N + '((s.doc.compareDocumentPosition(e)&16)&&s.doc.location.hash&&e.id==s.doc.location.hash.slice(1))){' + source + '}';\n                        break;\n\n                      default:\n                        emit('\\'' + selector_string + '\\'' + qsInvalid);\n                        break;\n                    }\n                  } // *** user actions pseudo-classes\n                  // :hover, :active, :focus\n                  else if (match = selector.match(Patterns.useraction)) {\n                      match[1] = match[1].toLowerCase();\n\n                      switch (match[1]) {\n                        case 'hover':\n                          source = 'hasFocus' in doc && doc.hasFocus() ? 'if(' + N + '(e===s.doc.hoverElement)){' + source + '}' : 'if(' + D + 'true){' + source + '}';\n                          break;\n\n                        case 'active':\n                          source = 'hasFocus' in doc && doc.hasFocus() ? 'if(' + N + '(e===s.doc.activeElement)){' + source + '}' : 'if(' + D + 'true){' + source + '}';\n                          break;\n\n                        case 'focus':\n                          source = 'hasFocus' in doc ? 'if(' + N + '(e===s.doc.activeElement&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex==\"number\"))){' + source + '}' : 'if(' + N + '(e===s.doc.activeElement&&(e.type||e.href))){' + source + '}';\n                          break;\n\n                        case 'focus-within':\n                          source = 'hasFocus' in doc ? 'n=s.doc.activeElement;while(e){if(e===n||e.parentNode===n)break;}' + 'if(' + N + '(e===n&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex==\"number\"))){' + source + '}' : source;\n                          break;\n\n                        default:\n                          emit('\\'' + selector_string + '\\'' + qsInvalid);\n                          break;\n                      }\n                    } // *** user interface and form pseudo-classes\n                    // :enabled, :disabled, :read-only, :read-write, :placeholder-shown, :default\n                    else if (match = selector.match(Patterns.inputstate)) {\n                        match[1] = match[1].toLowerCase();\n\n                        switch (match[1]) {\n                          case 'enabled':\n                            source = 'if(' + N + '((\"form\" in e||/^optgroup$/i.test(e.nodeName))&&\"disabled\" in e &&e.disabled===false' + ')){' + source + '}';\n                            break;\n\n                          case 'disabled':\n                            // https://www.w3.org/TR/html5/forms.html#enabling-and-disabling-form-controls:-the-disabled-attribute\n                            source = 'if(' + N + '((\"form\" in e||/^optgroup$/i.test(e.nodeName))&&\"disabled\" in e&&' + '(e.disabled===true||(n=s.ancestor(\"fieldset\",e))&&(n=s.first(\"legend\",n))&&!n.contains(e))' + ')){' + source + '}';\n                            break;\n\n                          case 'read-only':\n                            source = 'if(' + N + '(' + '(/^textarea$/i.test(e.nodeName)&&(e.readOnly||e.disabled))||' + '(\"|password|text|\".includes(\"|\"+e.type+\"|\")&&e.readOnly)' + ')){' + source + '}';\n                            break;\n\n                          case 'read-write':\n                            source = 'if(' + N + '(' + '((/^textarea$/i.test(e.nodeName)&&!e.readOnly&&!e.disabled)||' + '(\"|password|text|\".includes(\"|\"+e.type+\"|\")&&!e.readOnly&&!e.disabled))||' + '(e.hasAttribute(\"contenteditable\")||(s.doc.designMode==\"on\"))' + ')){' + source + '}';\n                            break;\n\n                          case 'placeholder-shown':\n                            source = 'if(' + N + '(' + '(/^input|textarea$/i.test(e.nodeName))&&e.hasAttribute(\"placeholder\")&&' + '(\"|textarea|password|number|search|email|text|tel|url|\".includes(\"|\"+e.type+\"|\"))&&' + '(!s.match(\":focus\",e))' + ')){' + source + '}';\n                            break;\n\n                          case 'default':\n                            source = 'if(' + N + '(\"form\" in e && e.form)){' + 'var x=0;n=[];' + 'if(e.type==\"image\")n=e.form.getElementsByTagName(\"input\");' + 'if(e.type==\"submit\")n=e.form.elements;' + 'while(n[x]&&e!==n[x]){' + 'if(n[x].type==\"image\")break;' + 'if(n[x].type==\"submit\")break;' + 'x++;' + '}' + '}' + 'if(' + N + '(e.form&&(e===n[x]&&\"|image|submit|\".includes(\"|\"+e.type+\"|\"))||' + '((/^option$/i.test(e.nodeName))&&e.defaultSelected)||' + '((\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\"))&&e.defaultChecked)' + ')){' + source + '}';\n                            break;\n\n                          default:\n                            emit('\\'' + selector_string + '\\'' + qsInvalid);\n                            break;\n                        }\n                      } // *** input pseudo-classes (for form validation)\n                      // :checked, :indeterminate, :valid, :invalid, :in-range, :out-of-range, :required, :optional\n                      else if (match = selector.match(Patterns.inputvalue)) {\n                          match[1] = match[1].toLowerCase();\n\n                          switch (match[1]) {\n                            case 'checked':\n                              source = 'if(' + N + '(/^input$/i.test(e.nodeName)&&' + '(\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\")&&e.checked)||' + '(/^option$/i.test(e.nodeName)&&(e.selected||e.checked))' + ')){' + source + '}';\n                              break;\n\n                            case 'indeterminate':\n                              source = 'if(' + N + '(/^progress$/i.test(e.nodeName)&&!e.hasAttribute(\"value\"))||' + '(/^input$/i.test(e.nodeName)&&(\"checkbox\"==e.type&&e.indeterminate)||' + '(\"radio\"==e.type&&e.name&&!s.first(\"input[name=\"+e.name+\"]:checked\",e.form))' + ')){' + source + '}';\n                              break;\n\n                            case 'required':\n                              source = 'if(' + N + '(/^input|select|textarea$/i.test(e.nodeName)&&e.required)' + '){' + source + '}';\n                              break;\n\n                            case 'optional':\n                              source = 'if(' + N + '(/^input|select|textarea$/i.test(e.nodeName)&&!e.required)' + '){' + source + '}';\n                              break;\n\n                            case 'invalid':\n                              source = 'if(' + N + '((' + '(/^form$/i.test(e.nodeName)&&!e.noValidate)||' + '(e.willValidate&&!e.formNoValidate))&&!e.checkValidity())||' + '(/^fieldset$/i.test(e.nodeName)&&s.first(\":invalid\",e))' + '){' + source + '}';\n                              break;\n\n                            case 'valid':\n                              source = 'if(' + N + '((' + '(/^form$/i.test(e.nodeName)&&!e.noValidate)||' + '(e.willValidate&&!e.formNoValidate))&&e.checkValidity())||' + '(/^fieldset$/i.test(e.nodeName)&&s.first(\":valid\",e))' + '){' + source + '}';\n                              break;\n\n                            case 'in-range':\n                              source = 'if(' + N + '(/^input$/i.test(e.nodeName))&&' + '(e.willValidate&&!e.formNoValidate)&&' + '(!e.validity.rangeUnderflow&&!e.validity.rangeOverflow)&&' + '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' + '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' + '){' + source + '}';\n                              break;\n\n                            case 'out-of-range':\n                              source = 'if(' + N + '(/^input$/i.test(e.nodeName))&&' + '(e.willValidate&&!e.formNoValidate)&&' + '(e.validity.rangeUnderflow||e.validity.rangeOverflow)&&' + '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' + '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' + '){' + source + '}';\n                              break;\n\n                            default:\n                              emit('\\'' + selector_string + '\\'' + qsInvalid);\n                              break;\n                          }\n                        } // allow pseudo-elements starting with single colon (:)\n                        // :after, :before, :first-letter, :first-line, :placeholder-shown, :-webkit-<foo-bar>\n                        else if (match = selector.match(Patterns.pseudo_sng)) {\n                            source = 'if(' + D + '(/1|11/).test(e.nodeType)){' + source + '}';\n                          } // allow pseudo-elements starting with double colon (::)\n                          // ::after, ::before, ::marker, ::placeholder, ::inactive-selection, ::selection\n                          else if (match = selector.match(Patterns.pseudo_dbl)) {\n                              source = 'if(' + D + '(/1|11/).test(e.nodeType)){' + source + '}';\n                            } else {\n                              // reset\n                              expr = false;\n                              status = false; // process registered selector extensions\n\n                              for (expr in Selectors) {\n                                if (match = selector.match(Selectors[expr].Expression)) {\n                                  result = Selectors[expr].Callback(match, source, mode, callback);\n\n                                  if ('match' in result) {\n                                    match = result.match;\n                                  }\n\n                                  vars = result.modvar;\n\n                                  if (mode) {\n                                    // add extra select() vars\n                                    vars && S_VARS.indexOf(vars) < 0 && (S_VARS[S_VARS.length] = vars);\n                                  } else {\n                                    // add extra match() vars\n                                    vars && M_VARS.indexOf(vars) < 0 && (M_VARS[M_VARS.length] = vars);\n                                  } // extension source code\n\n\n                                  source = result.source; // extension status code\n\n                                  status = result.status; // break on status error\n\n                                  if (status) {\n                                    break;\n                                  }\n                                }\n                              }\n\n                              if (!status) {\n                                emit('unknown pseudo-class selector \\'' + selector + '\\'');\n                                return '';\n                              }\n\n                              if (!expr) {\n                                emit('unknown token in selector \\'' + selector + '\\'');\n                                return '';\n                              }\n                            }\n\n          break;\n\n        default:\n          emit('\\'' + selector_string + '\\'' + qsInvalid);\n          break;\n      } // end of switch symbol\n\n\n      if (!match) {\n        emit('\\'' + selector_string + '\\'' + qsInvalid);\n        return '';\n      } // pop last component\n\n\n      selector = match.pop();\n    } // end of while selector\n\n\n    return source;\n  },\n      // replace ':scope' pseudo-class with element references\n  makeref = function makeref(selectors, element) {\n    return selectors.replace(/:scope/i, element.nodeName.toLowerCase() + (element.id ? '#' + element.id : '') + (element.className ? '.' + element.classList[0] : ''));\n  },\n      // equivalent of w3c 'closest' method\n  ancestor = function _closest(selectors, element, callback) {\n    if (/:scope/i.test(selectors)) {\n      selectors = makeref(selectors, element);\n    }\n\n    while (element) {\n      if (match(selectors, element, callback)) break;\n      element = element.parentElement;\n    }\n\n    return element;\n  },\n      match_assert = function match_assert(f, element, callback) {\n    for (var i = 0, l = f.length, r = false; l > i; ++i) {\n      f[i](element, callback, null, false) && (r = true);\n    }\n\n    return r;\n  },\n      match_collect = function match_collect(selectors, callback) {\n    for (var i = 0, l = selectors.length, f = []; l > i; ++i) {\n      f[i] = compile(selectors[i], false, callback);\n    }\n\n    return {\n      factory: f\n    };\n  },\n      // equivalent of w3c 'matches' method\n  match = function _matches(selectors, element, callback) {\n    var expressions, parsed;\n\n    if (element && matchResolvers[selectors]) {\n      return match_assert(matchResolvers[selectors].factory, element, callback);\n    }\n\n    lastMatched = selectors; // arguments validation\n\n    if (arguments.length === 0) {\n      emit(qsNotArgs, TypeError);\n      return Config.VERBOSITY ? undefined : false;\n    } else if (arguments[0] === '') {\n      emit('\\'\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    } // input NULL or UNDEFINED\n\n\n    if (typeof selectors != 'string') {\n      selectors = '' + selectors;\n    }\n\n    if (/:scope/i.test(selectors)) {\n      selectors = makeref(selectors, element);\n    } // normalize input string\n\n\n    parsed = selectors.replace(/\\x00|\\\\$/g, \"\\uFFFD\").replace(REX.CombineWSP, '\\x20').replace(REX.PseudosWSP, '$1').replace(REX.TabCharWSP, '\\t').replace(REX.CommaGroup, ',').replace(REX.TrimSpaces, ''); // parse, validate and split possible compound selectors\n\n    if ((expressions = parsed.match(reValidator)) && expressions.join('') == parsed) {\n      expressions = parsed.match(REX.SplitGroup);\n\n      if (parsed[parsed.length - 1] == ',') {\n        emit(qsInvalid);\n        return Config.VERBOSITY ? undefined : false;\n      }\n    } else {\n      emit('\\'' + selectors + '\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    }\n\n    matchResolvers[selectors] = match_collect(expressions, callback);\n    return match_assert(matchResolvers[selectors].factory, element, callback);\n  },\n      // equivalent of w3c 'querySelector' method\n  first = function _querySelector(selectors, context, callback) {\n    if (arguments.length === 0) {\n      emit(qsNotArgs, TypeError);\n    }\n\n    return select(selectors, context, typeof callback == 'function' ? function firstMatch(element) {\n      callback(element);\n      return false;\n    } : function firstMatch() {\n      return false;\n    })[0] || null;\n  },\n      // equivalent of w3c 'querySelectorAll' method\n  select = function _querySelectorAll(selectors, context, callback) {\n    var expressions, nodes, parsed, resolver;\n    context || (context = doc);\n\n    if (selectors) {\n      if (resolver = selectResolvers[selectors]) {\n        if (resolver.context === context && resolver.callback === callback) {\n          nodes = results_from(resolver, context, callback);\n          Config.LIVECACHE && !/\\[[^\\]]*\\]/.test(selectors) && (resolver.results = nodes);\n          return typeof callback == 'function' ? concatCall(nodes, callback) : nodes;\n        }\n      }\n    }\n\n    lastSelected = selectors; // arguments validation\n\n    if (arguments.length === 0) {\n      emit(qsNotArgs, TypeError);\n      return Config.VERBOSITY ? undefined : none;\n    } else if (arguments[0] === '') {\n      emit('\\'\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : none;\n    } else if (lastContext !== context) {\n      lastContext = switchContext(context);\n    } // input NULL or UNDEFINED\n\n\n    if (typeof selectors != 'string') {\n      selectors = '' + selectors;\n    }\n\n    if (/:scope/i.test(selectors)) {\n      selectors = makeref(selectors, context);\n    } // normalize input string\n\n\n    parsed = selectors.replace(/\\x00|\\\\$/g, \"\\uFFFD\").replace(REX.CombineWSP, '\\x20').replace(REX.PseudosWSP, '$1').replace(REX.TabCharWSP, '\\t').replace(REX.CommaGroup, ',').replace(REX.TrimSpaces, ''); // parse, validate and split possible compound selectors\n\n    if ((expressions = parsed.match(reValidator)) && expressions.join('') == parsed) {\n      expressions = parsed.match(REX.SplitGroup);\n\n      if (parsed[parsed.length - 1] == ',') {\n        emit(qsInvalid);\n        return Config.VERBOSITY ? undefined : false;\n      }\n    } else {\n      emit('\\'' + selectors + '\\'' + qsInvalid);\n      return Config.VERBOSITY ? undefined : false;\n    } // save/reuse factory and closure collection\n\n\n    selectResolvers[selectors] = collect(expressions, context, callback);\n    nodes = results_from(selectResolvers[selectors], context, callback);\n    return typeof callback == 'function' ? concatCall(nodes, callback) : nodes;\n  },\n      // optimize selectors avoiding duplicated checks\n  optimize = function optimize(selector, token) {\n    var index = token.index,\n        length = token[1].length + token[2].length;\n    return selector.slice(0, index) + (' >+~'.indexOf(selector.charAt(index - 1)) > -1 ? ':['.indexOf(selector.charAt(index + length + 1)) > -1 ? '*' : '' : '') + selector.slice(index + length - (token[1] == '*' ? 1 : 0));\n  },\n      results_from = function results_from(resolver, context, callback) {\n    var i,\n        k,\n        l,\n        list,\n        nodes = [],\n        f = resolver.factory,\n        h = resolver.htmlset,\n        n = resolver.nodeset,\n        r = resolver.results;\n\n    for (i = 0, k = 0, l = n.length; l > i; ++i) {\n      list = r && h[i] ? h[i]() : compat[n[i][0]](context, n[i].slice(1))();\n\n      if (f[i] !== null) {\n        if (r && h[i]) {\n          if (list.item || validate(resolver, n[i], list)) {\n            ++k;\n          } else {\n            f[i](list, callback, context, nodes);\n          }\n        } else {\n          f[i](list, callback, context, nodes);\n        }\n      } else {\n        if (list.length !== 0) {\n          list.length == 1 ? nodes[nodes.length] = list[0] : concatList(nodes, list);\n        }\n      }\n\n      if (r && h[i]) {\n        if (k == l) {\n          nodes = r;\n        }\n      } else {\n        if (l > 1 && nodes.length > 1) {\n          nodes.sort(documentOrder);\n          hasDupes && (nodes = unique(nodes));\n        }\n      }\n    }\n\n    return nodes;\n  },\n      // validate memoized HTMLCollection\n  validate = function validate(resolver, n, s) {\n    var c = 0,\n        i = 0,\n        l = s.length,\n        m;\n\n    if (l === 0) {\n      return false;\n    }\n\n    m = compat[n[0]](resolver.context, n.slice(1))();\n\n    if (m.item && s.item) {\n      while (l > i) {\n        if (m.item(i) === s.item(c)) {\n          ++i;\n          ++c;\n        } else return false;\n      }\n    } else {\n      while (l > i) {\n        if (m[i] === s[c]) {\n          ++i;\n          ++c;\n        } else return false;\n      }\n    }\n\n    return m.length == c;\n  },\n      // prepare factory resolvers and closure collections\n  collect = function collect(selectors, context, callback) {\n    var i,\n        l,\n        token,\n        seen = {},\n        factory = [],\n        htmlset = [],\n        nodeset = [];\n\n    for (i = 0, l = selectors.length; l > i; ++i) {\n      if (!seen[selectors[i]] && (seen[selectors[i]] = true)) {\n        if ((token = selectors[i].match(reOptimizer)) && token[1] != ':') {\n          Config.LIVECACHE && !/\\[[^\\]]*\\]/.test(selectors[i]) && (htmlset[i] = compat[token[1] || '*'](context, token[2]));\n          nodeset[i] = (token[1] || '*') + token[2];\n          selectors[i] = optimize(selectors[i], token);\n        } else if (token && token[1] != ':') {\n          Config.LIVECACHE && !/\\[[^\\]]*\\]/.test(selectors[i]) && (htmlset[i] = compat['*'](context, '*'));\n          nodeset[i] = '**';\n        } else {\n          nodeset[i] = '**';\n        }\n\n        factory[i] = selectors[i] == '*' ? null : compile(selectors[i], true, null);\n      }\n    }\n\n    return {\n      callback: callback,\n      context: context,\n      factory: factory,\n      htmlset: htmlset,\n      nodeset: nodeset,\n      results: null\n    };\n  },\n      // QSA placeholders to native references\n  _closest,\n      _matches,\n      _querySelector,\n      _querySelectorAll,\n      // overrides QSA methods (only for browsers)\n  install = function install(all) {\n    // save native QSA references\n    _closest = Element.prototype.closest;\n    _matches = Element.prototype.matches;\n    _querySelector = Document.prototype.querySelector;\n    _querySelectorAll = Document.prototype.querySelectorAll;\n\n    Element.prototype.closest = function closest() {\n      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;\n\n      if (!('nodeType' in this)) {\n        emit('\\'closest\\' called on an object that does not implement interface ' + ctor + '.', TypeError);\n      }\n\n      return arguments.length < 1 ? ancestor.apply(this, []) : arguments.length < 2 ? ancestor.apply(this, [arguments[0], this]) : ancestor.apply(this, [arguments[0], this, typeof arguments[1] == 'function' ? arguments[1] : undefined]);\n    };\n\n    Element.prototype.matches = function matches() {\n      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;\n\n      if (!('nodeType' in this)) {\n        emit('\\'matches\\' called on an object that does not implement interface ' + ctor + '.', TypeError);\n      }\n\n      return arguments.length < 1 ? match.apply(this, []) : arguments.length < 2 ? match.apply(this, [arguments[0], this]) : match.apply(this, [arguments[0], this, typeof arguments[1] == 'function' ? arguments[1] : undefined]);\n    };\n\n    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = function querySelector() {\n      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;\n\n      if (!('nodeType' in this)) {\n        emit('\\'querySelector\\' called on an object that does not implement interface ' + ctor + '.', TypeError);\n      }\n\n      return arguments.length < 1 ? first.apply(this, []) : arguments.length < 2 ? first.apply(this, [arguments[0], this]) : first.apply(this, [arguments[0], this, typeof arguments[1] == 'function' ? arguments[1] : undefined]);\n    };\n\n    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = function querySelectorAll() {\n      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;\n\n      if (!('nodeType' in this)) {\n        emit('\\'querySelectorAll\\' called on an object that does not implement interface ' + ctor + '.', TypeError);\n      }\n\n      return arguments.length < 1 ? select.apply(this, []) : arguments.length < 2 ? select.apply(this, [arguments[0], this]) : select.apply(this, [arguments[0], this, typeof arguments[1] == 'function' ? arguments[1] : undefined]);\n    };\n\n    if (all) {\n      document.addEventListener('load', function (e) {\n        var c,\n            d,\n            r,\n            s,\n            t = e.target;\n\n        if (/iframe/i.test(t.nodeName)) {\n          c = '(' + Export + ')(this, ' + Factory + ');';\n          d = t.contentDocument;\n          s = d.createElement('script');\n          s.textContent = c + 'NW.Dom.install()';\n          r = d.documentElement;\n          r.removeChild(r.insertBefore(s, r.firstChild));\n        }\n      }, true);\n    }\n  },\n      // restore QSA methods (only for browsers)\n  uninstall = function uninstall() {\n    // reinstates QSA native references\n    Element.prototype.closest = _closest;\n    Element.prototype.matches = _matches;\n    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = _querySelector;\n    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = _querySelectorAll;\n  },\n      // empty set\n  none = Array(),\n      // context\n  lastContext,\n      // selector\n  lastMatched,\n      lastSelected,\n      // cached lambdas\n  matchLambdas = {},\n      selectLambdas = {},\n      // cached resolvers\n  matchResolvers = {},\n      selectResolvers = {},\n      // passed to resolvers\n  Snapshot = {\n    doc: doc,\n    from: doc,\n    root: root,\n    byTag: byTag,\n    first: first,\n    match: match,\n    ancestor: ancestor,\n    nthOfType: nthOfType,\n    nthElement: nthElement,\n    hasAttributeNS: hasAttributeNS\n  },\n      // public exported methods/objects\n  Dom = {\n    // exported cache objects\n    lastMatched: lastMatched,\n    lastSelected: lastSelected,\n    matchLambdas: matchLambdas,\n    selectLambdas: selectLambdas,\n    matchResolvers: matchResolvers,\n    selectResolvers: selectResolvers,\n    // exported compiler macros\n    CFG: CFG,\n    M_BODY: M_BODY,\n    S_BODY: S_BODY,\n    M_TEST: M_TEST,\n    S_TEST: S_TEST,\n    // exported engine methods\n    byId: byId,\n    byTag: byTag,\n    byClass: byClass,\n    match: match,\n    first: first,\n    select: select,\n    closest: ancestor,\n    compile: compile,\n    configure: configure,\n    emit: emit,\n    Config: Config,\n    Snapshot: Snapshot,\n    Version: version,\n    install: install,\n    uninstall: uninstall,\n    Operators: Operators,\n    Selectors: Selectors,\n    // register a new selector combinator symbol and its related function resolver\n    registerCombinator: function registerCombinator(combinator, resolver) {\n      var i = 0,\n          l = combinator.length,\n          symbol;\n\n      for (; l > i; ++i) {\n        if (combinator[i] != '=') {\n          symbol = combinator[i];\n          break;\n        }\n      }\n\n      if (CFG.combinators.indexOf(symbol) < 0) {\n        CFG.combinators = CFG.combinators.replace('](', symbol + '](');\n        CFG.combinators = CFG.combinators.replace('])', symbol + '])');\n        Combinators[combinator] = resolver;\n        setIdentifierSyntax();\n      } else {\n        console.warn('Warning: the \\'' + combinator + '\\' combinator is already registered.');\n      }\n    },\n    // register a new attribute operator symbol and its related function resolver\n    registerOperator: function registerOperator(operator, resolver) {\n      var i = 0,\n          l = operator.length,\n          symbol;\n\n      for (; l > i; ++i) {\n        if (operator[i] != '=') {\n          symbol = operator[i];\n          break;\n        }\n      }\n\n      if (CFG.operators.indexOf(symbol) < 0 && !Operators[operator]) {\n        CFG.operators = CFG.operators.replace(']=', symbol + ']=');\n        Operators[operator] = resolver;\n        setIdentifierSyntax();\n      } else {\n        console.warn('Warning: the \\'' + operator + '\\' operator is already registered.');\n      }\n    },\n    // register a new selector symbol and its related function resolver\n    registerSelector: function registerSelector(name, rexp, func) {\n      Selectors[name] || (Selectors[name] = {\n        Expression: rexp,\n        Callback: func\n      });\n    }\n  };\n\n  initialize(doc);\n  return Dom;\n});","map":null,"metadata":{},"sourceType":"script"}