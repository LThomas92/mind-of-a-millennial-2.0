{"ast":null,"code":"/* eslint-env browser */\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/Lawrence/Desktop/mind-of-a-millennial/client/node_modules/@babel/runtime/helpers/inherits\");\n\nvar DOMException = require(\"domexception\");\n\nvar _require = require(\"whatwg-url\"),\n    parseURL = _require.parseURL,\n    serializeURL = _require.serializeURL,\n    serializeURLOrigin = _require.serializeURLOrigin;\n\nvar _require2 = require(\"../helpers/create-event-accessor\"),\n    setupForSimpleEventAccessors = _require2.setupForSimpleEventAccessors;\n\nvar EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\n\nvar idlUtils = require(\"../generated/utils\");\n\nvar Blob = require(\"../generated/Blob\");\n\nvar CloseEvent = require(\"../generated/CloseEvent\");\n\nvar Event = require(\"../generated/Event\");\n\nvar MessageEvent = require(\"../generated/MessageEvent\");\n\nvar productions = {\n  // https://tools.ietf.org/html/rfc7230#section-3.2.6\n  token: /^[!#$%&'*+\\-.^_`|~\\dA-Za-z]+$/\n}; // https://tools.ietf.org/html/rfc6455#section-4.3\n// See Sec-WebSocket-Protocol-Client, which is for the syntax of an entire header value. This function checks if a\n// single header conforms to the rules.\n\nfunction verifySecWebSocketProtocol(str) {\n  return productions.token.test(str);\n}\n\nvar openSockets = new WeakMap();\n\nvar WebSocketImpl =\n/*#__PURE__*/\nfunction (_EventTargetImpl) {\n  _inherits(WebSocketImpl, _EventTargetImpl);\n\n  function WebSocketImpl(constructorArgs, privateData) {\n    var _this;\n\n    _classCallCheck(this, WebSocketImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebSocketImpl).call(this, [], privateData));\n    var window = privateData.window;\n    _this._ownerDocument = idlUtils.implForWrapper(window._document);\n    var url = constructorArgs[0];\n    var protocols = constructorArgs[1] !== undefined ? constructorArgs[1] : [];\n    var urlRecord = parseURL(url);\n\n    if (urlRecord === null) {\n      throw new DOMException(\"The URL '\".concat(url, \"' is invalid.\"), \"SyntaxError\");\n    }\n\n    if (urlRecord.scheme !== \"ws\" && urlRecord.scheme !== \"wss\") {\n      throw new DOMException(\"The URL's scheme must be either 'ws' or 'wss'. '\".concat(urlRecord.scheme, \"' is not allowed.\"), \"SyntaxError\");\n    }\n\n    if (urlRecord.fragment !== null) {\n      throw new DOMException(\"The URL contains a fragment identifier ('\".concat(urlRecord.fragment, \"'). Fragment identifiers \") + \"are not allowed in WebSocket URLs.\", \"SyntaxError\");\n    }\n\n    if (typeof protocols === \"string\") {\n      protocols = [protocols];\n    }\n\n    var protocolSet = new Set();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = protocols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var protocol = _step.value;\n\n        if (!verifySecWebSocketProtocol(protocol)) {\n          throw new DOMException(\"The subprotocol '\".concat(protocol, \"' is invalid.\"), \"SyntaxError\");\n        }\n\n        var lowered = protocol.toLowerCase();\n\n        if (protocolSet.has(lowered)) {\n          throw new DOMException(\"The subprotocol '\".concat(protocol, \"' is duplicated.\"), \"SyntaxError\");\n        }\n\n        protocolSet.add(lowered);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _this._urlRecord = urlRecord;\n    _this.url = serializeURL(urlRecord);\n    _this._ws = new WebSocket(_this.url, protocols);\n\n    _this._ws.onopen = function () {\n      _this._dispatch(Event.createImpl([\"open\"], {\n        isTrusted: true\n      }));\n    };\n\n    _this._ws.onerror = function () {\n      _this._dispatch(Event.createImpl([\"error\"], {\n        isTrusted: true\n      }));\n    };\n\n    _this._ws.onclose = function (event) {\n      _this._dispatch(CloseEvent.createImpl([\"close\", {\n        wasClean: event.wasClean,\n        code: event.code,\n        reason: event.reason\n      }], {\n        isTrusted: true\n      }));\n    };\n\n    _this._ws.onmessage = function (event) {\n      _this._dispatch(MessageEvent.createImpl([\"message\", {\n        data: event.data,\n        origin: serializeURLOrigin(_this._urlRecord)\n      }], {\n        isTrusted: true\n      }));\n    };\n\n    var openSocketsForWindow = openSockets.get(window._globalProxy);\n\n    if (openSocketsForWindow === undefined) {\n      openSocketsForWindow = new Set();\n      openSockets.set(window._globalProxy, openSocketsForWindow);\n    }\n\n    openSocketsForWindow.add(_assertThisInitialized(_this));\n    return _this;\n  } // https://html.spec.whatwg.org/multipage/web-sockets.html#make-disappear\n\n\n  _createClass(WebSocketImpl, [{\n    key: \"_makeDisappear\",\n    value: function _makeDisappear() {\n      this._eventListeners = Object.create(null);\n\n      this._ws.close(1001);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n      if (code !== undefined && code !== 1000 && !(code >= 3000 && code <= 4999)) {\n        throw new DOMException(\"The code must be either 1000, or between 3000 and 4999. \".concat(code, \" is neither.\"), \"InvalidAccessError\");\n      }\n\n      if (reason !== undefined && Buffer.byteLength(reason, \"utf8\") > 123) {\n        throw new DOMException(\"The message must not be greater than 123 bytes.\", \"SyntaxError\");\n      }\n\n      return this._ws.close(code, reason);\n    }\n  }, {\n    key: \"send\",\n    value: function send(data) {\n      if (Blob.isImpl(data)) {\n        data = data._buffer;\n      }\n\n      this._ws.send(data);\n    }\n  }, {\n    key: \"readyState\",\n    get: function get() {\n      return this._ws.readyState;\n    }\n  }, {\n    key: \"bufferedAmount\",\n    get: function get() {\n      return this._ws.bufferedAmount;\n    }\n  }, {\n    key: \"extensions\",\n    get: function get() {\n      return this._ws.extensions;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._ws.protocol;\n    }\n  }, {\n    key: \"binaryType\",\n    get: function get() {\n      return this._ws.binaryType;\n    },\n    set: function set(val) {\n      this._ws.binaryType = val;\n    }\n  }], [{\n    key: \"cleanUpWindow\",\n    value: function cleanUpWindow(window) {\n      var openSocketsForWindow = openSockets.get(window._globalProxy);\n\n      if (openSocketsForWindow !== undefined) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = openSocketsForWindow[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var ws = _step2.value;\n\n            ws._makeDisappear();\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return WebSocketImpl;\n}(EventTargetImpl);\n\nsetupForSimpleEventAccessors(WebSocketImpl.prototype, [\"open\", \"message\", \"error\", \"close\"]);\nexports.implementation = WebSocketImpl;","map":null,"metadata":{},"sourceType":"script"}